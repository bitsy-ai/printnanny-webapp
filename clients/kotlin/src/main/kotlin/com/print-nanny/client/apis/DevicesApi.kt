/**
 * 
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.print-nanny.client.apis

import com.print-nanny.client.models.Camera
import com.print-nanny.client.models.CameraRequest
import com.print-nanny.client.models.CloudiotDevice
import com.print-nanny.client.models.CloudiotDeviceRequest
import com.print-nanny.client.models.Device
import com.print-nanny.client.models.DeviceConfig
import com.print-nanny.client.models.DeviceInfo
import com.print-nanny.client.models.DeviceInfoRequest
import com.print-nanny.client.models.DeviceRequest
import com.print-nanny.client.models.DeviceState
import com.print-nanny.client.models.ErrorDetail
import com.print-nanny.client.models.PaginatedCameraList
import com.print-nanny.client.models.PaginatedCloudiotDeviceList
import com.print-nanny.client.models.PaginatedDeviceConfigList
import com.print-nanny.client.models.PaginatedDeviceInfoList
import com.print-nanny.client.models.PaginatedDeviceList
import com.print-nanny.client.models.PaginatedDeviceStateList
import com.print-nanny.client.models.PaginatedPrinterControllerList
import com.print-nanny.client.models.PatchedCameraRequest
import com.print-nanny.client.models.PatchedCloudiotDeviceRequest
import com.print-nanny.client.models.PatchedDeviceInfoRequest
import com.print-nanny.client.models.PatchedDeviceRequest
import com.print-nanny.client.models.PatchedPrinterControllerRequest
import com.print-nanny.client.models.PrinterController

import com.print-nanny.client.infrastructure.ApiClient
import com.print-nanny.client.infrastructure.ClientException
import com.print-nanny.client.infrastructure.ClientError
import com.print-nanny.client.infrastructure.ServerException
import com.print-nanny.client.infrastructure.ServerError
import com.print-nanny.client.infrastructure.MultiValueMap
import com.print-nanny.client.infrastructure.RequestConfig
import com.print-nanny.client.infrastructure.RequestMethod
import com.print-nanny.client.infrastructure.ResponseType
import com.print-nanny.client.infrastructure.Success
import com.print-nanny.client.infrastructure.toMultiValue

class DevicesApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("com.print-nanny.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param deviceInfoRequest  
    * @return DeviceInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deviceInfoUpdateOrCreate(deviceId: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : DeviceInfo {
        val localVariableConfig = deviceInfoUpdateOrCreateRequestConfig(deviceId = deviceId, deviceInfoRequest = deviceInfoRequest)

        val localVarResponse = request<DeviceInfoRequest, DeviceInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation deviceInfoUpdateOrCreate
    *
    * @param deviceId  
    * @param deviceInfoRequest  
    * @return RequestConfig
    */
    fun deviceInfoUpdateOrCreateRequestConfig(deviceId: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : RequestConfig<DeviceInfoRequest> {
        val localVariableBody = deviceInfoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/{device_id}/info/update-or-create/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param cameraRequest  
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCamerasCreate(deviceId: kotlin.Int, cameraRequest: CameraRequest) : Camera {
        val localVariableConfig = devicesCamerasCreateRequestConfig(deviceId = deviceId, cameraRequest = cameraRequest)

        val localVarResponse = request<CameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCamerasCreate
    *
    * @param deviceId  
    * @param cameraRequest  
    * @return RequestConfig
    */
    fun devicesCamerasCreateRequestConfig(deviceId: kotlin.Int, cameraRequest: CameraRequest) : RequestConfig<CameraRequest> {
        val localVariableBody = cameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/{device_id}/cameras/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedCameraList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCamerasList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedCameraList {
        val localVariableConfig = devicesCamerasListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedCameraList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCameraList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCamerasList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesCamerasListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/cameras/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @param patchedCameraRequest  (optional)
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCamerasPartialUpdate(deviceId: kotlin.Int, id: kotlin.Int, patchedCameraRequest: PatchedCameraRequest?) : Camera {
        val localVariableConfig = devicesCamerasPartialUpdateRequestConfig(deviceId = deviceId, id = id, patchedCameraRequest = patchedCameraRequest)

        val localVarResponse = request<PatchedCameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCamerasPartialUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @param patchedCameraRequest  (optional)
    * @return RequestConfig
    */
    fun devicesCamerasPartialUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, patchedCameraRequest: PatchedCameraRequest?) : RequestConfig<PatchedCameraRequest> {
        val localVariableBody = patchedCameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/devices/{device_id}/cameras/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCamerasRetrieve(deviceId: kotlin.Int, id: kotlin.Int) : Camera {
        val localVariableConfig = devicesCamerasRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCamerasRetrieve
    *
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @return RequestConfig
    */
    fun devicesCamerasRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/cameras/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @param cameraRequest  
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCamerasUpdate(deviceId: kotlin.Int, id: kotlin.Int, cameraRequest: CameraRequest) : Camera {
        val localVariableConfig = devicesCamerasUpdateRequestConfig(deviceId = deviceId, id = id, cameraRequest = cameraRequest)

        val localVarResponse = request<CameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCamerasUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this camera. 
    * @param cameraRequest  
    * @return RequestConfig
    */
    fun devicesCamerasUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, cameraRequest: CameraRequest) : RequestConfig<CameraRequest> {
        val localVariableBody = cameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/devices/{device_id}/cameras/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param cloudiotDeviceRequest  
    * @return CloudiotDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCloudIotDevicesCreate(deviceId: kotlin.Int, cloudiotDeviceRequest: CloudiotDeviceRequest) : CloudiotDevice {
        val localVariableConfig = devicesCloudIotDevicesCreateRequestConfig(deviceId = deviceId, cloudiotDeviceRequest = cloudiotDeviceRequest)

        val localVarResponse = request<CloudiotDeviceRequest, CloudiotDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudiotDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCloudIotDevicesCreate
    *
    * @param deviceId  
    * @param cloudiotDeviceRequest  
    * @return RequestConfig
    */
    fun devicesCloudIotDevicesCreateRequestConfig(deviceId: kotlin.Int, cloudiotDeviceRequest: CloudiotDeviceRequest) : RequestConfig<CloudiotDeviceRequest> {
        val localVariableBody = cloudiotDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/{device_id}/cloud-iot-devices/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedCloudiotDeviceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCloudIotDevicesList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedCloudiotDeviceList {
        val localVariableConfig = devicesCloudIotDevicesListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedCloudiotDeviceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCloudiotDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCloudIotDevicesList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesCloudIotDevicesListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/cloud-iot-devices/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id  
    * @param patchedCloudiotDeviceRequest  (optional)
    * @return CloudiotDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCloudIotDevicesPartialUpdate(deviceId: kotlin.Int, id: kotlin.String, patchedCloudiotDeviceRequest: PatchedCloudiotDeviceRequest?) : CloudiotDevice {
        val localVariableConfig = devicesCloudIotDevicesPartialUpdateRequestConfig(deviceId = deviceId, id = id, patchedCloudiotDeviceRequest = patchedCloudiotDeviceRequest)

        val localVarResponse = request<PatchedCloudiotDeviceRequest, CloudiotDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudiotDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCloudIotDevicesPartialUpdate
    *
    * @param deviceId  
    * @param id  
    * @param patchedCloudiotDeviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesCloudIotDevicesPartialUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.String, patchedCloudiotDeviceRequest: PatchedCloudiotDeviceRequest?) : RequestConfig<PatchedCloudiotDeviceRequest> {
        val localVariableBody = patchedCloudiotDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/devices/{device_id}/cloud-iot-devices/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id  
    * @return CloudiotDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCloudIotDevicesRetrieve(deviceId: kotlin.Int, id: kotlin.String) : CloudiotDevice {
        val localVariableConfig = devicesCloudIotDevicesRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, CloudiotDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudiotDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCloudIotDevicesRetrieve
    *
    * @param deviceId  
    * @param id  
    * @return RequestConfig
    */
    fun devicesCloudIotDevicesRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/cloud-iot-devices/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id  
    * @param cloudiotDeviceRequest  
    * @return CloudiotDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCloudIotDevicesUpdate(deviceId: kotlin.Int, id: kotlin.String, cloudiotDeviceRequest: CloudiotDeviceRequest) : CloudiotDevice {
        val localVariableConfig = devicesCloudIotDevicesUpdateRequestConfig(deviceId = deviceId, id = id, cloudiotDeviceRequest = cloudiotDeviceRequest)

        val localVarResponse = request<CloudiotDeviceRequest, CloudiotDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudiotDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCloudIotDevicesUpdate
    *
    * @param deviceId  
    * @param id  
    * @param cloudiotDeviceRequest  
    * @return RequestConfig
    */
    fun devicesCloudIotDevicesUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.String, cloudiotDeviceRequest: CloudiotDeviceRequest) : RequestConfig<CloudiotDeviceRequest> {
        val localVariableBody = cloudiotDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/devices/{device_id}/cloud-iot-devices/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedDeviceConfigList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesConfigList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedDeviceConfigList {
        val localVariableConfig = devicesConfigListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedDeviceConfigList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDeviceConfigList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesConfigList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesConfigListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/config/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this device config. 
    * @return DeviceConfig
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesConfigRetrieve(deviceId: kotlin.Int, id: kotlin.Int) : DeviceConfig {
        val localVariableConfig = devicesConfigRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, DeviceConfig>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesConfigRetrieve
    *
    * @param deviceId  
    * @param id A unique integer value identifying this device config. 
    * @return RequestConfig
    */
    fun devicesConfigRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/config/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param deviceRequest  (optional)
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesCreate(deviceRequest: DeviceRequest?) : Device {
        val localVariableConfig = devicesCreateRequestConfig(deviceRequest = deviceRequest)

        val localVarResponse = request<DeviceRequest, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesCreate
    *
    * @param deviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesCreateRequestConfig(deviceRequest: DeviceRequest?) : RequestConfig<DeviceRequest> {
        val localVariableBody = deviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param deviceInfoRequest  
    * @return DeviceInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesInfoCreate(deviceId: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : DeviceInfo {
        val localVariableConfig = devicesInfoCreateRequestConfig(deviceId = deviceId, deviceInfoRequest = deviceInfoRequest)

        val localVarResponse = request<DeviceInfoRequest, DeviceInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesInfoCreate
    *
    * @param deviceId  
    * @param deviceInfoRequest  
    * @return RequestConfig
    */
    fun devicesInfoCreateRequestConfig(deviceId: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : RequestConfig<DeviceInfoRequest> {
        val localVariableBody = deviceInfoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/{device_id}/info/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedDeviceInfoList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesInfoList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedDeviceInfoList {
        val localVariableConfig = devicesInfoListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedDeviceInfoList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDeviceInfoList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesInfoList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesInfoListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/info/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @param patchedDeviceInfoRequest  (optional)
    * @return DeviceInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesInfoPartialUpdate(deviceId: kotlin.Int, id: kotlin.Int, patchedDeviceInfoRequest: PatchedDeviceInfoRequest?) : DeviceInfo {
        val localVariableConfig = devicesInfoPartialUpdateRequestConfig(deviceId = deviceId, id = id, patchedDeviceInfoRequest = patchedDeviceInfoRequest)

        val localVarResponse = request<PatchedDeviceInfoRequest, DeviceInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesInfoPartialUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @param patchedDeviceInfoRequest  (optional)
    * @return RequestConfig
    */
    fun devicesInfoPartialUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, patchedDeviceInfoRequest: PatchedDeviceInfoRequest?) : RequestConfig<PatchedDeviceInfoRequest> {
        val localVariableBody = patchedDeviceInfoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/devices/{device_id}/info/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @return DeviceInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesInfoRetrieve(deviceId: kotlin.Int, id: kotlin.Int) : DeviceInfo {
        val localVariableConfig = devicesInfoRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, DeviceInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesInfoRetrieve
    *
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @return RequestConfig
    */
    fun devicesInfoRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/info/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @param deviceInfoRequest  
    * @return DeviceInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesInfoUpdate(deviceId: kotlin.Int, id: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : DeviceInfo {
        val localVariableConfig = devicesInfoUpdateRequestConfig(deviceId = deviceId, id = id, deviceInfoRequest = deviceInfoRequest)

        val localVarResponse = request<DeviceInfoRequest, DeviceInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesInfoUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this device info. 
    * @param deviceInfoRequest  
    * @return RequestConfig
    */
    fun devicesInfoUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, deviceInfoRequest: DeviceInfoRequest) : RequestConfig<DeviceInfoRequest> {
        val localVariableBody = deviceInfoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/devices/{device_id}/info/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this device. 
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesLicenseRetrieve(id: kotlin.Int) : Device {
        val localVariableConfig = devicesLicenseRetrieveRequestConfig(id = id)

        val localVarResponse = request<Unit, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesLicenseRetrieve
    *
    * @param id A unique integer value identifying this device. 
    * @return RequestConfig
    */
    fun devicesLicenseRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{id}/license/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedDeviceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesList(page: kotlin.Int?) : PaginatedDeviceList {
        val localVariableConfig = devicesListRequestConfig(page = page)

        val localVarResponse = request<Unit, PaginatedDeviceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesList
    *
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesListRequestConfig(page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this device. 
    * @param patchedDeviceRequest  (optional)
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPartialUpdate(id: kotlin.Int, patchedDeviceRequest: PatchedDeviceRequest?) : Device {
        val localVariableConfig = devicesPartialUpdateRequestConfig(id = id, patchedDeviceRequest = patchedDeviceRequest)

        val localVarResponse = request<PatchedDeviceRequest, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPartialUpdate
    *
    * @param id A unique integer value identifying this device. 
    * @param patchedDeviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesPartialUpdateRequestConfig(id: kotlin.Int, patchedDeviceRequest: PatchedDeviceRequest?) : RequestConfig<PatchedDeviceRequest> {
        val localVariableBody = patchedDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/devices/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param deviceRequest  (optional)
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPrinterControllersCreate(deviceId: kotlin.Int, deviceRequest: DeviceRequest?) : PrinterController {
        val localVariableConfig = devicesPrinterControllersCreateRequestConfig(deviceId = deviceId, deviceRequest = deviceRequest)

        val localVarResponse = request<DeviceRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPrinterControllersCreate
    *
    * @param deviceId  
    * @param deviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesPrinterControllersCreateRequestConfig(deviceId: kotlin.Int, deviceRequest: DeviceRequest?) : RequestConfig<DeviceRequest> {
        val localVariableBody = deviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/devices/{device_id}/printer-controllers/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedPrinterControllerList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPrinterControllersList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedPrinterControllerList {
        val localVariableConfig = devicesPrinterControllersListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedPrinterControllerList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPrinterControllerList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPrinterControllersList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesPrinterControllersListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/printer-controllers/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param patchedPrinterControllerRequest  (optional)
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPrinterControllersPartialUpdate(deviceId: kotlin.Int, id: kotlin.Int, patchedPrinterControllerRequest: PatchedPrinterControllerRequest?) : PrinterController {
        val localVariableConfig = devicesPrinterControllersPartialUpdateRequestConfig(deviceId = deviceId, id = id, patchedPrinterControllerRequest = patchedPrinterControllerRequest)

        val localVarResponse = request<PatchedPrinterControllerRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPrinterControllersPartialUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param patchedPrinterControllerRequest  (optional)
    * @return RequestConfig
    */
    fun devicesPrinterControllersPartialUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, patchedPrinterControllerRequest: PatchedPrinterControllerRequest?) : RequestConfig<PatchedPrinterControllerRequest> {
        val localVariableBody = patchedPrinterControllerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/devices/{device_id}/printer-controllers/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPrinterControllersRetrieve(deviceId: kotlin.Int, id: kotlin.Int) : PrinterController {
        val localVariableConfig = devicesPrinterControllersRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPrinterControllersRetrieve
    *
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @return RequestConfig
    */
    fun devicesPrinterControllersRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/printer-controllers/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param deviceRequest  (optional)
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesPrinterControllersUpdate(deviceId: kotlin.Int, id: kotlin.Int, deviceRequest: DeviceRequest?) : PrinterController {
        val localVariableConfig = devicesPrinterControllersUpdateRequestConfig(deviceId = deviceId, id = id, deviceRequest = deviceRequest)

        val localVarResponse = request<DeviceRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesPrinterControllersUpdate
    *
    * @param deviceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param deviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesPrinterControllersUpdateRequestConfig(deviceId: kotlin.Int, id: kotlin.Int, deviceRequest: DeviceRequest?) : RequestConfig<DeviceRequest> {
        val localVariableBody = deviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/devices/{device_id}/printer-controllers/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this device. 
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesRetrieve(id: kotlin.Int) : Device {
        val localVariableConfig = devicesRetrieveRequestConfig(id = id)

        val localVarResponse = request<Unit, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesRetrieve
    *
    * @param id A unique integer value identifying this device. 
    * @return RequestConfig
    */
    fun devicesRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param hostname  
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesRetrieveHostname(hostname: kotlin.String) : Device {
        val localVariableConfig = devicesRetrieveHostnameRequestConfig(hostname = hostname)

        val localVarResponse = request<Unit, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesRetrieveHostname
    *
    * @param hostname  
    * @return RequestConfig
    */
    fun devicesRetrieveHostnameRequestConfig(hostname: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{hostname}".replace("{"+"hostname"+"}", "$hostname"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedDeviceStateList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesStateList(deviceId: kotlin.Int, page: kotlin.Int?) : PaginatedDeviceStateList {
        val localVariableConfig = devicesStateListRequestConfig(deviceId = deviceId, page = page)

        val localVarResponse = request<Unit, PaginatedDeviceStateList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedDeviceStateList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesStateList
    *
    * @param deviceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun devicesStateListRequestConfig(deviceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/state/".replace("{"+"device_id"+"}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param deviceId  
    * @param id A unique integer value identifying this device state. 
    * @return DeviceState
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesStateRetrieve(deviceId: kotlin.Int, id: kotlin.Int) : DeviceState {
        val localVariableConfig = devicesStateRetrieveRequestConfig(deviceId = deviceId, id = id)

        val localVarResponse = request<Unit, DeviceState>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceState
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesStateRetrieve
    *
    * @param deviceId  
    * @param id A unique integer value identifying this device state. 
    * @return RequestConfig
    */
    fun devicesStateRetrieveRequestConfig(deviceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/devices/{device_id}/state/{id}/".replace("{"+"device_id"+"}", "$deviceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this device. 
    * @param deviceRequest  (optional)
    * @return Device
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun devicesUpdate(id: kotlin.Int, deviceRequest: DeviceRequest?) : Device {
        val localVariableConfig = devicesUpdateRequestConfig(id = id, deviceRequest = deviceRequest)

        val localVarResponse = request<DeviceRequest, Device>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Device
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation devicesUpdate
    *
    * @param id A unique integer value identifying this device. 
    * @param deviceRequest  (optional)
    * @return RequestConfig
    */
    fun devicesUpdateRequestConfig(id: kotlin.Int, deviceRequest: DeviceRequest?) : RequestConfig<DeviceRequest> {
        val localVariableBody = deviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/devices/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
