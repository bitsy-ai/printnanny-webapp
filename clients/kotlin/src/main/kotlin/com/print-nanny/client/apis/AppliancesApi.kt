/**
 * 
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.print-nanny.client.apis

import com.print-nanny.client.models.AnsibleFacts
import com.print-nanny.client.models.AnsibleFactsRequest
import com.print-nanny.client.models.Appliance
import com.print-nanny.client.models.ApplianceKeyPair
import com.print-nanny.client.models.AppliancePublicKey
import com.print-nanny.client.models.ApplianceRequest
import com.print-nanny.client.models.Camera
import com.print-nanny.client.models.CameraRequest
import com.print-nanny.client.models.CloudIoTDevice
import com.print-nanny.client.models.CloudIoTDeviceRequest
import com.print-nanny.client.models.ErrorDetail
import com.print-nanny.client.models.PaginatedAnsibleFactsList
import com.print-nanny.client.models.PaginatedApplianceList
import com.print-nanny.client.models.PaginatedAppliancePublicKeyList
import com.print-nanny.client.models.PaginatedCameraList
import com.print-nanny.client.models.PaginatedCloudIoTDeviceList
import com.print-nanny.client.models.PaginatedPrinterControllerList
import com.print-nanny.client.models.PatchedAnsibleFactsRequest
import com.print-nanny.client.models.PatchedApplianceRequest
import com.print-nanny.client.models.PatchedCameraRequest
import com.print-nanny.client.models.PatchedCloudIoTDeviceRequest
import com.print-nanny.client.models.PatchedPrinterControllerRequest
import com.print-nanny.client.models.PrinterController

import com.print-nanny.client.infrastructure.ApiClient
import com.print-nanny.client.infrastructure.ClientException
import com.print-nanny.client.infrastructure.ClientError
import com.print-nanny.client.infrastructure.ServerException
import com.print-nanny.client.infrastructure.ServerError
import com.print-nanny.client.infrastructure.MultiValueMap
import com.print-nanny.client.infrastructure.RequestConfig
import com.print-nanny.client.infrastructure.RequestMethod
import com.print-nanny.client.infrastructure.ResponseType
import com.print-nanny.client.infrastructure.Success
import com.print-nanny.client.infrastructure.toMultiValue

class AppliancesApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("com.print-nanny.client.baseUrl", "http://localhost")
        }
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param ansibleFactsRequest  
    * @return AnsibleFacts
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesAnsibleFactsCreate(applianceId: kotlin.Int, ansibleFactsRequest: AnsibleFactsRequest) : AnsibleFacts {
        val localVariableConfig = appliancesAnsibleFactsCreateRequestConfig(applianceId = applianceId, ansibleFactsRequest = ansibleFactsRequest)

        val localVarResponse = request<AnsibleFactsRequest, AnsibleFacts>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnsibleFacts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesAnsibleFactsCreate
    *
    * @param applianceId  
    * @param ansibleFactsRequest  
    * @return RequestConfig
    */
    fun appliancesAnsibleFactsCreateRequestConfig(applianceId: kotlin.Int, ansibleFactsRequest: AnsibleFactsRequest) : RequestConfig<AnsibleFactsRequest> {
        val localVariableBody = ansibleFactsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/{appliance_id}/ansible-facts/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedAnsibleFactsList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesAnsibleFactsList(applianceId: kotlin.Int, page: kotlin.Int?) : PaginatedAnsibleFactsList {
        val localVariableConfig = appliancesAnsibleFactsListRequestConfig(applianceId = applianceId, page = page)

        val localVarResponse = request<Unit, PaginatedAnsibleFactsList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAnsibleFactsList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesAnsibleFactsList
    *
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesAnsibleFactsListRequestConfig(applianceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/ansible-facts/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @param patchedAnsibleFactsRequest  (optional)
    * @return AnsibleFacts
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesAnsibleFactsPartialUpdate(applianceId: kotlin.Int, id: kotlin.Int, patchedAnsibleFactsRequest: PatchedAnsibleFactsRequest?) : AnsibleFacts {
        val localVariableConfig = appliancesAnsibleFactsPartialUpdateRequestConfig(applianceId = applianceId, id = id, patchedAnsibleFactsRequest = patchedAnsibleFactsRequest)

        val localVarResponse = request<PatchedAnsibleFactsRequest, AnsibleFacts>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnsibleFacts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesAnsibleFactsPartialUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @param patchedAnsibleFactsRequest  (optional)
    * @return RequestConfig
    */
    fun appliancesAnsibleFactsPartialUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, patchedAnsibleFactsRequest: PatchedAnsibleFactsRequest?) : RequestConfig<PatchedAnsibleFactsRequest> {
        val localVariableBody = patchedAnsibleFactsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/appliances/{appliance_id}/ansible-facts/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @return AnsibleFacts
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesAnsibleFactsRetrieve(applianceId: kotlin.Int, id: kotlin.Int) : AnsibleFacts {
        val localVariableConfig = appliancesAnsibleFactsRetrieveRequestConfig(applianceId = applianceId, id = id)

        val localVarResponse = request<Unit, AnsibleFacts>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnsibleFacts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesAnsibleFactsRetrieve
    *
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @return RequestConfig
    */
    fun appliancesAnsibleFactsRetrieveRequestConfig(applianceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/ansible-facts/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @param ansibleFactsRequest  
    * @return AnsibleFacts
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesAnsibleFactsUpdate(applianceId: kotlin.Int, id: kotlin.Int, ansibleFactsRequest: AnsibleFactsRequest) : AnsibleFacts {
        val localVariableConfig = appliancesAnsibleFactsUpdateRequestConfig(applianceId = applianceId, id = id, ansibleFactsRequest = ansibleFactsRequest)

        val localVarResponse = request<AnsibleFactsRequest, AnsibleFacts>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AnsibleFacts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesAnsibleFactsUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this ansible facts. 
    * @param ansibleFactsRequest  
    * @return RequestConfig
    */
    fun appliancesAnsibleFactsUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, ansibleFactsRequest: AnsibleFactsRequest) : RequestConfig<AnsibleFactsRequest> {
        val localVariableBody = ansibleFactsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/appliances/{appliance_id}/ansible-facts/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param cameraRequest  
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCamerasCreate(applianceId: kotlin.Int, cameraRequest: CameraRequest) : Camera {
        val localVariableConfig = appliancesCamerasCreateRequestConfig(applianceId = applianceId, cameraRequest = cameraRequest)

        val localVarResponse = request<CameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCamerasCreate
    *
    * @param applianceId  
    * @param cameraRequest  
    * @return RequestConfig
    */
    fun appliancesCamerasCreateRequestConfig(applianceId: kotlin.Int, cameraRequest: CameraRequest) : RequestConfig<CameraRequest> {
        val localVariableBody = cameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/{appliance_id}/cameras/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedCameraList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCamerasList(applianceId: kotlin.Int, page: kotlin.Int?) : PaginatedCameraList {
        val localVariableConfig = appliancesCamerasListRequestConfig(applianceId = applianceId, page = page)

        val localVarResponse = request<Unit, PaginatedCameraList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCameraList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCamerasList
    *
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesCamerasListRequestConfig(applianceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/cameras/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @param patchedCameraRequest  (optional)
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCamerasPartialUpdate(applianceId: kotlin.Int, id: kotlin.Int, patchedCameraRequest: PatchedCameraRequest?) : Camera {
        val localVariableConfig = appliancesCamerasPartialUpdateRequestConfig(applianceId = applianceId, id = id, patchedCameraRequest = patchedCameraRequest)

        val localVarResponse = request<PatchedCameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCamerasPartialUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @param patchedCameraRequest  (optional)
    * @return RequestConfig
    */
    fun appliancesCamerasPartialUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, patchedCameraRequest: PatchedCameraRequest?) : RequestConfig<PatchedCameraRequest> {
        val localVariableBody = patchedCameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/appliances/{appliance_id}/cameras/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCamerasRetrieve(applianceId: kotlin.Int, id: kotlin.Int) : Camera {
        val localVariableConfig = appliancesCamerasRetrieveRequestConfig(applianceId = applianceId, id = id)

        val localVarResponse = request<Unit, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCamerasRetrieve
    *
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @return RequestConfig
    */
    fun appliancesCamerasRetrieveRequestConfig(applianceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/cameras/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @param cameraRequest  
    * @return Camera
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCamerasUpdate(applianceId: kotlin.Int, id: kotlin.Int, cameraRequest: CameraRequest) : Camera {
        val localVariableConfig = appliancesCamerasUpdateRequestConfig(applianceId = applianceId, id = id, cameraRequest = cameraRequest)

        val localVarResponse = request<CameraRequest, Camera>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Camera
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCamerasUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this camera. 
    * @param cameraRequest  
    * @return RequestConfig
    */
    fun appliancesCamerasUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, cameraRequest: CameraRequest) : RequestConfig<CameraRequest> {
        val localVariableBody = cameraRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/appliances/{appliance_id}/cameras/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param cloudIoTDeviceRequest  
    * @return CloudIoTDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCloudIotDevicesCreate(applianceId: kotlin.Int, cloudIoTDeviceRequest: CloudIoTDeviceRequest) : CloudIoTDevice {
        val localVariableConfig = appliancesCloudIotDevicesCreateRequestConfig(applianceId = applianceId, cloudIoTDeviceRequest = cloudIoTDeviceRequest)

        val localVarResponse = request<CloudIoTDeviceRequest, CloudIoTDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudIoTDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCloudIotDevicesCreate
    *
    * @param applianceId  
    * @param cloudIoTDeviceRequest  
    * @return RequestConfig
    */
    fun appliancesCloudIotDevicesCreateRequestConfig(applianceId: kotlin.Int, cloudIoTDeviceRequest: CloudIoTDeviceRequest) : RequestConfig<CloudIoTDeviceRequest> {
        val localVariableBody = cloudIoTDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/{appliance_id}/cloud-iot-devices/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedCloudIoTDeviceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCloudIotDevicesList(applianceId: kotlin.Int, page: kotlin.Int?) : PaginatedCloudIoTDeviceList {
        val localVariableConfig = appliancesCloudIotDevicesListRequestConfig(applianceId = applianceId, page = page)

        val localVarResponse = request<Unit, PaginatedCloudIoTDeviceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedCloudIoTDeviceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCloudIotDevicesList
    *
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesCloudIotDevicesListRequestConfig(applianceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/cloud-iot-devices/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id  
    * @param patchedCloudIoTDeviceRequest  (optional)
    * @return CloudIoTDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCloudIotDevicesPartialUpdate(applianceId: kotlin.Int, id: kotlin.String, patchedCloudIoTDeviceRequest: PatchedCloudIoTDeviceRequest?) : CloudIoTDevice {
        val localVariableConfig = appliancesCloudIotDevicesPartialUpdateRequestConfig(applianceId = applianceId, id = id, patchedCloudIoTDeviceRequest = patchedCloudIoTDeviceRequest)

        val localVarResponse = request<PatchedCloudIoTDeviceRequest, CloudIoTDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudIoTDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCloudIotDevicesPartialUpdate
    *
    * @param applianceId  
    * @param id  
    * @param patchedCloudIoTDeviceRequest  (optional)
    * @return RequestConfig
    */
    fun appliancesCloudIotDevicesPartialUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.String, patchedCloudIoTDeviceRequest: PatchedCloudIoTDeviceRequest?) : RequestConfig<PatchedCloudIoTDeviceRequest> {
        val localVariableBody = patchedCloudIoTDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/appliances/{appliance_id}/cloud-iot-devices/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id  
    * @return CloudIoTDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCloudIotDevicesRetrieve(applianceId: kotlin.Int, id: kotlin.String) : CloudIoTDevice {
        val localVariableConfig = appliancesCloudIotDevicesRetrieveRequestConfig(applianceId = applianceId, id = id)

        val localVarResponse = request<Unit, CloudIoTDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudIoTDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCloudIotDevicesRetrieve
    *
    * @param applianceId  
    * @param id  
    * @return RequestConfig
    */
    fun appliancesCloudIotDevicesRetrieveRequestConfig(applianceId: kotlin.Int, id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/cloud-iot-devices/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id  
    * @param cloudIoTDeviceRequest  
    * @return CloudIoTDevice
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCloudIotDevicesUpdate(applianceId: kotlin.Int, id: kotlin.String, cloudIoTDeviceRequest: CloudIoTDeviceRequest) : CloudIoTDevice {
        val localVariableConfig = appliancesCloudIotDevicesUpdateRequestConfig(applianceId = applianceId, id = id, cloudIoTDeviceRequest = cloudIoTDeviceRequest)

        val localVarResponse = request<CloudIoTDeviceRequest, CloudIoTDevice>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CloudIoTDevice
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCloudIotDevicesUpdate
    *
    * @param applianceId  
    * @param id  
    * @param cloudIoTDeviceRequest  
    * @return RequestConfig
    */
    fun appliancesCloudIotDevicesUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.String, cloudIoTDeviceRequest: CloudIoTDeviceRequest) : RequestConfig<CloudIoTDeviceRequest> {
        val localVariableBody = cloudIoTDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/appliances/{appliance_id}/cloud-iot-devices/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param applianceRequest  
    * @return Appliance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesCreate(applianceRequest: ApplianceRequest) : Appliance {
        val localVariableConfig = appliancesCreateRequestConfig(applianceRequest = applianceRequest)

        val localVarResponse = request<ApplianceRequest, Appliance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Appliance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesCreate
    *
    * @param applianceRequest  
    * @return RequestConfig
    */
    fun appliancesCreateRequestConfig(applianceRequest: ApplianceRequest) : RequestConfig<ApplianceRequest> {
        val localVariableBody = applianceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Public key for Print Nanny Appliance Only one public key may be active at a time DELETE &lt;:endpoint&gt; will soft-delete a key
    * @param applianceId  
    * @return ApplianceKeyPair
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesKeypairsCreate(applianceId: kotlin.Int) : ApplianceKeyPair {
        val localVariableConfig = appliancesKeypairsCreateRequestConfig(applianceId = applianceId)

        val localVarResponse = request<Unit, ApplianceKeyPair>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ApplianceKeyPair
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesKeypairsCreate
    *
    * @param applianceId  
    * @return RequestConfig
    */
    fun appliancesKeypairsCreateRequestConfig(applianceId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/{appliance_id}/keypairs/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Public key for Print Nanny Appliance Only one public key may be active at a time DELETE &lt;:endpoint&gt; will soft-delete a key
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedAppliancePublicKeyList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesKeypairsList(applianceId: kotlin.Int, page: kotlin.Int?) : PaginatedAppliancePublicKeyList {
        val localVariableConfig = appliancesKeypairsListRequestConfig(applianceId = applianceId, page = page)

        val localVarResponse = request<Unit, PaginatedAppliancePublicKeyList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedAppliancePublicKeyList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesKeypairsList
    *
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesKeypairsListRequestConfig(applianceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/keypairs/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * Public key for Print Nanny Appliance Only one public key may be active at a time DELETE &lt;:endpoint&gt; will soft-delete a key
    * @param applianceId  
    * @param id A unique integer value identifying this appliance public key. 
    * @return AppliancePublicKey
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesKeypairsRetrieve(applianceId: kotlin.Int, id: kotlin.Int) : AppliancePublicKey {
        val localVariableConfig = appliancesKeypairsRetrieveRequestConfig(applianceId = applianceId, id = id)

        val localVarResponse = request<Unit, AppliancePublicKey>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AppliancePublicKey
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesKeypairsRetrieve
    *
    * @param applianceId  
    * @param id A unique integer value identifying this appliance public key. 
    * @return RequestConfig
    */
    fun appliancesKeypairsRetrieveRequestConfig(applianceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/keypairs/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedApplianceList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesList(page: kotlin.Int?) : PaginatedApplianceList {
        val localVariableConfig = appliancesListRequestConfig(page = page)

        val localVarResponse = request<Unit, PaginatedApplianceList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedApplianceList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesList
    *
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesListRequestConfig(page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this appliance. 
    * @param patchedApplianceRequest  (optional)
    * @return Appliance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPartialUpdate(id: kotlin.Int, patchedApplianceRequest: PatchedApplianceRequest?) : Appliance {
        val localVariableConfig = appliancesPartialUpdateRequestConfig(id = id, patchedApplianceRequest = patchedApplianceRequest)

        val localVarResponse = request<PatchedApplianceRequest, Appliance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Appliance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPartialUpdate
    *
    * @param id A unique integer value identifying this appliance. 
    * @param patchedApplianceRequest  (optional)
    * @return RequestConfig
    */
    fun appliancesPartialUpdateRequestConfig(id: kotlin.Int, patchedApplianceRequest: PatchedApplianceRequest?) : RequestConfig<PatchedApplianceRequest> {
        val localVariableBody = patchedApplianceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/appliances/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param applianceRequest  
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPrinterControllersCreate(applianceId: kotlin.Int, applianceRequest: ApplianceRequest) : PrinterController {
        val localVariableConfig = appliancesPrinterControllersCreateRequestConfig(applianceId = applianceId, applianceRequest = applianceRequest)

        val localVarResponse = request<ApplianceRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPrinterControllersCreate
    *
    * @param applianceId  
    * @param applianceRequest  
    * @return RequestConfig
    */
    fun appliancesPrinterControllersCreateRequestConfig(applianceId: kotlin.Int, applianceRequest: ApplianceRequest) : RequestConfig<ApplianceRequest> {
        val localVariableBody = applianceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/appliances/{appliance_id}/printer-controllers/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return PaginatedPrinterControllerList
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPrinterControllersList(applianceId: kotlin.Int, page: kotlin.Int?) : PaginatedPrinterControllerList {
        val localVariableConfig = appliancesPrinterControllersListRequestConfig(applianceId = applianceId, page = page)

        val localVarResponse = request<Unit, PaginatedPrinterControllerList>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PaginatedPrinterControllerList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPrinterControllersList
    *
    * @param applianceId  
    * @param page A page number within the paginated result set. (optional)
    * @return RequestConfig
    */
    fun appliancesPrinterControllersListRequestConfig(applianceId: kotlin.Int, page: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/printer-controllers/".replace("{"+"appliance_id"+"}", "$applianceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param patchedPrinterControllerRequest  (optional)
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPrinterControllersPartialUpdate(applianceId: kotlin.Int, id: kotlin.Int, patchedPrinterControllerRequest: PatchedPrinterControllerRequest?) : PrinterController {
        val localVariableConfig = appliancesPrinterControllersPartialUpdateRequestConfig(applianceId = applianceId, id = id, patchedPrinterControllerRequest = patchedPrinterControllerRequest)

        val localVarResponse = request<PatchedPrinterControllerRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPrinterControllersPartialUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param patchedPrinterControllerRequest  (optional)
    * @return RequestConfig
    */
    fun appliancesPrinterControllersPartialUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, patchedPrinterControllerRequest: PatchedPrinterControllerRequest?) : RequestConfig<PatchedPrinterControllerRequest> {
        val localVariableBody = patchedPrinterControllerRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/appliances/{appliance_id}/printer-controllers/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPrinterControllersRetrieve(applianceId: kotlin.Int, id: kotlin.Int) : PrinterController {
        val localVariableConfig = appliancesPrinterControllersRetrieveRequestConfig(applianceId = applianceId, id = id)

        val localVarResponse = request<Unit, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPrinterControllersRetrieve
    *
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @return RequestConfig
    */
    fun appliancesPrinterControllersRetrieveRequestConfig(applianceId: kotlin.Int, id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{appliance_id}/printer-controllers/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param applianceRequest  
    * @return PrinterController
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesPrinterControllersUpdate(applianceId: kotlin.Int, id: kotlin.Int, applianceRequest: ApplianceRequest) : PrinterController {
        val localVariableConfig = appliancesPrinterControllersUpdateRequestConfig(applianceId = applianceId, id = id, applianceRequest = applianceRequest)

        val localVarResponse = request<ApplianceRequest, PrinterController>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PrinterController
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesPrinterControllersUpdate
    *
    * @param applianceId  
    * @param id A unique integer value identifying this printer controller. 
    * @param applianceRequest  
    * @return RequestConfig
    */
    fun appliancesPrinterControllersUpdateRequestConfig(applianceId: kotlin.Int, id: kotlin.Int, applianceRequest: ApplianceRequest) : RequestConfig<ApplianceRequest> {
        val localVariableBody = applianceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/appliances/{appliance_id}/printer-controllers/{id}/".replace("{"+"appliance_id"+"}", "$applianceId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this appliance. 
    * @return Appliance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesRetrieve(id: kotlin.Int) : Appliance {
        val localVariableConfig = appliancesRetrieveRequestConfig(id = id)

        val localVarResponse = request<Unit, Appliance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Appliance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesRetrieve
    *
    * @param id A unique integer value identifying this appliance. 
    * @return RequestConfig
    */
    fun appliancesRetrieveRequestConfig(id: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * 
    * @param hostname  
    * @return Appliance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesRetrieveHostname(hostname: kotlin.String) : Appliance {
        val localVariableConfig = appliancesRetrieveHostnameRequestConfig(hostname = hostname)

        val localVarResponse = request<Unit, Appliance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Appliance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesRetrieveHostname
    *
    * @param hostname  
    * @return RequestConfig
    */
    fun appliancesRetrieveHostnameRequestConfig(hostname: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/appliances/{hostname}".replace("{"+"hostname"+"}", "$hostname"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * 
    * All-in-one Print Nanny installation via print-nanny-main-&lt;platform&gt;-&lt;cpu&gt;.img
    * @param id A unique integer value identifying this appliance. 
    * @param applianceRequest  
    * @return Appliance
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appliancesUpdate(id: kotlin.Int, applianceRequest: ApplianceRequest) : Appliance {
        val localVariableConfig = appliancesUpdateRequestConfig(id = id, applianceRequest = applianceRequest)

        val localVarResponse = request<ApplianceRequest, Appliance>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Appliance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation appliancesUpdate
    *
    * @param id A unique integer value identifying this appliance. 
    * @param applianceRequest  
    * @return RequestConfig
    */
    fun appliancesUpdateRequestConfig(id: kotlin.Int, applianceRequest: ApplianceRequest) : RequestConfig<ApplianceRequest> {
        val localVariableBody = applianceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/appliances/{id}/".replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
