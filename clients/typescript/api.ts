/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    time: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    gcode_file: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    print_progress: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    time_elapsed: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    time_remaining: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    manage_device_url: string | null;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {AlertMethodEnum}
     * @memberof Alert
     */
    alert_method: AlertMethodEnum;
    /**
     * 
     * @type {AlertEventTypeEnum}
     * @memberof Alert
     */
    event_type?: AlertEventTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    sent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    updated_dt: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    message: string;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface AlertBulkResponse
 */
export interface AlertBulkResponse {
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    received: number;
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    updated: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AlertEventTypeEnum {
    Test = 'Test',
    VideoDone = 'VideoDone',
    PrintHealth = 'PrintHealth',
    PrintProgress = 'PrintProgress',
    PrintDone = 'PrintDone',
    PrintFailed = 'PrintFailed',
    PrintPaused = 'PrintPaused',
    PrintResumed = 'PrintResumed',
    PrintStarted = 'PrintStarted',
    PrintCancelled = 'PrintCancelled',
    Shutdown = 'Shutdown',
    Startup = 'Startup',
    Connected = 'Connected',
    Disconnected = 'Disconnected'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AlertMethodEnum {
    Ui = 'UI',
    Email = 'EMAIL',
    Discord = 'DISCORD',
    Partner3Dgeeks = 'PARTNER_3DGEEKS'
}

/**
 * 
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
    /**
     * 
     * @type {number}
     * @memberof AlertRequest
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {AlertMethodEnum}
     * @memberof AlertRequest
     */
    alert_method: AlertMethodEnum;
    /**
     * 
     * @type {AlertEventTypeEnum}
     * @memberof AlertRequest
     */
    event_type?: AlertEventTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRequest
     */
    sent?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ArtifactTypesEnum {
    Tflite = 'TFLITE',
    Tf1 = 'TF1',
    Tf2SavedModel = 'TF2_SAVED_MODEL',
    Tf2Hdf5 = 'TF2_HDF5'
}

/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    password: string;
}
/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuthRequest
 */
export interface CallbackTokenAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    mobile?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    token: string;
}
/**
 * Takes a user and a token, verifies the token belongs to the user and validates the alias that the token was sent from.
 * @export
 * @interface CallbackTokenVerification
 */
export interface CallbackTokenVerification {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    mobile?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    token: string;
}
/**
 * Takes a user and a token, verifies the token belongs to the user and validates the alias that the token was sent from.
 * @export
 * @interface CallbackTokenVerificationRequest
 */
export interface CallbackTokenVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    mobile?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    token: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CommandEnum {
    MonitoringStop = 'monitoring_stop',
    MonitoringStart = 'monitoring_start',
    PrintStart = 'print_start',
    PrintStop = 'print_stop',
    PrintPause = 'print_pause',
    PrintResume = 'print_resume',
    MoveNozzle = 'move_nozzle',
    ConnectTestMqttPong = 'connect_test_mqtt_pong'
}

/**
 * Generic auth response serializer
 * @export
 * @interface DetailResponse
 */
export interface DetailResponse {
    /**
     * 
     * @type {string}
     * @memberof DetailResponse
     */
    detail: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deleted: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    updated_dt: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    user: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    public_key: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    fingerprint: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Device
     */
    cloudiot_device: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    cloudiot_device_name: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    cloudiot_device_path: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    cloudiot_device_num_id: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    os_version: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    os: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    kernel_version: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    serial?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    ram: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Device
     */
    cpu_flags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    url: string;
}
/**
 * 
 * @export
 * @interface DeviceCalibration
 */
export interface DeviceCalibration {
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    updated_dt: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    fps?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DeviceCalibration
     */
    xy?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    width?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    url: string;
}
/**
 * 
 * @export
 * @interface DeviceCalibrationRequest
 */
export interface DeviceCalibrationRequest {
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    fps?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DeviceCalibrationRequest
     */
    xy?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    width?: number;
}
/**
 * 
 * @export
 * @interface DeviceIdentity
 */
export interface DeviceIdentity {
    /**
     * 
     * @type {number}
     * @memberof DeviceIdentity
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    deleted: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    updated_dt: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceIdentity
     */
    user: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    public_key: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    fingerprint: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DeviceIdentity
     */
    cloudiot_device: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    cloudiot_device_name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    cloudiot_device_path: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceIdentity
     */
    cloudiot_device_num_id: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    os_version: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    os: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    kernel_version: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    serial?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceIdentity
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceIdentity
     */
    ram: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceIdentity
     */
    cpu_flags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    private_key: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    private_key_checksum: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    public_key_checksum: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentity
     */
    cloudiot_device_configs: string;
    /**
     * 
     * @type {DeviceIdentityCaCerts}
     * @memberof DeviceIdentity
     */
    ca_certs: DeviceIdentityCaCerts;
}
/**
 * 
 * @export
 * @interface DeviceIdentityCaCerts
 */
export interface DeviceIdentityCaCerts {
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentityCaCerts
     */
    primary?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentityCaCerts
     */
    primary_checksum?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentityCaCerts
     */
    backup?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentityCaCerts
     */
    backup_checksum?: string;
}
/**
 * 
 * @export
 * @interface DeviceRequest
 */
export interface DeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    os_version: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    os: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    kernel_version: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceRequest
     */
    serial?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceRequest
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceRequest
     */
    ram: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeviceRequest
     */
    cpu_flags: Array<string>;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuthRequest
 */
export interface EmailAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailAuthRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EventSourceEnum {
    Octoprint = 'octoprint',
    PluginOctoprintNanny = 'plugin_octoprint_nanny',
    RemoteCommand = 'remote_command'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EventType0c4Enum {
    Operational = 'Operational',
    Paused = 'Paused',
    Cancelling = 'Cancelling',
    Printing = 'Printing',
    Pausing = 'Pausing',
    SdReady = 'sdReady',
    Error = 'Error',
    ReadyPrinterReady = 'ReadyPrinter Ready',
    ClosedOrError = 'closedOrError',
    Offline = 'Offline',
    OpeningSerialConnection = 'Opening serial connection',
    Connection = 'Connection',
    Resuming = 'Resuming',
    Finishing = 'Finishing',
    PrinterStateChanged = 'PrinterStateChanged',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    PrinterReset = 'PrinterReset',
    FirmwareData = 'FirmwareData'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EventTypeD9eEnum {
    PrintCancelled = 'PrintCancelled',
    PrintCancelling = 'PrintCancelling',
    PrintDone = 'PrintDone',
    PrintFailed = 'PrintFailed',
    PrintPaused = 'PrintPaused',
    PrintResumed = 'PrintResumed',
    PrintStarted = 'PrintStarted'
}

/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    created_dt: string;
    /**
     * 
     * @type {boolean}
     * @memberof Experiment
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    hypothesis: string;
    /**
     * 
     * @type {Nested}
     * @memberof Experiment
     */
    control: Nested;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof Experiment
     */
    treatments: Array<Nested>;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    notion_url?: string | null;
}
/**
 * 
 * @export
 * @interface ExperimentDeviceConfig
 */
export interface ExperimentDeviceConfig {
    /**
     * 
     * @type {number}
     * @memberof ExperimentDeviceConfig
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ExperimentDeviceConfig
     */
    created_dt: string;
    /**
     * 
     * @type {Nested}
     * @memberof ExperimentDeviceConfig
     */
    experiment: Nested;
    /**
     * 
     * @type {Nested}
     * @memberof ExperimentDeviceConfig
     */
    artifact: Nested;
}
/**
 * 
 * @export
 * @interface GcodeFile
 */
export interface GcodeFile {
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    user: number;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    file_hash: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    octoprint_device: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    url: string;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface MobileAuthRequest
 */
export interface MobileAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof MobileAuthRequest
     */
    mobile: string;
}
/**
 * 
 * @export
 * @interface ModelArtifact
 */
export interface ModelArtifact {
    /**
     * 
     * @type {number}
     * @memberof ModelArtifact
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    labels: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    artifacts: string;
    /**
     * 
     * @type {Array<ArtifactTypesEnum>}
     * @memberof ModelArtifact
     */
    artifact_types: Array<ArtifactTypesEnum>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelArtifact
     */
    metadata: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    url: string;
}
/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    created_dt: string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    hypothesis: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    notion_url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    control: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Nested
     */
    treatments?: Array<number>;
}
/**
 * 
 * @export
 * @interface OctoPrintDevice
 */
export interface OctoPrintDevice {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    deleted: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    user: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    public_key: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    fingerprint: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintDevice
     */
    cloudiot_device: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_name: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_path: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_num_id: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDevice
     */
    cpu_flags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    virtualenv?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_configs: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    manage_url: string;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrintDevice
     */
    monitoring_active: boolean;
    /**
     * 
     * @type {PrintSession}
     * @memberof OctoPrintDevice
     */
    active_session?: PrintSession;
}
/**
 * 
 * @export
 * @interface OctoPrintDeviceKey
 */
export interface OctoPrintDeviceKey {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    deleted: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    user: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    public_key: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    fingerprint: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_name: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_path: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_num_id: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDeviceKey
     */
    cpu_flags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    virtualenv?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    private_key: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    private_key_checksum: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    public_key_checksum: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_configs: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OctoPrintDeviceKey
     */
    ca_certs: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    manage_url: string;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrintDeviceKey
     */
    monitoring_active: boolean;
    /**
     * 
     * @type {PrintSession}
     * @memberof OctoPrintDeviceKey
     */
    active_session?: PrintSession;
}
/**
 * 
 * @export
 * @interface OctoPrintDeviceRequest
 */
export interface OctoPrintDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDeviceRequest
     */
    cpu_flags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceRequest
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceRequest
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    virtualenv?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {PrintSessionRequest}
     * @memberof OctoPrintDeviceRequest
     */
    active_session?: PrintSessionRequest;
}
/**
 * 
 * @export
 * @interface OctoPrintEvent
 */
export interface OctoPrintEvent {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    id: number;
    /**
     * 
     * @type {OctoPrintEventEventTypeEnum}
     * @memberof OctoPrintEvent
     */
    event_type: OctoPrintEventEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof OctoPrintEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OctoPrintEventEventTypeEnum {
    ClientAuthed = 'ClientAuthed',
    ClientClosed = 'ClientClosed',
    ClientDeauthed = 'ClientDeauthed',
    ClientOpened = 'ClientOpened',
    SettingsUpdated = 'SettingsUpdated',
    UserLoggedIn = 'UserLoggedIn',
    UserLoggedOut = 'UserLoggedOut',
    FileAdded = 'FileAdded',
    FileRemoved = 'FileRemoved',
    FolderAdded = 'FolderAdded',
    FolderRemoved = 'FolderRemoved',
    TransferDone = 'TransferDone',
    TransferFailed = 'TransferFailed',
    TransferStarted = 'TransferStarted',
    UpdatedFiles = 'UpdatedFiles',
    Upload = 'Upload',
    CaptureDone = 'CaptureDone',
    CaptureFailed = 'CaptureFailed',
    CaptureStart = 'CaptureStart',
    MovieDone = 'MovieDone',
    MovieFailed = 'MovieFailed',
    MovieRendering = 'MovieRendering',
    PostRollEnd = 'PostRollEnd',
    PostRollStart = 'PostRollStart',
    SlicingCancelled = 'SlicingCancelled',
    SlicingDone = 'SlicingDone',
    SlicingFailed = 'SlicingFailed',
    SlicingProfileAdded = 'SlicingProfileAdded',
    SlicingProfileDeleted = 'SlicingProfileDeleted',
    SlicingProfileModified = 'SlicingProfileModified',
    SlicingStarted = 'SlicingStarted',
    PrinterProfileAdded = 'PrinterProfileAdded',
    PrinterProfileDeleted = 'PrinterProfileDeleted',
    PrinterProfileModified = 'PrinterProfileModified',
    PrintProgress = 'PrintProgress',
    PluginPiSupportThrottleState = 'plugin_pi_support_throttle_state',
    Shutdown = 'Shutdown',
    Startup = 'Startup'
}

/**
 * 
 * @export
 * @interface OctoPrintEventRequest
 */
export interface OctoPrintEventRequest {
    /**
     * 
     * @type {OctoPrintEventEventTypeEnum}
     * @memberof OctoPrintEventRequest
     */
    event_type: OctoPrintEventEventTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @interface OctoprintEnvironment
 */
export interface OctoprintEnvironment {
    /**
     * 
     * @type {OctoprintPlatform}
     * @memberof OctoprintEnvironment
     */
    os: OctoprintPlatform;
    /**
     * 
     * @type {OctoprintPython}
     * @memberof OctoprintEnvironment
     */
    python: OctoprintPython;
    /**
     * 
     * @type {OctoprintHardware}
     * @memberof OctoprintEnvironment
     */
    hardware: OctoprintHardware;
    /**
     * 
     * @type {OctoprintPiSupport}
     * @memberof OctoprintEnvironment
     */
    pi_support: OctoprintPiSupport;
}
/**
 * 
 * @export
 * @interface OctoprintFile
 */
export interface OctoprintFile {
    /**
     * 
     * @type {string}
     * @memberof OctoprintFile
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoprintFile
     */
    path: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoprintFile
     */
    display?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoprintFile
     */
    origin: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintFile
     */
    size: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintFile
     */
    date: number | null;
}
/**
 * 
 * @export
 * @interface OctoprintHardware
 */
export interface OctoprintHardware {
    /**
     * 
     * @type {number}
     * @memberof OctoprintHardware
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoprintHardware
     */
    freq: number;
    /**
     * 
     * @type {number}
     * @memberof OctoprintHardware
     */
    ram: number;
}
/**
 * 
 * @export
 * @interface OctoprintJob
 */
export interface OctoprintJob {
    /**
     * 
     * @type {OctoprintFile}
     * @memberof OctoprintJob
     */
    file: OctoprintFile | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintJob
     */
    estimatedPrintTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintJob
     */
    averagePrintTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintJob
     */
    lastPrintTime?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoprintJob
     */
    filament: { [key: string]: any; } | null;
}
/**
 * 
 * @export
 * @interface OctoprintPiSupport
 */
export interface OctoprintPiSupport {
    /**
     * 
     * @type {string}
     * @memberof OctoprintPiSupport
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPiSupport
     */
    throttle_state: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPiSupport
     */
    octopi_version?: string;
}
/**
 * 
 * @export
 * @interface OctoprintPlatform
 */
export interface OctoprintPlatform {
    /**
     * 
     * @type {string}
     * @memberof OctoprintPlatform
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPlatform
     */
    platform: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPlatform
     */
    bits: string;
}
/**
 * 
 * @export
 * @interface OctoprintPrinterData
 */
export interface OctoprintPrinterData {
    /**
     * 
     * @type {OctoprintJob}
     * @memberof OctoprintPrinterData
     */
    job: OctoprintJob;
    /**
     * 
     * @type {OctoprintPrinterState}
     * @memberof OctoprintPrinterData
     */
    state: OctoprintPrinterState;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPrinterData
     */
    user?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintPrinterData
     */
    currentZ?: number;
    /**
     * 
     * @type {OctoprintProgress}
     * @memberof OctoprintPrinterData
     */
    progress: OctoprintProgress;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoprintPrinterData
     */
    resends: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoprintPrinterData
     */
    offsets: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OctoprintPrinterFlags
 */
export interface OctoprintPrinterFlags {
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    operational: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    printing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    cancelling: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    pausing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    resuming: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    finishing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    closedOrError: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    error: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    paused: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    ready: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OctoprintPrinterFlags
     */
    sdReady: boolean;
}
/**
 * 
 * @export
 * @interface OctoprintPrinterState
 */
export interface OctoprintPrinterState {
    /**
     * 
     * @type {string}
     * @memberof OctoprintPrinterState
     */
    text: string;
    /**
     * 
     * @type {OctoprintPrinterFlags}
     * @memberof OctoprintPrinterState
     */
    flags: OctoprintPrinterFlags;
}
/**
 * 
 * @export
 * @interface OctoprintProgress
 */
export interface OctoprintProgress {
    /**
     * 
     * @type {number}
     * @memberof OctoprintProgress
     */
    completion: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintProgress
     */
    filepos: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintProgress
     */
    printTime: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoprintProgress
     */
    printTimeLeft: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoprintProgress
     */
    printTimeOrigin?: string | null;
}
/**
 * 
 * @export
 * @interface OctoprintPython
 */
export interface OctoprintPython {
    /**
     * 
     * @type {string}
     * @memberof OctoprintPython
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPython
     */
    pip: string;
    /**
     * 
     * @type {string}
     * @memberof OctoprintPython
     */
    virtualenv: string;
}
/**
 * 
 * @export
 * @interface PaginatedAlertList
 */
export interface PaginatedAlertList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlertList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof PaginatedAlertList
     */
    results?: Array<Alert>;
}
/**
 * 
 * @export
 * @interface PaginatedDeviceCalibrationList
 */
export interface PaginatedDeviceCalibrationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeviceCalibrationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceCalibrationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceCalibrationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceCalibration>}
     * @memberof PaginatedDeviceCalibrationList
     */
    results?: Array<DeviceCalibration>;
}
/**
 * 
 * @export
 * @interface PaginatedDeviceList
 */
export interface PaginatedDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeviceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Device>}
     * @memberof PaginatedDeviceList
     */
    results?: Array<Device>;
}
/**
 * 
 * @export
 * @interface PaginatedExperimentDeviceConfigList
 */
export interface PaginatedExperimentDeviceConfigList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExperimentDeviceConfig>}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    results?: Array<ExperimentDeviceConfig>;
}
/**
 * 
 * @export
 * @interface PaginatedExperimentList
 */
export interface PaginatedExperimentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExperimentList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof PaginatedExperimentList
     */
    results?: Array<Experiment>;
}
/**
 * 
 * @export
 * @interface PaginatedGcodeFileList
 */
export interface PaginatedGcodeFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGcodeFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GcodeFile>}
     * @memberof PaginatedGcodeFileList
     */
    results?: Array<GcodeFile>;
}
/**
 * 
 * @export
 * @interface PaginatedModelArtifactList
 */
export interface PaginatedModelArtifactList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedModelArtifactList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModelArtifactList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModelArtifactList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ModelArtifact>}
     * @memberof PaginatedModelArtifactList
     */
    results?: Array<ModelArtifact>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintDeviceList
 */
export interface PaginatedOctoPrintDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintDeviceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintDeviceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintDeviceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<OctoPrintDevice>}
     * @memberof PaginatedOctoPrintDeviceList
     */
    results?: Array<OctoPrintDevice>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintEventList
 */
export interface PaginatedOctoPrintEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<OctoPrintEvent>}
     * @memberof PaginatedOctoPrintEventList
     */
    results?: Array<OctoPrintEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintJobEventList
 */
export interface PaginatedPrintJobEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintJobEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintJobEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintJobEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintJobEvent>}
     * @memberof PaginatedPrintJobEventList
     */
    results?: Array<PrintJobEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintNannyPluginEventList
 */
export interface PaginatedPrintNannyPluginEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintNannyPluginEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintNannyPluginEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintNannyPluginEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintNannyPluginEvent>}
     * @memberof PaginatedPrintNannyPluginEventList
     */
    results?: Array<PrintNannyPluginEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintSessionList
 */
export interface PaginatedPrintSessionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintSessionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintSession>}
     * @memberof PaginatedPrintSessionList
     */
    results?: Array<PrintSession>;
}
/**
 * 
 * @export
 * @interface PaginatedPrinterProfileList
 */
export interface PaginatedPrinterProfileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrinterProfileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrinterProfileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrinterProfileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrinterProfile>}
     * @memberof PaginatedPrinterProfileList
     */
    results?: Array<PrinterProfile>;
}
/**
 * 
 * @export
 * @interface PaginatedRemoteCommandEventList
 */
export interface PaginatedRemoteCommandEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRemoteCommandEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteCommandEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteCommandEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RemoteCommandEvent>}
     * @memberof PaginatedRemoteCommandEventList
     */
    results?: Array<RemoteCommandEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedRemoteControlCommandList
 */
export interface PaginatedRemoteControlCommandList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRemoteControlCommandList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlCommandList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlCommandList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RemoteControlCommand>}
     * @memberof PaginatedRemoteControlCommandList
     */
    results?: Array<RemoteControlCommand>;
}
/**
 * 
 * @export
 * @interface PaginatedTelemetryEventPolymorphicList
 */
export interface PaginatedTelemetryEventPolymorphicList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTelemetryEventPolymorphicList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTelemetryEventPolymorphicList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTelemetryEventPolymorphicList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TelemetryEventPolymorphic>}
     * @memberof PaginatedTelemetryEventPolymorphicList
     */
    results?: Array<TelemetryEventPolymorphic>;
}
/**
 * 
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof PaginatedUserList
     */
    results?: Array<User>;
}
/**
 * Do not use underscores in this serializer - linitation of Firebase Cloud Messaging
 * @export
 * @interface Partner3DGeeksAlert
 */
export interface Partner3DGeeksAlert {
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    event: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    printer: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    print: string;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    currentTime: number;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    timeLeft: number;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    percent: number;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    image: string | null;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    action: string;
}
/**
 * Please do not include any personally-identifying info or sensitive info in partner serializers
 * @export
 * @interface Partner3DGeeksMetadata
 */
export interface Partner3DGeeksMetadata {
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    platform: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    verified: string;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface PatchedAlertBulkRequestRequest
 */
export interface PatchedAlertBulkRequestRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedAlertBulkRequestRequest
     */
    ids?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedAlertRequest
 */
export interface PatchedAlertRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedAlertRequest
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {AlertMethodEnum}
     * @memberof PatchedAlertRequest
     */
    alert_method?: AlertMethodEnum;
    /**
     * 
     * @type {AlertEventTypeEnum}
     * @memberof PatchedAlertRequest
     */
    event_type?: AlertEventTypeEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAlertRequest
     */
    sent?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedDeviceCalibrationRequest
 */
export interface PatchedDeviceCalibrationRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    fps?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedDeviceCalibrationRequest
     */
    xy?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    width?: number;
}
/**
 * 
 * @export
 * @interface PatchedDeviceRequest
 */
export interface PatchedDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    os_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    os?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    kernel_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    serial?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceRequest
     */
    cores?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceRequest
     */
    ram?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedDeviceRequest
     */
    cpu_flags?: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintDeviceRequest
 */
export interface PatchedOctoPrintDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    platform?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    cpu_flags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    hardware?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    revision?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    serial?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    cores?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    ram?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    python_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    pip_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    virtualenv?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    octoprint_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    plugin_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    print_nanny_client_version?: string;
    /**
     * 
     * @type {PrintSessionRequest}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    active_session?: PrintSessionRequest;
}
/**
 * 
 * @export
 * @interface PatchedPrintSessionRequest
 */
export interface PatchedPrintSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPrintSessionRequest
     */
    created_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrintSessionRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrintSessionRequest
     */
    session?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    filepos?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    print_progress?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    time_elapsed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    time_remaining?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrintSessionRequest
     */
    gcode_filename?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedPrintSessionRequest
     */
    octoprint_job?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PrintJobStatusEnum}
     * @memberof PatchedPrintSessionRequest
     */
    print_job_status?: PrintJobStatusEnum | null;
}
/**
 * 
 * @export
 * @interface PatchedPrinterProfileRequest
 */
export interface PatchedPrinterProfileRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    octoprint_key?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_width?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedRemoteControlCommandRequest
 */
export interface PatchedRemoteControlCommandRequest {
    /**
     * 
     * @type {CommandEnum}
     * @memberof PatchedRemoteControlCommandRequest
     */
    command?: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedRemoteControlCommandRequest
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRemoteControlCommandRequest
     */
    device?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandRequest
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandRequest
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedRemoteControlCommandRequest
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedRemoteControlCommandRequest
     */
    metadata?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface PrintJobEvent
 */
export interface PrintJobEvent {
    /**
     * 
     * @type {number}
     * @memberof PrintJobEvent
     */
    id: number;
    /**
     * 
     * @type {EventTypeD9eEnum}
     * @memberof PrintJobEvent
     */
    event_type: EventTypeD9eEnum;
    /**
     * 
     * @type {string}
     * @memberof PrintJobEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PrintJobEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobEvent
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobEvent
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PrintJobEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJobEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintJobEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof PrintJobEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJobEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJobEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof PrintJobEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintJobStatusEnum {
    PrintCancelled = 'PrintCancelled',
    PrintCancelling = 'PrintCancelling',
    PrintDone = 'PrintDone',
    PrintFailed = 'PrintFailed',
    PrintPaused = 'PrintPaused',
    PrintResumed = 'PrintResumed',
    PrintStarted = 'PrintStarted'
}

/**
 * 
 * @export
 * @interface PrintNannyPluginEvent
 */
export interface PrintNannyPluginEvent {
    /**
     * 
     * @type {number}
     * @memberof PrintNannyPluginEvent
     */
    id: number;
    /**
     * 
     * @type {PrintNannyPluginEventEventTypeEnum}
     * @memberof PrintNannyPluginEvent
     */
    event_type: PrintNannyPluginEventEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyPluginEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PrintNannyPluginEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintNannyPluginEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintNannyPluginEvent
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintNannyPluginEvent
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintNannyPluginEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PrintNannyPluginEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyPluginEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyPluginEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof PrintNannyPluginEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof PrintNannyPluginEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof PrintNannyPluginEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof PrintNannyPluginEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintNannyPluginEventEventTypeEnum {
    MonitoringStart = 'plugin_octoprint_nanny_monitoring_start',
    MonitoringStop = 'plugin_octoprint_nanny_monitoring_stop',
    MonitoringReset = 'plugin_octoprint_nanny_monitoring_reset',
    DeviceRegisterStart = 'plugin_octoprint_nanny_device_register_start',
    DeviceRegisterDone = 'plugin_octoprint_nanny_device_register_done',
    DeviceRegisterFailed = 'plugin_octoprint_nanny_device_register_failed',
    DeviceReset = 'plugin_octoprint_nanny_device_reset',
    PrinterProfileSyncStart = 'plugin_octoprint_nanny_printer_profile_sync_start',
    PrinterProfileSyncDone = 'plugin_octoprint_nanny_printer_profile_sync_done',
    PrinterProfileSyncFailed = 'plugin_octoprint_nanny_printer_profile_sync_failed',
    ConnectTestRestApi = 'plugin_octoprint_nanny_connect_test_rest_api',
    ConnectTestRestApiFailed = 'plugin_octoprint_nanny_connect_test_rest_api_failed',
    ConnectTestRestApiSuccess = 'plugin_octoprint_nanny_connect_test_rest_api_success',
    ConnectTestMqttPing = 'plugin_octoprint_nanny_connect_test_mqtt_ping',
    ConnectTestMqttPingFailed = 'plugin_octoprint_nanny_connect_test_mqtt_ping_failed',
    ConnectTestMqttPingSuccess = 'plugin_octoprint_nanny_connect_test_mqtt_ping_success',
    ConnectTestMqttPong = 'plugin_octoprint_nanny_connect_test_mqtt_pong',
    ConnectTestMqttPongFailed = 'plugin_octoprint_nanny_connect_test_mqtt_pong_failed',
    ConnectTestMqttPongSuccess = 'plugin_octoprint_nanny_connect_test_mqtt_pong_success'
}

/**
 * 
 * @export
 * @interface PrintSession
 */
export interface PrintSession {
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    created_dt: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    updated_dt: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSession
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    session: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    filepos?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    print_progress?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    time_elapsed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    time_remaining?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    gcode_filename?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSession
     */
    octoprint_job?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PrintJobStatusEnum}
     * @memberof PrintSession
     */
    print_job_status?: PrintJobStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    datesegment: string;
}
/**
 * 
 * @export
 * @interface PrintSessionRequest
 */
export interface PrintSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof PrintSessionRequest
     */
    created_dt: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionRequest
     */
    session: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    filepos?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    print_progress?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    time_elapsed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    time_remaining?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionRequest
     */
    gcode_filename?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSessionRequest
     */
    octoprint_job?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PrintJobStatusEnum}
     * @memberof PrintSessionRequest
     */
    print_job_status?: PrintJobStatusEnum | null;
}
/**
 * 
 * @export
 * @interface PrinterEvent
 */
export interface PrinterEvent {
    /**
     * 
     * @type {number}
     * @memberof PrinterEvent
     */
    id: number;
    /**
     * 
     * @type {EventType0c4Enum}
     * @memberof PrinterEvent
     */
    event_type: EventType0c4Enum;
    /**
     * 
     * @type {string}
     * @memberof PrinterEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PrinterEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterEvent
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterEvent
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PrinterEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {PrinterStateEnum}
     * @memberof PrinterEvent
     */
    printer_state: PrinterStateEnum;
    /**
     * 
     * @type {number}
     * @memberof PrinterEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @interface PrinterProfile
 */
export interface PrinterProfile {
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    octoprint_key: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterProfile
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_width?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    url: string;
}
/**
 * 
 * @export
 * @interface PrinterProfileRequest
 */
export interface PrinterProfileRequest {
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    octoprint_key: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterProfileRequest
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_width?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrinterStateEnum {
    Operational = 'Operational',
    Paused = 'Paused',
    Cancelling = 'Cancelling',
    Printing = 'Printing',
    Pausing = 'Pausing',
    SdReady = 'sdReady',
    Error = 'Error',
    ReadyPrinterReady = 'ReadyPrinter Ready',
    ClosedOrError = 'closedOrError',
    Offline = 'Offline',
    OpeningSerialConnection = 'Opening serial connection',
    Connection = 'Connection',
    Resuming = 'Resuming',
    Finishing = 'Finishing',
    PrinterStateChanged = 'PrinterStateChanged',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    PrinterReset = 'PrinterReset',
    FirmwareData = 'FirmwareData'
}

/**
 * 
 * @export
 * @interface RemoteCommandEvent
 */
export interface RemoteCommandEvent {
    /**
     * 
     * @type {number}
     * @memberof RemoteCommandEvent
     */
    id: number;
    /**
     * 
     * @type {RemoteCommandEventEventTypeEnum}
     * @memberof RemoteCommandEvent
     */
    event_type: RemoteCommandEventEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RemoteCommandEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof RemoteCommandEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteCommandEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteCommandEvent
     */
    octoprint_environment?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteCommandEvent
     */
    octoprint_printer_data?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteCommandEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RemoteCommandEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteCommandEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteCommandEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteCommandEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteCommandEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteCommandEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteCommandEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RemoteCommandEventEventTypeEnum {
    Received = 'remote_command_received',
    Failed = 'remote_command_failed',
    Success = 'remote_command_success'
}

/**
 * 
 * @export
 * @interface RemoteControlCommand
 */
export interface RemoteControlCommand {
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    created_dt: string;
    /**
     * 
     * @type {CommandEnum}
     * @memberof RemoteControlCommand
     */
    command: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    device: number;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommand
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommand
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommand
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommand
     */
    metadata?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    octoprint_event_type: string;
}
/**
 * 
 * @export
 * @interface RemoteControlCommandRequest
 */
export interface RemoteControlCommandRequest {
    /**
     * 
     * @type {CommandEnum}
     * @memberof RemoteControlCommandRequest
     */
    command: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandRequest
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandRequest
     */
    device: number;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandRequest
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandRequest
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommandRequest
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommandRequest
     */
    metadata?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface TelemetryEvent
 */
export interface TelemetryEvent {
    /**
     * 
     * @type {number}
     * @memberof TelemetryEvent
     */
    id: number;
    /**
     * 
     * @type {TelemetryEventEventTypeEnum}
     * @memberof TelemetryEvent
     */
    event_type: TelemetryEventEventTypeEnum;
    /**
     * 
     * @type {OctoprintEnvironment}
     * @memberof TelemetryEvent
     */
    octoprint_environment: OctoprintEnvironment;
    /**
     * 
     * @type {OctoprintPrinterData}
     * @memberof TelemetryEvent
     */
    octoprint_printer_data: OctoprintPrinterData;
    /**
     * 
     * @type {string}
     * @memberof TelemetryEvent
     */
    ts: string;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof TelemetryEvent
     */
    event_source: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TelemetryEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof TelemetryEvent
     */
    temperature?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof TelemetryEvent
     */
    print_nanny_plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof TelemetryEvent
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof TelemetryEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {number}
     * @memberof TelemetryEvent
     */
    polymorphic_ctype: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryEvent
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryEvent
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryEvent
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TelemetryEventEventTypeEnum {
    PluginOctoprintNannyMonitoringStart = 'plugin_octoprint_nanny_monitoring_start',
    PluginOctoprintNannyMonitoringStop = 'plugin_octoprint_nanny_monitoring_stop',
    PluginOctoprintNannyMonitoringReset = 'plugin_octoprint_nanny_monitoring_reset',
    PluginOctoprintNannyDeviceRegisterStart = 'plugin_octoprint_nanny_device_register_start',
    PluginOctoprintNannyDeviceRegisterDone = 'plugin_octoprint_nanny_device_register_done',
    PluginOctoprintNannyDeviceRegisterFailed = 'plugin_octoprint_nanny_device_register_failed',
    PluginOctoprintNannyDeviceReset = 'plugin_octoprint_nanny_device_reset',
    PluginOctoprintNannyPrinterProfileSyncStart = 'plugin_octoprint_nanny_printer_profile_sync_start',
    PluginOctoprintNannyPrinterProfileSyncDone = 'plugin_octoprint_nanny_printer_profile_sync_done',
    PluginOctoprintNannyPrinterProfileSyncFailed = 'plugin_octoprint_nanny_printer_profile_sync_failed',
    PluginOctoprintNannyConnectTestRestApi = 'plugin_octoprint_nanny_connect_test_rest_api',
    PluginOctoprintNannyConnectTestRestApiFailed = 'plugin_octoprint_nanny_connect_test_rest_api_failed',
    PluginOctoprintNannyConnectTestRestApiSuccess = 'plugin_octoprint_nanny_connect_test_rest_api_success',
    PluginOctoprintNannyConnectTestMqttPing = 'plugin_octoprint_nanny_connect_test_mqtt_ping',
    PluginOctoprintNannyConnectTestMqttPingFailed = 'plugin_octoprint_nanny_connect_test_mqtt_ping_failed',
    PluginOctoprintNannyConnectTestMqttPingSuccess = 'plugin_octoprint_nanny_connect_test_mqtt_ping_success',
    PluginOctoprintNannyConnectTestMqttPong = 'plugin_octoprint_nanny_connect_test_mqtt_pong',
    PluginOctoprintNannyConnectTestMqttPongFailed = 'plugin_octoprint_nanny_connect_test_mqtt_pong_failed',
    PluginOctoprintNannyConnectTestMqttPongSuccess = 'plugin_octoprint_nanny_connect_test_mqtt_pong_success',
    ClientAuthed = 'ClientAuthed',
    ClientClosed = 'ClientClosed',
    ClientDeauthed = 'ClientDeauthed',
    ClientOpened = 'ClientOpened',
    SettingsUpdated = 'SettingsUpdated',
    UserLoggedIn = 'UserLoggedIn',
    UserLoggedOut = 'UserLoggedOut',
    FileAdded = 'FileAdded',
    FileRemoved = 'FileRemoved',
    FolderAdded = 'FolderAdded',
    FolderRemoved = 'FolderRemoved',
    TransferDone = 'TransferDone',
    TransferFailed = 'TransferFailed',
    TransferStarted = 'TransferStarted',
    UpdatedFiles = 'UpdatedFiles',
    Upload = 'Upload',
    CaptureDone = 'CaptureDone',
    CaptureFailed = 'CaptureFailed',
    CaptureStart = 'CaptureStart',
    MovieDone = 'MovieDone',
    MovieFailed = 'MovieFailed',
    MovieRendering = 'MovieRendering',
    PostRollEnd = 'PostRollEnd',
    PostRollStart = 'PostRollStart',
    SlicingCancelled = 'SlicingCancelled',
    SlicingDone = 'SlicingDone',
    SlicingFailed = 'SlicingFailed',
    SlicingProfileAdded = 'SlicingProfileAdded',
    SlicingProfileDeleted = 'SlicingProfileDeleted',
    SlicingProfileModified = 'SlicingProfileModified',
    SlicingStarted = 'SlicingStarted',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    PrinterReset = 'PrinterReset',
    FirmwareData = 'FirmwareData',
    PrinterProfileAdded = 'PrinterProfileAdded',
    PrinterProfileDeleted = 'PrinterProfileDeleted',
    PrinterProfileModified = 'PrinterProfileModified',
    PrintProgress = 'PrintProgress',
    PluginPiSupportThrottleState = 'plugin_pi_support_throttle_state',
    Shutdown = 'Shutdown',
    Startup = 'Startup',
    RemoteCommandReceived = 'remote_command_received',
    RemoteCommandFailed = 'remote_command_failed',
    RemoteCommandSuccess = 'remote_command_success',
    PrintCancelled = 'PrintCancelled',
    PrintCancelling = 'PrintCancelling',
    PrintDone = 'PrintDone',
    PrintFailed = 'PrintFailed',
    PrintPaused = 'PrintPaused',
    PrintResumed = 'PrintResumed',
    PrintStarted = 'PrintStarted',
    PrinterStateChanged = 'PrinterStateChanged'
}

/**
 * @type TelemetryEventPolymorphic
 * @export
 */
export type TelemetryEventPolymorphic = OctoPrintEvent | PrintJobEvent | PrintNannyPluginEvent | PrinterEvent | RemoteCommandEvent | TelemetryEvent;

/**
 * Our default response serializer.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    token: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    url: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    email: string;
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/recent/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen: async (patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/seen/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAlertBulkRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnread: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/unread/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsSeen(patchedAlertBulkRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsUnread(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsUnread(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecent(options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnread(options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsUnread(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - interface
 * @export
 * @interface AlertsApi
 */
export interface AlertsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsRecent(options?: any): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsUnread(options?: any): AxiosPromise<AlertBulkResponse>;

}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI implements AlertsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsRecent(options?: any) {
        return AlertsApiFp(this.configuration).alertsRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any) {
        return AlertsApiFp(this.configuration).alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsUnread(options?: any) {
        return AlertsApiFp(this.configuration).alertsUnread(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsPartialUpdate: async (id: number, patchedAlertRequest?: PatchedAlertRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAlertsPartialUpdate', 'id', id)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAlertsRetrieve', 'id', id)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} alertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsUpdate: async (id: number, alertRequest: AlertRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAlertsUpdate', 'id', id)
            // verify required parameter 'alertRequest' is not null or undefined
            assertParamExists('apiAlertsUpdate', 'alertRequest', alertRequest)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthTokenCreate: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiAuthTokenCreate', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiAuthTokenCreate', 'password', password)
            const localVarPath = `/api/auth-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve: async (lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAlertsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAlertList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAlertsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAlertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAlertsPartialUpdate(id, patchedAlertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAlertsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAlertsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} alertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAlertsUpdate(id: number, alertRequest: AlertRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAlertsUpdate(id, alertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAuthTokenCreate(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAuthTokenCreate(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSchemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSchemaRetrieve(lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsList(page?: number, options?: any): AxiosPromise<PaginatedAlertList> {
            return localVarFp.apiAlertsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: any): AxiosPromise<Alert> {
            return localVarFp.apiAlertsPartialUpdate(id, patchedAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsRetrieve(id: number, options?: any): AxiosPromise<Alert> {
            return localVarFp.apiAlertsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} alertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAlertsUpdate(id: number, alertRequest: AlertRequest, options?: any): AxiosPromise<Alert> {
            return localVarFp.apiAlertsUpdate(id, alertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAuthTokenCreate(username: string, password: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.apiAuthTokenCreate(username, password, options).then((request) => request(axios, basePath));
        },
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSchemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.apiSchemaRetrieve(lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - interface
 * @export
 * @interface ApiApi
 */
export interface ApiApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAlertsList(page?: number, options?: any): AxiosPromise<PaginatedAlertList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {PatchedAlertRequest} [patchedAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAlertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: any): AxiosPromise<Alert>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAlertsRetrieve(id: number, options?: any): AxiosPromise<Alert>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {AlertRequest} alertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAlertsUpdate(id: number, alertRequest: AlertRequest, options?: any): AxiosPromise<Alert>;

    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiAuthTokenCreate(username: string, password: string, options?: any): AxiosPromise<AuthToken>;

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApiInterface
     */
    apiSchemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI implements ApiApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAlertsList(page?: number, options?: any) {
        return ApiApiFp(this.configuration).apiAlertsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {PatchedAlertRequest} [patchedAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAlertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAlertsPartialUpdate(id, patchedAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAlertsRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAlertsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {AlertRequest} alertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAlertsUpdate(id: number, alertRequest: AlertRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAlertsUpdate(id, alertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAuthTokenCreate(username: string, password: string, options?: any) {
        return ApiApiFp(this.configuration).apiAuthTokenCreate(username, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSchemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any) {
        return ApiApiFp(this.configuration).apiSchemaRetrieve(lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailCreate: async (emailAuthRequest: EmailAuthRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailAuthRequest' is not null or undefined
            assertParamExists('authEmailCreate', 'emailAuthRequest', emailAuthRequest)
            const localVarPath = `/auth/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileCreate: async (mobileAuthRequest: MobileAuthRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mobileAuthRequest' is not null or undefined
            assertParamExists('authMobileCreate', 'mobileAuthRequest', mobileAuthRequest)
            const localVarPath = `/auth/mobile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mobileAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (callbackTokenAuthRequest: CallbackTokenAuthRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenAuthRequest' is not null or undefined
            assertParamExists('authTokenCreate', 'callbackTokenAuthRequest', callbackTokenAuthRequest)
            const localVarPath = `/auth/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyCreate: async (callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenVerificationRequest' is not null or undefined
            assertParamExists('authVerifyCreate', 'callbackTokenVerificationRequest', callbackTokenVerificationRequest)
            const localVarPath = `/auth/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobileCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify/mobile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailCreate(emailAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMobileCreate(mobileAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCreate(callbackTokenAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallbackTokenVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyCreate(callbackTokenVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyEmailCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyEmailCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyMobileCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyMobileCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authEmailCreate(emailAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authMobileCreate(mobileAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.authTokenCreate(callbackTokenAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: any): AxiosPromise<CallbackTokenVerification> {
            return localVarFp.authVerifyCreate(callbackTokenVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailCreate(options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authVerifyEmailCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobileCreate(options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authVerifyMobileCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): AxiosPromise<DetailResponse>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {MobileAuthRequest} mobileAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: any): AxiosPromise<DetailResponse>;

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<TokenResponse>;

    /**
     * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
     * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: any): AxiosPromise<CallbackTokenVerification>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyEmailCreate(options?: any): AxiosPromise<DetailResponse>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyMobileCreate(options?: any): AxiosPromise<DetailResponse>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any) {
        return AuthApiFp(this.configuration).authEmailCreate(emailAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {MobileAuthRequest} mobileAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: any) {
        return AuthApiFp(this.configuration).authMobileCreate(mobileAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any) {
        return AuthApiFp(this.configuration).authTokenCreate(callbackTokenAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
     * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: any) {
        return AuthApiFp(this.configuration).authVerifyCreate(callbackTokenVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyEmailCreate(options?: any) {
        return AuthApiFp(this.configuration).authVerifyEmailCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyMobileCreate(options?: any) {
        return AuthApiFp(this.configuration).authVerifyMobileCreate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesCreate: async (deviceRequest: DeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceRequest' is not null or undefined
            assertParamExists('apiDevicesCreate', 'deviceRequest', deviceRequest)
            const localVarPath = `/api/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDevicesRetrieve', 'id', id)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate: async (id: number, patchedDeviceRequest?: PatchedDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate: async (id: number, deviceRequest: DeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesUpdate', 'id', id)
            // verify required parameter 'deviceRequest' is not null or undefined
            assertParamExists('devicesUpdate', 'deviceRequest', deviceRequest)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateOrCreate: async (deviceRequest: DeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceRequest' is not null or undefined
            assertParamExists('devicesUpdateOrCreate', 'deviceRequest', deviceRequest)
            const localVarPath = `/api/devices/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDevicesCreate(deviceRequest: DeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDevicesCreate(deviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDevicesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDevicesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDevicesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDevicesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPartialUpdate(id, patchedDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdate(id: number, deviceRequest: DeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdate(id, deviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateOrCreate(deviceRequest: DeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceIdentity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdateOrCreate(deviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesCreate(deviceRequest: DeviceRequest, options?: any): AxiosPromise<Device> {
            return localVarFp.apiDevicesCreate(deviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesList(page?: number, options?: any): AxiosPromise<PaginatedDeviceList> {
            return localVarFp.apiDevicesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDevicesRetrieve(id: number, options?: any): AxiosPromise<Device> {
            return localVarFp.apiDevicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesPartialUpdate(id, patchedDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate(id: number, deviceRequest: DeviceRequest, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesUpdate(id, deviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateOrCreate(deviceRequest: DeviceRequest, options?: any): AxiosPromise<DeviceIdentity> {
            return localVarFp.devicesUpdateOrCreate(deviceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - interface
 * @export
 * @interface DevicesApi
 */
export interface DevicesApiInterface {
    /**
     * 
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    apiDevicesCreate(deviceRequest: DeviceRequest, options?: any): AxiosPromise<Device>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    apiDevicesList(page?: number, options?: any): AxiosPromise<PaginatedDeviceList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    apiDevicesRetrieve(id: number, options?: any): AxiosPromise<Device>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: any): AxiosPromise<Device>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesUpdate(id: number, deviceRequest: DeviceRequest, options?: any): AxiosPromise<Device>;

    /**
     * 
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesUpdateOrCreate(deviceRequest: DeviceRequest, options?: any): AxiosPromise<DeviceIdentity>;

}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI implements DevicesApiInterface {
    /**
     * 
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesCreate(deviceRequest: DeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesCreate(deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesList(page?: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public apiDevicesRetrieve(id: number, options?: any) {
        return DevicesApiFp(this.configuration).apiDevicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).devicesPartialUpdate(id, patchedDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device.
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesUpdate(id: number, deviceRequest: DeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).devicesUpdate(id, deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesUpdateOrCreate(deviceRequest: DeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).devicesUpdateOrCreate(deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MlOpsApi - axios parameter creator
 * @export
 */
export const MlOpsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/device-calibrations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsPartialUpdate: async (id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDeviceCalibrationsPartialUpdate', 'id', id)
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDeviceCalibrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDeviceCalibrationsRetrieve', 'id', id)
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsUpdate: async (id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiDeviceCalibrationsUpdate', 'id', id)
            // verify required parameter 'deviceCalibrationRequest' is not null or undefined
            assertParamExists('apiDeviceCalibrationsUpdate', 'deviceCalibrationRequest', deviceCalibrationRequest)
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceCalibrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentDeviceConfigsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/experiment-device-configs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentDeviceConfigsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExperimentDeviceConfigsRetrieve', 'id', id)
            const localVarPath = `/api/experiment-device-configs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/experiments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExperimentsRetrieve', 'id', id)
            const localVarPath = `/api/experiments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModelArtifactsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/model-artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModelArtifactsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiModelArtifactsRetrieve', 'id', id)
            const localVarPath = `/api/model-artifacts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationUpdateOrCreate: async (deviceCalibrationRequest: DeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceCalibrationRequest' is not null or undefined
            assertParamExists('deviceCalibrationUpdateOrCreate', 'deviceCalibrationRequest', deviceCalibrationRequest)
            const localVarPath = `/api/device-calibrations/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceCalibrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlOpsApi - functional programming interface
 * @export
 */
export const MlOpsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MlOpsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeviceCalibrationsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeviceCalibrationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeviceCalibrationsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeviceCalibrationsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeviceCalibrationsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDeviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDeviceCalibrationsUpdate(id, deviceCalibrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExperimentDeviceConfigsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExperimentDeviceConfigList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExperimentDeviceConfigsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExperimentDeviceConfigsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentDeviceConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExperimentDeviceConfigsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExperimentsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExperimentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExperimentsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExperimentsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExperimentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiModelArtifactsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedModelArtifactList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiModelArtifactsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiModelArtifactsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelArtifact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiModelArtifactsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MlOpsApi - factory interface
 * @export
 */
export const MlOpsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MlOpsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsList(page?: number, options?: any): AxiosPromise<PaginatedDeviceCalibrationList> {
            return localVarFp.apiDeviceCalibrationsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return localVarFp.apiDeviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsRetrieve(id: number, options?: any): AxiosPromise<DeviceCalibration> {
            return localVarFp.apiDeviceCalibrationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDeviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return localVarFp.apiDeviceCalibrationsUpdate(id, deviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentDeviceConfigsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentDeviceConfigList> {
            return localVarFp.apiExperimentDeviceConfigsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentDeviceConfigsRetrieve(id: number, options?: any): AxiosPromise<ExperimentDeviceConfig> {
            return localVarFp.apiExperimentDeviceConfigsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentList> {
            return localVarFp.apiExperimentsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExperimentsRetrieve(id: number, options?: any): AxiosPromise<Experiment> {
            return localVarFp.apiExperimentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModelArtifactsList(page?: number, options?: any): AxiosPromise<PaginatedModelArtifactList> {
            return localVarFp.apiModelArtifactsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiModelArtifactsRetrieve(id: number, options?: any): AxiosPromise<ModelArtifact> {
            return localVarFp.apiModelArtifactsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return localVarFp.deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlOpsApi - interface
 * @export
 * @interface MlOpsApi
 */
export interface MlOpsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiDeviceCalibrationsList(page?: number, options?: any): AxiosPromise<PaginatedDeviceCalibrationList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiDeviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiDeviceCalibrationsRetrieve(id: number, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiDeviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiExperimentDeviceConfigsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentDeviceConfigList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment device config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiExperimentDeviceConfigsRetrieve(id: number, options?: any): AxiosPromise<ExperimentDeviceConfig>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiExperimentsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiExperimentsRetrieve(id: number, options?: any): AxiosPromise<Experiment>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiModelArtifactsList(page?: number, options?: any): AxiosPromise<PaginatedModelArtifactList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this model artifact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    apiModelArtifactsRetrieve(id: number, options?: any): AxiosPromise<ModelArtifact>;

    /**
     * 
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

}

/**
 * MlOpsApi - object-oriented interface
 * @export
 * @class MlOpsApi
 * @extends {BaseAPI}
 */
export class MlOpsApi extends BaseAPI implements MlOpsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiDeviceCalibrationsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiDeviceCalibrationsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiDeviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).apiDeviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiDeviceCalibrationsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiDeviceCalibrationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiDeviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).apiDeviceCalibrationsUpdate(id, deviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiExperimentDeviceConfigsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiExperimentDeviceConfigsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment device config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiExperimentDeviceConfigsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiExperimentDeviceConfigsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiExperimentsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiExperimentsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiExperimentsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiExperimentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiModelArtifactsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiModelArtifactsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this model artifact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public apiModelArtifactsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).apiModelArtifactsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnersGeeks3Api - axios parameter creator
 * @export
 */
export const PartnersGeeks3ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsList', 'id', id)
            const localVarPath = `/api/partners/3d-geeks/{id}/alerts/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnersGeeks3Api - functional programming interface
 * @export
 */
export const PartnersGeeks3ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnersGeeks3ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsList(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner3DGeeksAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnersGeeks3Api - factory interface
 * @export
 */
export const PartnersGeeks3ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnersGeeks3ApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList(id: string, options?: any): AxiosPromise<Partner3DGeeksAlert> {
            return localVarFp.alertsList(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnersGeeks3Api - interface
 * @export
 * @interface PartnersGeeks3Api
 */
export interface PartnersGeeks3ApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3ApiInterface
     */
    alertsList(id: string, options?: any): AxiosPromise<Partner3DGeeksAlert>;

}

/**
 * PartnersGeeks3Api - object-oriented interface
 * @export
 * @class PartnersGeeks3Api
 * @extends {BaseAPI}
 */
export class PartnersGeeks3Api extends BaseAPI implements PartnersGeeks3ApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3Api
     */
    public alertsList(id: string, options?: any) {
        return PartnersGeeks3ApiFp(this.configuration).alertsList(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnersGeeks3dApi - axios parameter creator
 * @export
 */
export const PartnersGeeks3dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRetrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metadataRetrieve', 'id', id)
            const localVarPath = `/api/partners/3d-geeks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnersGeeks3dApi - functional programming interface
 * @export
 */
export const PartnersGeeks3dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnersGeeks3dApiAxiosParamCreator(configuration)
    return {
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadataRetrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner3DGeeksMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadataRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnersGeeks3dApi - factory interface
 * @export
 */
export const PartnersGeeks3dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnersGeeks3dApiFp(configuration)
    return {
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRetrieve(id: string, options?: any): AxiosPromise<Partner3DGeeksMetadata> {
            return localVarFp.metadataRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnersGeeks3dApi - interface
 * @export
 * @interface PartnersGeeks3dApi
 */
export interface PartnersGeeks3dApiInterface {
    /**
     * 3D Geeks calls this endpoint to validate token & fetch printer metadata
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApiInterface
     */
    metadataRetrieve(id: string, options?: any): AxiosPromise<Partner3DGeeksMetadata>;

}

/**
 * PartnersGeeks3dApi - object-oriented interface
 * @export
 * @class PartnersGeeks3dApi
 * @extends {BaseAPI}
 */
export class PartnersGeeks3dApi extends BaseAPI implements PartnersGeeks3dApiInterface {
    /**
     * 3D Geeks calls this endpoint to validate token & fetch printer metadata
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApi
     */
    public metadataRetrieve(id: string, options?: any) {
        return PartnersGeeks3dApiFp(this.configuration).metadataRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteControlApi - axios parameter creator
 * @export
 */
export const RemoteControlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsPartialUpdate: async (id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCommandsPartialUpdate', 'id', id)
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRemoteControlCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCommandsRetrieve', 'id', id)
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsUpdate: async (id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCommandsUpdate', 'id', id)
            // verify required parameter 'remoteControlCommandRequest' is not null or undefined
            assertParamExists('apiCommandsUpdate', 'remoteControlCommandRequest', remoteControlCommandRequest)
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(remoteControlCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesPartialUpdate: async (id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiGcodeFilesPartialUpdate', 'id', id)
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesRetrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiGcodeFilesRetrieve', 'id', id)
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesUpdate: async (id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiGcodeFilesUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiGcodeFilesUpdate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiGcodeFilesUpdate', 'file', file)
            // verify required parameter 'fileHash' is not null or undefined
            assertParamExists('apiGcodeFilesUpdate', 'fileHash', fileHash)
            // verify required parameter 'octoprintDevice' is not null or undefined
            assertParamExists('apiGcodeFilesUpdate', 'octoprintDevice', octoprintDevice)
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesCreate: async (octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            assertParamExists('apiOctoprintDevicesCreate', 'octoPrintDeviceRequest', octoPrintDeviceRequest)
            const localVarPath = `/api/octoprint-devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint-devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOctoprintDevicesRetrieve', 'id', id)
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsCreate: async (printSessionRequest: PrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printSessionRequest' is not null or undefined
            assertParamExists('apiPrintSessionsCreate', 'printSessionRequest', printSessionRequest)
            const localVarPath = `/api/print-sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsRetrieve: async (session: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('apiPrintSessionsRetrieve', 'session', session)
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesList: async (name?: string, page?: number, user?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesPartialUpdate: async (id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPrinterProfilesPartialUpdate', 'id', id)
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPrinterProfilesRetrieve', 'id', id)
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesUpdate: async (id: number, printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPrinterProfilesUpdate', 'id', id)
            // verify required parameter 'printerProfileRequest' is not null or undefined
            assertParamExists('apiPrinterProfilesUpdate', 'printerProfileRequest', printerProfileRequest)
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printerProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesCreate: async (name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('gcodeFilesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('gcodeFilesCreate', 'file', file)
            // verify required parameter 'fileHash' is not null or undefined
            assertParamExists('gcodeFilesCreate', 'fileHash', fileHash)
            // verify required parameter 'octoprintDevice' is not null or undefined
            assertParamExists('gcodeFilesCreate', 'octoprintDevice', octoprintDevice)
            const localVarPath = `/api/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdateOrCreate: async (name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('gcodeFilesUpdateOrCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('gcodeFilesUpdateOrCreate', 'file', file)
            // verify required parameter 'fileHash' is not null or undefined
            assertParamExists('gcodeFilesUpdateOrCreate', 'fileHash', fileHash)
            // verify required parameter 'octoprintDevice' is not null or undefined
            assertParamExists('gcodeFilesUpdateOrCreate', 'octoprintDevice', octoprintDevice)
            const localVarPath = `/api/gcode-files/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesPartialUpdate: async (id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintDevicesPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdate: async (id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintDevicesUpdate', 'id', id)
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            assertParamExists('octoprintDevicesUpdate', 'octoPrintDeviceRequest', octoPrintDeviceRequest)
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdateOrCreate: async (octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            assertParamExists('octoprintDevicesUpdateOrCreate', 'octoPrintDeviceRequest', octoPrintDeviceRequest)
            const localVarPath = `/api/octoprint-devices/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionPartialUpdate: async (session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('printSessionPartialUpdate', 'session', session)
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPrintSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionUpdate: async (session: string, printSessionRequest: PrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            assertParamExists('printSessionUpdate', 'session', session)
            // verify required parameter 'printSessionRequest' is not null or undefined
            assertParamExists('printSessionUpdate', 'printSessionRequest', printSessionRequest)
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printSessionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesCreate: async (printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printerProfileRequest' is not null or undefined
            assertParamExists('printerProfilesCreate', 'printerProfileRequest', printerProfileRequest)
            const localVarPath = `/api/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printerProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdateOrCreate: async (printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printerProfileRequest' is not null or undefined
            assertParamExists('printerProfilesUpdateOrCreate', 'printerProfileRequest', printerProfileRequest)
            const localVarPath = `/api/printer-profiles/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printerProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteControlApi - functional programming interface
 * @export
 */
export const RemoteControlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RemoteControlApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommandsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRemoteControlCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommandsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommandsPartialUpdate(id, patchedRemoteControlCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommandsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommandsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCommandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCommandsUpdate(id, remoteControlCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGcodeFilesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGcodeFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGcodeFilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGcodeFilesRetrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGcodeFilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintDevicesCreate(octoPrintDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintDevicesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintDevicesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintDevicesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintDevicesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintSessionsCreate(printSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintSessionsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintSessionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintSessionsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintSessionsRetrieve(session: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintSessionsRetrieve(session, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrinterProfilesList(name?: string, page?: number, user?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrinterProfileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrinterProfilesList(name, page, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrinterProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrinterProfilesPartialUpdate(id, patchedPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrinterProfilesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrinterProfilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrinterProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrinterProfilesUpdate(id, printerProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gcodeFilesCreate(name, file, fileHash, octoprintDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintDevicesUpdate(id, octoPrintDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printSessionPartialUpdate(session, patchedPrintSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printSessionUpdate(session, printSessionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printerProfilesCreate(printerProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printerProfilesUpdateOrCreate(printerProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RemoteControlApi - factory interface
 * @export
 */
export const RemoteControlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RemoteControlApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlCommandList> {
            return localVarFp.apiCommandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand> {
            return localVarFp.apiCommandsPartialUpdate(id, patchedRemoteControlCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlCommand> {
            return localVarFp.apiCommandsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCommandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand> {
            return localVarFp.apiCommandsUpdate(id, remoteControlCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList> {
            return localVarFp.apiGcodeFilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.apiGcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesRetrieve(id: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.apiGcodeFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.apiGcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return localVarFp.apiOctoprintDevicesCreate(octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintDeviceList> {
            return localVarFp.apiOctoprintDevicesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintDevicesRetrieve(id: number, options?: any): AxiosPromise<OctoPrintDevice> {
            return localVarFp.apiOctoprintDevicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return localVarFp.apiPrintSessionsCreate(printSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionList> {
            return localVarFp.apiPrintSessionsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintSessionsRetrieve(session: string, options?: any): AxiosPromise<PrintSession> {
            return localVarFp.apiPrintSessionsRetrieve(session, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesList(name?: string, page?: number, user?: number, options?: any): AxiosPromise<PaginatedPrinterProfileList> {
            return localVarFp.apiPrinterProfilesList(name, page, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return localVarFp.apiPrinterProfilesPartialUpdate(id, patchedPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesRetrieve(id: number, options?: any): AxiosPromise<PrinterProfile> {
            return localVarFp.apiPrinterProfilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrinterProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return localVarFp.apiPrinterProfilesUpdate(id, printerProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.gcodeFilesCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return localVarFp.octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return localVarFp.octoprintDevicesUpdate(id, octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return localVarFp.octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return localVarFp.printSessionPartialUpdate(session, patchedPrintSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return localVarFp.printSessionUpdate(session, printSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrintSession> {
            return localVarFp.printerProfilesCreate(printerProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return localVarFp.printerProfilesUpdateOrCreate(printerProfileRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteControlApi - interface
 * @export
 * @interface RemoteControlApi
 */
export interface RemoteControlApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiCommandsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlCommandList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiCommandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiCommandsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiCommandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiGcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList>;

    /**
     * 
     * @param {string} id 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {string} [fileHash] 
     * @param {string} [octoprintDevice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiGcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiGcodeFilesRetrieve(id: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiGcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiOctoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiOctoprintDevicesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintDeviceList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiOctoprintDevicesRetrieve(id: number, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrintSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrintSessionsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionList>;

    /**
     * 
     * @param {string} session 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrintSessionsRetrieve(session: string, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {string} [name] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrinterProfilesList(name?: string, page?: number, user?: number, options?: any): AxiosPromise<PaginatedPrinterProfileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrinterProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrinterProfilesRetrieve(id: number, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    apiPrinterProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {string} session 
     * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {string} session 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

}

/**
 * RemoteControlApi - object-oriented interface
 * @export
 * @class RemoteControlApi
 * @extends {BaseAPI}
 */
export class RemoteControlApi extends BaseAPI implements RemoteControlApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiCommandsList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiCommandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiCommandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiCommandsPartialUpdate(id, patchedRemoteControlCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiCommandsRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiCommandsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiCommandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiCommandsUpdate(id, remoteControlCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiGcodeFilesList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiGcodeFilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {string} [fileHash] 
     * @param {string} [octoprintDevice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiGcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any) {
        return RemoteControlApiFp(this.configuration).apiGcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiGcodeFilesRetrieve(id: string, options?: any) {
        return RemoteControlApiFp(this.configuration).apiGcodeFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiGcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).apiGcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiOctoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiOctoprintDevicesCreate(octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiOctoprintDevicesList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiOctoprintDevicesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiOctoprintDevicesRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiOctoprintDevicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrintSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrintSessionsCreate(printSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrintSessionsList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrintSessionsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrintSessionsRetrieve(session: string, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrintSessionsRetrieve(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrinterProfilesList(name?: string, page?: number, user?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrinterProfilesList(name, page, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrinterProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrinterProfilesPartialUpdate(id, patchedPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrinterProfilesRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrinterProfilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public apiPrinterProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).apiPrinterProfilesUpdate(id, printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesUpdate(id, octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionPartialUpdate(session, patchedPrintSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionUpdate(session, printSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesCreate(printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesUpdateOrCreate(printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TelemetryApi - axios parameter creator
 * @export
 */
export const TelemetryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsCreate: async (octoPrintEventRequest: OctoPrintEventRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintEventRequest' is not null or undefined
            assertParamExists('apiOctoprintEventsCreate', 'octoPrintEventRequest', octoPrintEventRequest)
            const localVarPath = `/api/octoprint-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOctoprintEventsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintJobEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-job-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print job event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintJobEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPrintJobEventsRetrieve', 'id', id)
            const localVarPath = `/api/print-job-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintNannyPluginEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-nanny-plugin-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print nanny plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintNannyPluginEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPrintNannyPluginEventsRetrieve', 'id', id)
            const localVarPath = `/api/print-nanny-plugin-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRemoteCommandEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/remote-command-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote command event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRemoteCommandEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRemoteCommandEventsRetrieve', 'id', id)
            const localVarPath = `/api/remote-command-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTelemetryEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/telemetry-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this telemetry event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTelemetryEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTelemetryEventsRetrieve', 'id', id)
            const localVarPath = `/api/telemetry-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TelemetryApi - functional programming interface
 * @export
 */
export const TelemetryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TelemetryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintEventsCreate(octoPrintEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOctoprintEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOctoprintEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintJobEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintJobEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintJobEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print job event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintJobEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintJobEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintJobEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintNannyPluginEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintNannyPluginEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintNannyPluginEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print nanny plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPrintNannyPluginEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintNannyPluginEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPrintNannyPluginEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRemoteCommandEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRemoteCommandEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRemoteCommandEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote command event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRemoteCommandEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteCommandEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRemoteCommandEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTelemetryEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedTelemetryEventPolymorphicList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTelemetryEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this telemetry event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTelemetryEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelemetryEventPolymorphic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTelemetryEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TelemetryApi - factory interface
 * @export
 */
export const TelemetryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TelemetryApiFp(configuration)
    return {
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): AxiosPromise<OctoPrintEvent> {
            return localVarFp.apiOctoprintEventsCreate(octoPrintEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintEventList> {
            return localVarFp.apiOctoprintEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOctoprintEventsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintEvent> {
            return localVarFp.apiOctoprintEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintJobEventsList(page?: number, options?: any): AxiosPromise<PaginatedPrintJobEventList> {
            return localVarFp.apiPrintJobEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print job event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintJobEventsRetrieve(id: number, options?: any): AxiosPromise<PrintJobEvent> {
            return localVarFp.apiPrintJobEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintNannyPluginEventsList(page?: number, options?: any): AxiosPromise<PaginatedPrintNannyPluginEventList> {
            return localVarFp.apiPrintNannyPluginEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print nanny plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPrintNannyPluginEventsRetrieve(id: number, options?: any): AxiosPromise<PrintNannyPluginEvent> {
            return localVarFp.apiPrintNannyPluginEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRemoteCommandEventsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteCommandEventList> {
            return localVarFp.apiRemoteCommandEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote command event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRemoteCommandEventsRetrieve(id: number, options?: any): AxiosPromise<RemoteCommandEvent> {
            return localVarFp.apiRemoteCommandEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTelemetryEventsList(page?: number, options?: any): AxiosPromise<PaginatedTelemetryEventPolymorphicList> {
            return localVarFp.apiTelemetryEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this telemetry event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTelemetryEventsRetrieve(id: number, options?: any): AxiosPromise<TelemetryEventPolymorphic> {
            return localVarFp.apiTelemetryEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TelemetryApi - interface
 * @export
 * @interface TelemetryApi
 */
export interface TelemetryApiInterface {
    /**
     * 
     * @param {OctoPrintEventRequest} octoPrintEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiOctoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): AxiosPromise<OctoPrintEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiOctoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiOctoprintEventsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiPrintJobEventsList(page?: number, options?: any): AxiosPromise<PaginatedPrintJobEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this print job event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiPrintJobEventsRetrieve(id: number, options?: any): AxiosPromise<PrintJobEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiPrintNannyPluginEventsList(page?: number, options?: any): AxiosPromise<PaginatedPrintNannyPluginEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this print nanny plugin event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiPrintNannyPluginEventsRetrieve(id: number, options?: any): AxiosPromise<PrintNannyPluginEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiRemoteCommandEventsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteCommandEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote command event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiRemoteCommandEventsRetrieve(id: number, options?: any): AxiosPromise<RemoteCommandEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiTelemetryEventsList(page?: number, options?: any): AxiosPromise<PaginatedTelemetryEventPolymorphicList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this telemetry event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApiInterface
     */
    apiTelemetryEventsRetrieve(id: number, options?: any): AxiosPromise<TelemetryEventPolymorphic>;

}

/**
 * TelemetryApi - object-oriented interface
 * @export
 * @class TelemetryApi
 * @extends {BaseAPI}
 */
export class TelemetryApi extends BaseAPI implements TelemetryApiInterface {
    /**
     * 
     * @param {OctoPrintEventRequest} octoPrintEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiOctoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any) {
        return TelemetryApiFp(this.configuration).apiOctoprintEventsCreate(octoPrintEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiOctoprintEventsList(page?: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiOctoprintEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiOctoprintEventsRetrieve(id: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiOctoprintEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiPrintJobEventsList(page?: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiPrintJobEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this print job event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiPrintJobEventsRetrieve(id: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiPrintJobEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiPrintNannyPluginEventsList(page?: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiPrintNannyPluginEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this print nanny plugin event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiPrintNannyPluginEventsRetrieve(id: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiPrintNannyPluginEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiRemoteCommandEventsList(page?: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiRemoteCommandEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote command event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiRemoteCommandEventsRetrieve(id: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiRemoteCommandEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiTelemetryEventsList(page?: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiTelemetryEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this telemetry event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TelemetryApi
     */
    public apiTelemetryEventsRetrieve(id: number, options?: any) {
        return TelemetryApiFp(this.configuration).apiTelemetryEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMeRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPartialUpdate: async (id: number, patchedUserRequest?: PatchedUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersPartialUpdate', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersRetrieve', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUpdate: async (id: number, userRequest: UserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersUpdate', 'id', id)
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('apiUsersUpdate', 'userRequest', userRequest)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersMeRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersMeRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersPartialUpdate(id, patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUpdate(id: number, userRequest: UserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUpdate(id, userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersList(page?: number, options?: any): AxiosPromise<PaginatedUserList> {
            return localVarFp.apiUsersList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersMeRetrieve(options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersPartialUpdate(id, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUpdate(id: number, userRequest: UserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.apiUsersUpdate(id, userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    apiUsersList(page?: number, options?: any): AxiosPromise<PaginatedUserList>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    apiUsersMeRetrieve(options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    apiUsersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    apiUsersRetrieve(id: number, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    apiUsersUpdate(id: number, userRequest: UserRequest, options?: any): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersList(page?: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersMeRetrieve(options?: any) {
        return UsersApiFp(this.configuration).apiUsersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any) {
        return UsersApiFp(this.configuration).apiUsersPartialUpdate(id, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersRetrieve(id: number, options?: any) {
        return UsersApiFp(this.configuration).apiUsersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiUsersUpdate(id: number, userRequest: UserRequest, options?: any) {
        return UsersApiFp(this.configuration).apiUsersUpdate(id, userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


