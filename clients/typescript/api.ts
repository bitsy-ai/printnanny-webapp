/* tslint:disable */
/* eslint-disable */
/**
 * printnanny-api-client
 * Official API client library for printnanny.ai
 *
 * The version of the OpenAPI document: 0.119.5
 * Contact: leigh@printnanny.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Achievement
 */
export interface Achievement {
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'created_dt': string;
    /**
     * 
     * @type {AchievementTypeEnum}
     * @memberof Achievement
     */
    'type': AchievementTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    'user': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AchievementTypeEnum = {
    FreeBeta: 'FreeBeta',
    FoundingMember: 'FoundingMember'
} as const;

export type AchievementTypeEnum = typeof AchievementTypeEnum[keyof typeof AchievementTypeEnum];


/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuth
 */
export interface CallbackTokenAuth {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'token': string;
}
/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuthRequest
 */
export interface CallbackTokenAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CrashReport
 */
export interface CrashReport {
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'os_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'os_logs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'browser_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'browser_logs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'serial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'posthog_session'?: string | null;
    /**
     * 
     * @type {CrashReportStatusEnum}
     * @memberof CrashReport
     */
    'status'?: CrashReportStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'support_comment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CrashReport
     */
    'user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CrashReport
     */
    'pi'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CrashReportStatusEnum = {
    Investigating: 'Investigating',
    Fixed: 'Fixed'
} as const;

export type CrashReportStatusEnum = typeof CrashReportStatusEnum[keyof typeof CrashReportStatusEnum];


/**
 * 
 * @export
 * @interface DjStripeCharge
 */
export interface DjStripeCharge {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCharge
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeApiErrorCode}
     * @memberof DjStripeCharge
     */
    'failure_code': StripeApiErrorCode;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'description'?: string | null;
    /**
     * Amount charged (as decimal).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount': string;
    /**
     * Amount (as decimal) captured (can be less than the amount attribute on the charge if a partial capture was issued).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount_captured'?: string | null;
    /**
     * Amount (as decimal) refunded (can be less than the amount attribute on the charge if a partial refund was issued).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount_refunded': string;
    /**
     * ID of the Connect application that created the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application'?: string;
    /**
     * The amount (as decimal) of the application fee (if any) requested for the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application_fee_amount'?: string | null;
    /**
     * Billing information associated with the PaymentMethod at the time of the transaction.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'billing_details'?: { [key: string]: any; } | null;
    /**
     * The full statement descriptor that is passed to card networks, and that is displayed on your customers\' credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'calculated_statement_descriptor'?: string;
    /**
     * If the charge was created without capturing, this boolean represents whether or not it is still uncaptured or has since been captured.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'captured'?: boolean;
    /**
     * The currency in which the charge was made.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'currency': string;
    /**
     * Whether the charge has been disputed.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'disputed'?: boolean;
    /**
     * Message to user further explaining reason for charge failure if available.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'failure_message'?: string;
    /**
     * Hash with information on fraud assessments for the charge.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'fraud_details'?: { [key: string]: any; } | null;
    /**
     * Details about whether or not the payment was accepted, and why.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'outcome'?: { [key: string]: any; } | null;
    /**
     * True if the charge succeeded, or was successfully authorized for later capture, False otherwise.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'paid'?: boolean;
    /**
     * Details about the payment method at the time of the transaction.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'payment_method_details'?: { [key: string]: any; } | null;
    /**
     * The email address that the receipt for this charge was sent to.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_email'?: string;
    /**
     * The transaction number that appears on email receipts sent for this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_number'?: string;
    /**
     * This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_url'?: string;
    /**
     * Whether or not the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'refunded'?: boolean;
    /**
     * Shipping information for the charge
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers\' statements. Must contain at least one letter, maximum 22 characters.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'statement_descriptor'?: string | null;
    /**
     * Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that\'s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'statement_descriptor_suffix'?: string | null;
    /**
     * The status of the payment.
     * @type {StripeSourceCodeVerificationStatus}
     * @memberof DjStripeCharge
     */
    'status': StripeSourceCodeVerificationStatus;
    /**
     * An optional dictionary including the account to automatically transfer to as part of a destination charge.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'transfer_data'?: { [key: string]: any; } | null;
    /**
     * A string that identifies this transaction as part of a group.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'transfer_group'?: string | null;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_owner_account'?: string | null;
    /**
     * The application fee (if any) for the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application_fee'?: string | null;
    /**
     * The balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'balance_transaction'?: string | null;
    /**
     * The customer associated with this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'customer'?: string | null;
    /**
     * Details about the dispute if the charge has been disputed.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'dispute'?: string | null;
    /**
     * The invoice this charge is for if one exists.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'invoice'?: string | null;
    /**
     * The account (if any) the charge was made on behalf of without triggering an automatic transfer.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'on_behalf_of'?: string | null;
    /**
     * PaymentIntent associated with this charge, if one exists.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'payment_intent'?: string | null;
    /**
     * PaymentMethod used in this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'payment_method'?: string | null;
    /**
     * The source used for this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'source'?: string | null;
    /**
     * The transfer which created this charge. Only present if the charge came from another Stripe account.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'source_transfer'?: string | null;
    /**
     * The transfer to the `destination` account (only applicable if the charge was created using the `destination` parameter).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'transfer'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripeCheckoutSession
 */
export interface DjStripeCheckoutSession {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeSessionBillingAddressCollection}
     * @memberof DjStripeCheckoutSession
     */
    'billing_address_collection': StripeSessionBillingAddressCollection;
    /**
     * 
     * @type {StripeSessionMode}
     * @memberof DjStripeCheckoutSession
     */
    'mode': StripeSessionMode;
    /**
     * 
     * @type {StripeSubmitTypeStatus}
     * @memberof DjStripeCheckoutSession
     */
    'submit_type': StripeSubmitTypeStatus;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCheckoutSession
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'description'?: string | null;
    /**
     * The URL the customer will be directed to if theydecide to cancel payment and return to your website.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'cancel_url'?: string;
    /**
     * A unique string to reference the Checkout Session.This can be a customer ID, a cart ID, or similar, andcan be used to reconcile the session with your internal systems.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'client_reference_id'?: string;
    /**
     * If provided, this value will be used when the Customer object is created.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'customer_email'?: string;
    /**
     * The line items, plans, or SKUs purchased by the customer.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'display_items'?: { [key: string]: any; } | null;
    /**
     * The IETF language tag of the locale Checkout is displayed in.If blank or auto, the browser\'s locale is used.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'locale'?: string;
    /**
     * The list of payment method types (e.g. card) that this Checkout Session is allowed to accept.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'payment_method_types': { [key: string]: any; };
    /**
     * The URL the customer will be directed to after the payment or subscriptioncreation is successful.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'success_url'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_owner_account'?: string | null;
    /**
     * Customer this Checkout is for if one exists.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'customer'?: string | null;
    /**
     * PaymentIntent created if SKUs or line items were provided.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'payment_intent'?: string | null;
    /**
     * Subscription created if one or more plans were provided.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'subscription'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripeCustomer
 */
export interface DjStripeCustomer {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'djstripe_id': number;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'description'?: string | null;
    /**
     * The customer\'s address.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'address'?: { [key: string]: any; } | null;
    /**
     * Current balance (in cents), if any, being stored on the customer\'s account. If negative, the customer has credit to apply to the next invoice. If positive, the customer has an amount owed that will be added to the next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account for recurring billing purposes (i.e., subscriptions, invoices, invoice items).
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'balance'?: number | null;
    /**
     * The currency the customer can be charged in for recurring billing purposes
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'currency'?: string;
    /**
     * Whether or not the latest charge for the customer\'s latest invoice has failed.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'delinquent'?: boolean | null;
    /**
     * Whether the Customer instance has been deleted upstream in Stripe or not.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'deleted'?: boolean | null;
    /**
     * If a coupon is present, the date at which it was applied.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'coupon_start': string;
    /**
     * If a coupon is present and has a limited duration, the date that the discount will end.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'coupon_end': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'email'?: string;
    /**
     * The prefix for the customer used to generate unique invoice numbers.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'invoice_prefix'?: string;
    /**
     * The customer\'s default invoice settings.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'invoice_settings'?: { [key: string]: any; } | null;
    /**
     * The customer\'s full name or business name.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'name'?: string;
    /**
     * The customer\'s phone number.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'phone'?: string;
    /**
     * The customer\'s preferred locales (languages), ordered by preference.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'preferred_locales'?: { [key: string]: any; } | null;
    /**
     * Shipping information associated with the customer.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * Describes the customer\'s tax exemption status. When set to reverse, invoice and receipt PDFs include the text \"Reverse charge\".
     * @type {StripeCustomerTaxExempt}
     * @memberof DjStripeCustomer
     */
    'tax_exempt'?: StripeCustomerTaxExempt;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'date_purged': string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_owner_account': string | null;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'default_source'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'coupon'?: number | null;
    /**
     * default payment method used for subscriptions and invoices for the customer.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'default_payment_method'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'subscriber': number | null;
}
/**
 * 
 * @export
 * @interface DjStripePaymentIntent
 */
export interface DjStripePaymentIntent {
    /**
     * 
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripePaymentIntentCancellationReason}
     * @memberof DjStripePaymentIntent
     */
    'cancellation_reason': StripePaymentIntentCancellationReason;
    /**
     * 
     * @type {Array<DjStripeCharge>}
     * @memberof DjStripePaymentIntent
     */
    'charges': Array<DjStripeCharge>;
    /**
     * 
     * @type {StripeIntentUsage}
     * @memberof DjStripePaymentIntent
     */
    'setup_future_usage': StripeIntentUsage;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripePaymentIntent
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Amount (in cents) intended to be collected by this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount': number;
    /**
     * Amount (in cents) that can be captured from this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount_capturable': number;
    /**
     * Amount (in cents) that was collected by this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount_received': number;
    /**
     * Populated when status is canceled, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'canceled_at'?: string | null;
    /**
     * Capture method of this PaymentIntent, one of automatic or manual.
     * @type {StripeConfirmationMethod}
     * @memberof DjStripePaymentIntent
     */
    'capture_method': StripeConfirmationMethod;
    /**
     * The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'client_secret': string;
    /**
     * Confirmation method of this PaymentIntent, one of manual or automatic.
     * @type {StripeConfirmationMethod}
     * @memberof DjStripePaymentIntent
     */
    'confirmation_method': StripeConfirmationMethod;
    /**
     * Three-letter ISO currency code
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'currency': string;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'description'?: string;
    /**
     * The payment error encountered in the previous PaymentIntent confirmation.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'last_payment_error'?: { [key: string]: any; } | null;
    /**
     * If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'next_action'?: { [key: string]: any; } | null;
    /**
     * The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'payment_method_types': { [key: string]: any; };
    /**
     * Email address that the receipt for the resulting payment will be sent to.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'receipt_email'?: string;
    /**
     * Shipping information for this PaymentIntent.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * For non-card charges, you can use this value as the complete description that appears on your customers\' statements. Must contain at least one letter, maximum 22 characters.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'statement_descriptor'?: string;
    /**
     * Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.
     * @type {StripePaymentIntentStatus}
     * @memberof DjStripePaymentIntent
     */
    'status': StripePaymentIntentStatus;
    /**
     * The data with which to automatically create a Transfer when the payment is finalized. See the PaymentIntents Connect usage guide for details.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'transfer_data'?: { [key: string]: any; } | null;
    /**
     * A string that identifies the resulting payment as part of a group. See the PaymentIntents Connect usage guide for details.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'transfer_group'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_owner_account'?: string | null;
    /**
     * Customer this PaymentIntent is for if one exists.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'customer'?: string | null;
    /**
     * The account (if any) for which the funds of the PaymentIntent are intended.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'on_behalf_of'?: string | null;
    /**
     * Payment method used in this PaymentIntent.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'payment_method'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripePrice
 */
export interface DjStripePrice {
    /**
     * 
     * @type {number}
     * @memberof DjStripePrice
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeBillingScheme}
     * @memberof DjStripePrice
     */
    'billing_scheme': StripeBillingScheme;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'human_readable_price': string;
    /**
     * 
     * @type {StripePriceTiersMode}
     * @memberof DjStripePrice
     */
    'tiers_mode': StripePriceTiersMode;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripePrice
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripePrice
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripePrice
     */
    'description'?: string | null;
    /**
     * Whether the price can be used for new purchases.
     * @type {boolean}
     * @memberof DjStripePrice
     */
    'active': boolean;
    /**
     * Three-letter ISO currency code
     * @type {string}
     * @memberof DjStripePrice
     */
    'currency': string;
    /**
     * A brief description of the plan, hidden from customers.
     * @type {string}
     * @memberof DjStripePrice
     */
    'nickname'?: string;
    /**
     * The recurring components of a price such as `interval` and `usage_type`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'recurring'?: { [key: string]: any; } | null;
    /**
     * Whether the price is for a one-time purchase or a recurring (subscription) purchase.
     * @type {StripePriceType}
     * @memberof DjStripePrice
     */
    'type': StripePriceType;
    /**
     * The unit amount in cents to be charged, represented as a whole integer if possible. Null if a sub-cent precision is required.
     * @type {number}
     * @memberof DjStripePrice
     */
    'unit_amount'?: number | null;
    /**
     * The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
     * @type {string}
     * @memberof DjStripePrice
     */
    'unit_amount_decimal'?: string | null;
    /**
     * A lookup key used to retrieve prices dynamically from a static string.
     * @type {string}
     * @memberof DjStripePrice
     */
    'lookup_key'?: string | null;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'tiers'?: { [key: string]: any; } | null;
    /**
     * Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'transform_quantity'?: { [key: string]: any; } | null;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_owner_account'?: string | null;
    /**
     * The product this price is associated with.
     * @type {string}
     * @memberof DjStripePrice
     */
    'product': string;
}
/**
 * 
 * @export
 * @interface DjStripeProduct
 */
export interface DjStripeProduct {
    /**
     * 
     * @type {number}
     * @memberof DjStripeProduct
     */
    'djstripe_id': number;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'description'?: string | null;
    /**
     * The product\'s name, meant to be displayable to the customer. Applicable to both `service` and `good` types.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'name': string;
    /**
     * The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.
     * @type {StripeProductType}
     * @memberof DjStripeProduct
     */
    'type': StripeProductType;
    /**
     * Whether the product is currently available for purchase. Only applicable to products of `type=good`.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'active'?: boolean | null;
    /**
     * A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`). Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'attributes'?: { [key: string]: any; } | null;
    /**
     * A short one-line description of the product, meant to be displayableto the customer. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'caption'?: string;
    /**
     * An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'deactivate_on'?: { [key: string]: any; } | null;
    /**
     * A list of up to 8 URLs of images for this product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'images'?: { [key: string]: any; } | null;
    /**
     * The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own `package_dimensions`. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'package_dimensions'?: { [key: string]: any; } | null;
    /**
     * Whether this product is a shipped good. Only applicable to products of `type=good`.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'shippable'?: boolean | null;
    /**
     * A URL of a publicly-accessible webpage for this product. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'url'?: string | null;
    /**
     * Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used. Only available on products of type=`service`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'unit_label'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_owner_account'?: string | null;
}
/**
 * 
 * @export
 * @interface EmailAlertSettings
 */
export interface EmailAlertSettings {
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EmailAlertSettings
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof EmailAlertSettings
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailAlertSettings
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof EmailAlertSettings
     */
    'event_types'?: Array<EventTypesEnum>;
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface EmailAlertSettingsRequest
 */
export interface EmailAlertSettingsRequest {
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettingsRequest
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailAlertSettingsRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof EmailAlertSettingsRequest
     */
    'event_types'?: Array<EventTypesEnum>;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuth
 */
export interface EmailAuth {
    /**
     * 
     * @type {string}
     * @memberof EmailAuth
     */
    'email': string;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuthRequest
 */
export interface EmailAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailAuthRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface EmailWaitlist
 */
export interface EmailWaitlist {
    /**
     * 
     * @type {number}
     * @memberof EmailWaitlist
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlist
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlist
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface EmailWaitlistRequest
 */
export interface EmailWaitlistRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlistRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'code': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EventTypesEnum = {
    PrintQuality: 'PrintQuality',
    PrintStarted: 'PrintStarted',
    PrintDone: 'PrintDone',
    PrintProgress: 'PrintProgress',
    PrintPaused: 'PrintPaused',
    PrintCancelled: 'PrintCancelled'
} as const;

export type EventTypesEnum = typeof EventTypesEnum[keyof typeof EventTypesEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const GcodeEventType = {
    M300: 'M300',
    M245: 'M245',
    G4: 'G4',
    M112: 'M112',
    M600: 'M600',
    M701: 'M701',
    M702: 'M702',
    G28: 'G28',
    M81: 'M81',
    M80: 'M80'
} as const;

export type GcodeEventType = typeof GcodeEventType[keyof typeof GcodeEventType];


/**
 * 
 * @export
 * @interface GcodeFile
 */
export interface GcodeFile {
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'created_dt': string;
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'user': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JanusConfigType = {
    Cloud: 'cloud',
    Edge: 'edge'
} as const;

export type JanusConfigType = typeof JanusConfigType[keyof typeof JanusConfigType];


/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface NatsOrganization
 */
export interface NatsOrganization {
    /**
     * 
     * @type {number}
     * @memberof NatsOrganization
     */
    'id': number;
    /**
     * The name of the organization
     * @type {string}
     * @memberof NatsOrganization
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NatsOrganization
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganization
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganization
     */
    'modified': string;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof NatsOrganization
     */
    'slug': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganization
     */
    'json'?: { [key: string]: any; };
    /**
     * Enable JetStream for all users/apps belonging to NatsOrganization account
     * @type {boolean}
     * @memberof NatsOrganization
     */
    'jetstream_enabled'?: boolean;
    /**
     * JetStream memory resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganization
     */
    'jetstream_max_mem'?: string;
    /**
     * JetStream file resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganization
     */
    'jetstream_max_file'?: string;
    /**
     * JetStream max number of streams (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganization
     */
    'jetstream_max_streams'?: number;
    /**
     * JetStream max number of consumers (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganization
     */
    'jetstream_max_consumers'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'imports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'exports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'users': Array<number>;
}
/**
 * 
 * @export
 * @interface NatsOrganizationRequest
 */
export interface NatsOrganizationRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NatsOrganizationRequest
     */
    'is_active'?: boolean;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'slug': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganizationRequest
     */
    'json'?: { [key: string]: any; };
    /**
     * Enable JetStream for all users/apps belonging to NatsOrganization account
     * @type {boolean}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_enabled'?: boolean;
    /**
     * JetStream memory resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_mem'?: string;
    /**
     * JetStream file resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_file'?: string;
    /**
     * JetStream max number of streams (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_streams'?: number;
    /**
     * JetStream max number of consumers (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_consumers'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganizationRequest
     */
    'imports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganizationRequest
     */
    'exports': Array<number>;
}
/**
 * 
 * @export
 * @interface NatsOrganizationUser
 */
export interface NatsOrganizationUser {
    /**
     * 
     * @type {number}
     * @memberof NatsOrganizationUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganizationUser
     */
    'app_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof NatsOrganizationUser
     */
    'organization': number;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganizationUser
     */
    'creds': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganizationUser
     */
    'json'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OctoPrintBackup
 */
export interface OctoPrintBackup {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'file': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrintGcodeEvent
 */
export interface OctoPrintGcodeEvent {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintGcodeEvent
     */
    'id': string;
    /**
     * 
     * @type {OctoPrintGcodeEventSubjectPatternEnum}
     * @memberof OctoPrintGcodeEvent
     */
    'subject_pattern': OctoPrintGcodeEventSubjectPatternEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintGcodeEvent
     */
    'created_dt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintGcodeEvent
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {GcodeEventType}
     * @memberof OctoPrintGcodeEvent
     */
    'event_type': GcodeEventType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintGcodeEvent
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintGcodeEvent
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintGcodeEventRequest
 */
export interface OctoPrintGcodeEventRequest {
    /**
     * 
     * @type {OctoPrintGcodeEventSubjectPatternEnum}
     * @memberof OctoPrintGcodeEventRequest
     */
    'subject_pattern': OctoPrintGcodeEventSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintGcodeEventRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {GcodeEventType}
     * @memberof OctoPrintGcodeEventRequest
     */
    'event_type': GcodeEventType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintGcodeEventRequest
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintGcodeEventRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintGcodeEventSubjectPatternEnum = {
    PiPiIdOctoprintGcode: 'pi.{pi_id}.octoprint.gcode'
} as const;

export type OctoPrintGcodeEventSubjectPatternEnum = typeof OctoPrintGcodeEventSubjectPatternEnum[keyof typeof OctoPrintGcodeEventSubjectPatternEnum];


/**
 * Serialize OctoPrint print job status events: https://docs.octoprint.org/en/master/events/index.html?highlight=events#printing
 * @export
 * @interface OctoPrintPrintJobPayload
 */
export interface OctoPrintPrintJobPayload {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayload
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayload
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayload
     */
    'origin': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobPayload
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobPayload
     */
    'time'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintPrintJobPayload
     */
    'position': { [key: string]: any; };
}
/**
 * Serialize OctoPrint print job status events: https://docs.octoprint.org/en/master/events/index.html?highlight=events#printing
 * @export
 * @interface OctoPrintPrintJobPayloadRequest
 */
export interface OctoPrintPrintJobPayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'origin': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'time'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintPrintJobPayloadRequest
     */
    'position': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OctoPrintPrintJobStatus
 */
export interface OctoPrintPrintJobStatus {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobStatus
     */
    'id': string;
    /**
     * 
     * @type {OctoPrintPrintJobStatusSubjectPatternEnum}
     * @memberof OctoPrintPrintJobStatus
     */
    'subject_pattern': OctoPrintPrintJobStatusSubjectPatternEnum;
    /**
     * 
     * @type {OctoPrintPrintJobPayload}
     * @memberof OctoPrintPrintJobStatus
     */
    'payload': OctoPrintPrintJobPayload;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrintJobStatus
     */
    'created_dt': string;
    /**
     * 
     * @type {OctoPrintPrintJobStatusType}
     * @memberof OctoPrintPrintJobStatus
     */
    'event_type': OctoPrintPrintJobStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobStatus
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintPrintJobStatusRequest
 */
export interface OctoPrintPrintJobStatusRequest {
    /**
     * 
     * @type {OctoPrintPrintJobStatusSubjectPatternEnum}
     * @memberof OctoPrintPrintJobStatusRequest
     */
    'subject_pattern': OctoPrintPrintJobStatusSubjectPatternEnum;
    /**
     * 
     * @type {OctoPrintPrintJobPayloadRequest}
     * @memberof OctoPrintPrintJobStatusRequest
     */
    'payload': OctoPrintPrintJobPayloadRequest;
    /**
     * 
     * @type {OctoPrintPrintJobStatusType}
     * @memberof OctoPrintPrintJobStatusRequest
     */
    'event_type': OctoPrintPrintJobStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobStatusRequest
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrintJobStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintPrintJobStatusSubjectPatternEnum = {
    PiPiIdOctoprintPrintJob: 'pi.{pi_id}.octoprint.print_job'
} as const;

export type OctoPrintPrintJobStatusSubjectPatternEnum = typeof OctoPrintPrintJobStatusSubjectPatternEnum[keyof typeof OctoPrintPrintJobStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintPrintJobStatusType = {
    PrintProgress: 'PrintProgress',
    PrintStarted: 'PrintStarted',
    PrintFailed: 'PrintFailed',
    PrintDone: 'PrintDone',
    PrintCancelling: 'PrintCancelling',
    PrintCancelled: 'PrintCancelled',
    PrintPaused: 'PrintPaused',
    PrintResumed: 'PrintResumed'
} as const;

export type OctoPrintPrintJobStatusType = typeof OctoPrintPrintJobStatusType[keyof typeof OctoPrintPrintJobStatusType];


/**
 * 
 * @export
 * @interface OctoPrintPrinterStatus
 */
export interface OctoPrintPrinterStatus {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrinterStatus
     */
    'id': string;
    /**
     * 
     * @type {OctoPrintPrinterStatusSubjectPatternEnum}
     * @memberof OctoPrintPrinterStatus
     */
    'subject_pattern': OctoPrintPrinterStatusSubjectPatternEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintPrinterStatus
     */
    'created_dt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintPrinterStatus
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {OctoPrintPrinterStatusType}
     * @memberof OctoPrintPrinterStatus
     */
    'event_type': OctoPrintPrinterStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrinterStatus
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrinterStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintPrinterStatusRequest
 */
export interface OctoPrintPrinterStatusRequest {
    /**
     * 
     * @type {OctoPrintPrinterStatusSubjectPatternEnum}
     * @memberof OctoPrintPrinterStatusRequest
     */
    'subject_pattern': OctoPrintPrinterStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintPrinterStatusRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {OctoPrintPrinterStatusType}
     * @memberof OctoPrintPrinterStatusRequest
     */
    'event_type': OctoPrintPrinterStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrinterStatusRequest
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintPrinterStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintPrinterStatusSubjectPatternEnum = {
    PiPiIdOctoprintPrinter: 'pi.{pi_id}.octoprint.printer'
} as const;

export type OctoPrintPrinterStatusSubjectPatternEnum = typeof OctoPrintPrinterStatusSubjectPatternEnum[keyof typeof OctoPrintPrinterStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintPrinterStatusType = {
    PrinterOffline: 'PrinterOffline',
    PrinterOpenSerial: 'PrinterOpenSerial',
    PrinterConnecting: 'PrinterConnecting',
    PrinterOperational: 'PrinterOperational',
    PrinterStarting: 'PrinterStarting',
    PrinterInProgress: 'PrinterInProgress',
    PrinterCancelling: 'PrinterCancelling',
    PrinterPausing: 'PrinterPausing',
    PrinterPaused: 'PrinterPaused',
    PrinterResuming: 'PrinterResuming',
    PrinterFinishing: 'PrinterFinishing',
    PrinterError: 'PrinterError'
} as const;

export type OctoPrintPrinterStatusType = typeof OctoPrintPrinterStatusType[keyof typeof OctoPrintPrinterStatusType];


/**
 * 
 * @export
 * @interface OctoPrintServer
 */
export interface OctoPrintServer {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'id': number;
    /**
     * 
     * @type {OctoPrintSettings}
     * @memberof OctoPrintServer
     */
    'settings': OctoPrintSettings;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'venv_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'pip_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'python_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintServerRequest
 */
export interface OctoPrintServerRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'venv_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'pip_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'python_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintServerStatus
 */
export interface OctoPrintServerStatus {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerStatus
     */
    'id': string;
    /**
     * 
     * @type {OctoPrintServerStatusSubjectPatternEnum}
     * @memberof OctoPrintServerStatus
     */
    'subject_pattern': OctoPrintServerStatusSubjectPatternEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerStatus
     */
    'created_dt': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintServerStatus
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {OctoPrintServerStatusType}
     * @memberof OctoPrintServerStatus
     */
    'event_type': OctoPrintServerStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerStatus
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintServerStatusRequest
 */
export interface OctoPrintServerStatusRequest {
    /**
     * 
     * @type {OctoPrintServerStatusSubjectPatternEnum}
     * @memberof OctoPrintServerStatusRequest
     */
    'subject_pattern': OctoPrintServerStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintServerStatusRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {OctoPrintServerStatusType}
     * @memberof OctoPrintServerStatusRequest
     */
    'event_type': OctoPrintServerStatusType;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerStatusRequest
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintServerStatusSubjectPatternEnum = {
    PiPiIdOctoprintServer: 'pi.{pi_id}.octoprint.server'
} as const;

export type OctoPrintServerStatusSubjectPatternEnum = typeof OctoPrintServerStatusSubjectPatternEnum[keyof typeof OctoPrintServerStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintServerStatusType = {
    Test: 'Test',
    Startup: 'Startup',
    Shutdown: 'Shutdown'
} as const;

export type OctoPrintServerStatusType = typeof OctoPrintServerStatusType[keyof typeof OctoPrintServerStatusType];


/**
 * 
 * @export
 * @interface OctoPrintSettings
 */
export interface OctoPrintSettings {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'id': number;
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettings
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettings
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'octoprint_server': number;
}
/**
 * 
 * @export
 * @interface OctoPrintSettingsRequest
 */
export interface OctoPrintSettingsRequest {
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettingsRequest
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettingsRequest
     */
    'octoprint_server': number;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfile
 */
export interface OctoPrinterProfile {
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfile
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_width'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfileRequest
 */
export interface OctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * Djstripe\'s representation of Stripe Checkout model is missing a number of fields, like subtotal amount and shipping/tax charges  stripe_checkout_session_data is the raw JSON returned by stripe.checkout.Session.retrieve
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_dt': string;
    /**
     * 
     * @type {DjStripeCheckoutSession}
     * @memberof Order
     */
    'djstripe_checkout_session': DjStripeCheckoutSession;
    /**
     * 
     * @type {DjStripeCustomer}
     * @memberof Order
     */
    'djstripe_customer': DjStripeCustomer;
    /**
     * 
     * @type {DjStripePaymentIntent}
     * @memberof Order
     */
    'djstripe_payment_intent': DjStripePaymentIntent;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_shippable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_subscription': boolean;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'last_status': OrderStatus;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Order
     */
    'products': Array<Product>;
    /**
     * 
     * @type {Array<OrderStatus>}
     * @memberof Order
     */
    'status_history': Array<OrderStatus>;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'stripe_checkout_redirect_url': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'stripe_checkout_session_data': { [key: string]: any; };
    /**
     * 
     * @type {User}
     * @memberof Order
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'receipt_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'portal_url': string | null;
}
/**
 * 
 * @export
 * @interface OrderCheckout
 */
export interface OrderCheckout {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderCheckout
     */
    'products': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckout
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckout
     */
    'stripe_checkout_redirect_url': string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckout
     */
    'stripe_checkout_session_id': string;
}
/**
 * 
 * @export
 * @interface OrderCheckoutRequest
 */
export interface OrderCheckoutRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderCheckoutRequest
     */
    'products': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface OrderStatus
 */
export interface OrderStatus {
    /**
     * 
     * @type {number}
     * @memberof OrderStatus
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'created_dt': string;
    /**
     * 
     * @type {OrderStatusType}
     * @memberof OrderStatus
     */
    'status': OrderStatusType;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'order': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OrderStatusType = {
    CheckoutSessionCreated: 'checkout_session_created',
    CheckoutSessionCompleted: 'checkout_session_completed',
    CheckoutSessionExpired: 'checkout_session_expired',
    Processing: 'processing',
    ReadyToShip: 'ready_to_ship',
    Shipped: 'shipped',
    GoodsFulfilled: 'goods_fulfilled',
    ServiceFulfilled: 'service_fulfilled',
    RefundRequested: 'refund_requested',
    RefundGranted: 'refund_granted'
} as const;

export type OrderStatusType = typeof OrderStatusType[keyof typeof OrderStatusType];


/**
 * 
 * @export
 * @interface PaginatedAchievementList
 */
export interface PaginatedAchievementList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAchievementList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAchievementList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAchievementList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Achievement>}
     * @memberof PaginatedAchievementList
     */
    'results'?: Array<Achievement>;
}
/**
 * 
 * @export
 * @interface PaginatedCrashReportList
 */
export interface PaginatedCrashReportList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCrashReportList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCrashReportList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCrashReportList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CrashReport>}
     * @memberof PaginatedCrashReportList
     */
    'results'?: Array<CrashReport>;
}
/**
 * 
 * @export
 * @interface PaginatedEmailAlertSettingsList
 */
export interface PaginatedEmailAlertSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEmailAlertSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEmailAlertSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEmailAlertSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<EmailAlertSettings>}
     * @memberof PaginatedEmailAlertSettingsList
     */
    'results'?: Array<EmailAlertSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedGcodeFileList
 */
export interface PaginatedGcodeFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGcodeFileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GcodeFile>}
     * @memberof PaginatedGcodeFileList
     */
    'results'?: Array<GcodeFile>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintBackupList
 */
export interface PaginatedOctoPrintBackupList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintBackupList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintBackup>}
     * @memberof PaginatedOctoPrintBackupList
     */
    'results'?: Array<OctoPrintBackup>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintServerList
 */
export interface PaginatedOctoPrintServerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintServerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintServerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintServerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintServer>}
     * @memberof PaginatedOctoPrintServerList
     */
    'results'?: Array<OctoPrintServer>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintSettingsList
 */
export interface PaginatedOctoPrintSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintSettings>}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'results'?: Array<OctoPrintSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrinterProfileList
 */
export interface PaginatedOctoPrinterProfileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrinterProfile>}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'results'?: Array<OctoPrinterProfile>;
}
/**
 * 
 * @export
 * @interface PaginatedPiList
 */
export interface PaginatedPiList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPiList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pi>}
     * @memberof PaginatedPiList
     */
    'results'?: Array<Pi>;
}
/**
 * 
 * @export
 * @interface PaginatedPiSettingsList
 */
export interface PaginatedPiSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPiSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PiSettings>}
     * @memberof PaginatedPiSettingsList
     */
    'results'?: Array<PiSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicOctoPrintEventList
 */
export interface PaginatedPolymorphicOctoPrintEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicOctoPrintEventList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicOctoPrintEventList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicOctoPrintEventList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicOctoPrintEvent>}
     * @memberof PaginatedPolymorphicOctoPrintEventList
     */
    'results'?: Array<PolymorphicOctoPrintEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicPiCommandList
 */
export interface PaginatedPolymorphicPiCommandList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicPiCommandList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiCommandList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiCommandList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicPiCommand>}
     * @memberof PaginatedPolymorphicPiCommandList
     */
    'results'?: Array<PolymorphicPiCommand>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicPiEventList
 */
export interface PaginatedPolymorphicPiEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicPiEventList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiEventList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiEventList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicPiEvent>}
     * @memberof PaginatedPolymorphicPiEventList
     */
    'results'?: Array<PolymorphicPiEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicPiStatusList
 */
export interface PaginatedPolymorphicPiStatusList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicPiStatusList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiStatusList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicPiStatusList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicPiStatus>}
     * @memberof PaginatedPolymorphicPiStatusList
     */
    'results'?: Array<PolymorphicPiStatus>;
}
/**
 * 
 * @export
 * @interface PaginatedProductList
 */
export interface PaginatedProductList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProductList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PaginatedProductList
     */
    'results'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface PaginatedSystemInfoList
 */
export interface PaginatedSystemInfoList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSystemInfoList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SystemInfo>}
     * @memberof PaginatedSystemInfoList
     */
    'results'?: Array<SystemInfo>;
}
/**
 * 
 * @export
 * @interface PaginatedWebrtcStreamList
 */
export interface PaginatedWebrtcStreamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedWebrtcStreamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWebrtcStreamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWebrtcStreamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<WebrtcStream>}
     * @memberof PaginatedWebrtcStreamList
     */
    'results'?: Array<WebrtcStream>;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'new_password1': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'new_password2': string;
}
/**
 * Serializer for confirming a password reset attempt.
 * @export
 * @interface PasswordResetConfirmRequest
 */
export interface PasswordResetConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'new_password1': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'new_password2': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'token': string;
}
/**
 * Serializer for requesting a password reset e-mail.
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PatchedEmailAlertSettingsRequest
 */
export interface PatchedEmailAlertSettingsRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'event_types'?: Array<EventTypesEnum>;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintServerRequest
 */
export interface PatchedOctoPrintServerRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'base_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'venv_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pip_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'python_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintSettingsRequest
 */
export interface PatchedOctoPrintSettingsRequest {
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'octoprint_server'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrinterProfileRequest
 */
export interface PatchedOctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'octoprint_key'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedPiRequest
 */
export interface PatchedPiRequest {
    /**
     * 
     * @type {SbcEnum}
     * @memberof PatchedPiRequest
     */
    'sbc'?: SbcEnum;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof PatchedPiRequest
     */
    'hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPiRequest
     */
    'fqdn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPiRequest
     */
    'favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPiRequest
     */
    'setup_finished'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedPiSettingsRequest
 */
export interface PatchedPiSettingsRequest {
    /**
     * Send camera stream to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedPiSettingsRequest
     */
    'cloud_video_enabled'?: boolean;
    /**
     * Send telemetry and performance profiling data to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedPiSettingsRequest
     */
    'telemetry_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedPiSettingsRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedSystemInfoRequest
 */
export interface PatchedSystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'machine_id'?: string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'revision'?: string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'model'?: string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'serial'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'ram'?: number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'os_version_id'?: string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'os_build_id'?: string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof PatchedSystemInfoRequest
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'uptime'?: number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'rootfs_size'?: number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'rootfs_used'?: number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'bootfs_size'?: number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'bootfs_used'?: number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'datafs_size'?: number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'datafs_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'last_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedWebrtcStreamRequest
 */
export interface PatchedWebrtcStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedWebrtcStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof PatchedWebrtcStreamRequest
     */
    'config_type'?: JanusConfigType;
}
/**
 * 
 * @export
 * @interface Pi
 */
export interface Pi {
    /**
     * 
     * @type {number}
     * @memberof Pi
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'last_boot': string | null;
    /**
     * 
     * @type {PiSettings}
     * @memberof Pi
     */
    'settings': PiSettings;
    /**
     * 
     * @type {User}
     * @memberof Pi
     */
    'user': User;
    /**
     * 
     * @type {SystemInfo}
     * @memberof Pi
     */
    'system_info': SystemInfo;
    /**
     * 
     * @type {WebrtcStream}
     * @memberof Pi
     */
    'webrtc_edge': WebrtcStream;
    /**
     * 
     * @type {WebrtcStream}
     * @memberof Pi
     */
    'webrtc_cloud': WebrtcStream;
    /**
     * 
     * @type {OctoPrintServer}
     * @memberof Pi
     */
    'octoprint_server': OctoPrintServer;
    /**
     * 
     * @type {PiUrls}
     * @memberof Pi
     */
    'urls': PiUrls;
    /**
     * 
     * @type {PiNatsApp}
     * @memberof Pi
     */
    'nats_app': PiNatsApp;
    /**
     * 
     * @type {SbcEnum}
     * @memberof Pi
     */
    'sbc'?: SbcEnum;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'created_dt': string;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof Pi
     */
    'hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'fqdn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pi
     */
    'favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pi
     */
    'setup_finished'?: boolean;
}
/**
 * 
 * @export
 * @interface PiBootCommand
 */
export interface PiBootCommand {
    /**
     * 
     * @type {string}
     * @memberof PiBootCommand
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiBootCommand
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiBootCommandSubjectPatternEnum}
     * @memberof PiBootCommand
     */
    'subject_pattern': PiBootCommandSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiBootCommand
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiBootCommandType}
     * @memberof PiBootCommand
     */
    'event_type': PiBootCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiBootCommand
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiBootCommandRequest
 */
export interface PiBootCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof PiBootCommandRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiBootCommandRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiBootCommandSubjectPatternEnum}
     * @memberof PiBootCommandRequest
     */
    'subject_pattern': PiBootCommandSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiBootCommandRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiBootCommandType}
     * @memberof PiBootCommandRequest
     */
    'event_type': PiBootCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiBootCommandRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiBootCommandSubjectPatternEnum = {
    PiPiIdCommandBoot: 'pi.{pi_id}.command.boot'
} as const;

export type PiBootCommandSubjectPatternEnum = typeof PiBootCommandSubjectPatternEnum[keyof typeof PiBootCommandSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiBootCommandType = {
    Reboot: 'Reboot',
    Shutdown: 'Shutdown',
    SyncSettings: 'SyncSettings',
    SystemctlShow: 'SystemctlShow'
} as const;

export type PiBootCommandType = typeof PiBootCommandType[keyof typeof PiBootCommandType];


/**
 * 
 * @export
 * @interface PiBootStatus
 */
export interface PiBootStatus {
    /**
     * 
     * @type {string}
     * @memberof PiBootStatus
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiBootStatus
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiBootStatusSubjectPatternEnum}
     * @memberof PiBootStatus
     */
    'subject_pattern': PiBootStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiBootStatus
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiBootStatusType}
     * @memberof PiBootStatus
     */
    'event_type': PiBootStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiBootStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiBootStatusRequest
 */
export interface PiBootStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PiBootStatusRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiBootStatusRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiBootStatusSubjectPatternEnum}
     * @memberof PiBootStatusRequest
     */
    'subject_pattern': PiBootStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiBootStatusRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiBootStatusType}
     * @memberof PiBootStatusRequest
     */
    'event_type': PiBootStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiBootStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiBootStatusSubjectPatternEnum = {
    PiPiIdStatusBoot: 'pi.{pi_id}.status.boot'
} as const;

export type PiBootStatusSubjectPatternEnum = typeof PiBootStatusSubjectPatternEnum[keyof typeof PiBootStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiBootStatusType = {
    SystemctlShow: 'SystemctlShow',
    RebootStarted: 'RebootStarted',
    RebootError: 'RebootError',
    ShutdownStarted: 'ShutdownStarted',
    ShutdownError: 'ShutdownError',
    BootStarted: 'BootStarted',
    BootSuccess: 'BootSuccess',
    BootDegraded: 'BootDegraded',
    SyncSettingsStarted: 'SyncSettingsStarted',
    SyncSettingsSuccess: 'SyncSettingsSuccess',
    SyncSettingsError: 'SyncSettingsError'
} as const;

export type PiBootStatusType = typeof PiBootStatusType[keyof typeof PiBootStatusType];


/**
 * 
 * @export
 * @interface PiCamCommand
 */
export interface PiCamCommand {
    /**
     * 
     * @type {string}
     * @memberof PiCamCommand
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiCamCommand
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiCamCommandSubjectPatternEnum}
     * @memberof PiCamCommand
     */
    'subject_pattern': PiCamCommandSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiCamCommand
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiCamCommandType}
     * @memberof PiCamCommand
     */
    'event_type': PiCamCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiCamCommand
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiCamCommandRequest
 */
export interface PiCamCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof PiCamCommandRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiCamCommandRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiCamCommandSubjectPatternEnum}
     * @memberof PiCamCommandRequest
     */
    'subject_pattern': PiCamCommandSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiCamCommandRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiCamCommandType}
     * @memberof PiCamCommandRequest
     */
    'event_type': PiCamCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiCamCommandRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiCamCommandSubjectPatternEnum = {
    PiPiIdCommandCam: 'pi.{pi_id}.command.cam'
} as const;

export type PiCamCommandSubjectPatternEnum = typeof PiCamCommandSubjectPatternEnum[keyof typeof PiCamCommandSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiCamCommandType = {
    CamStart: 'CamStart',
    CamStop: 'CamStop'
} as const;

export type PiCamCommandType = typeof PiCamCommandType[keyof typeof PiCamCommandType];


/**
 * 
 * @export
 * @interface PiCamStatus
 */
export interface PiCamStatus {
    /**
     * 
     * @type {string}
     * @memberof PiCamStatus
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiCamStatus
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiCamStatusSubjectPatternEnum}
     * @memberof PiCamStatus
     */
    'subject_pattern': PiCamStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiCamStatus
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiCamStatusType}
     * @memberof PiCamStatus
     */
    'event_type': PiCamStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiCamStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiCamStatusRequest
 */
export interface PiCamStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PiCamStatusRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiCamStatusRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiCamStatusSubjectPatternEnum}
     * @memberof PiCamStatusRequest
     */
    'subject_pattern': PiCamStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiCamStatusRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {PiCamStatusType}
     * @memberof PiCamStatusRequest
     */
    'event_type': PiCamStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiCamStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiCamStatusSubjectPatternEnum = {
    PiPiIdStatusCam: 'pi.{pi_id}.status.cam'
} as const;

export type PiCamStatusSubjectPatternEnum = typeof PiCamStatusSubjectPatternEnum[keyof typeof PiCamStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiCamStatusType = {
    CamStarted: 'CamStarted',
    CamStartSuccess: 'CamStartSuccess',
    CamError: 'CamError',
    CamStopped: 'CamStopped'
} as const;

export type PiCamStatusType = typeof PiCamStatusType[keyof typeof PiCamStatusType];


/**
 * 
 * @export
 * @interface PiNatsApp
 */
export interface PiNatsApp {
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'app_name'?: string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof PiNatsApp
     */
    'json'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'pi': number;
    /**
     * 
     * @type {NatsOrganization}
     * @memberof PiNatsApp
     */
    'organization': NatsOrganization;
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'organization_user': number;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_server_uri': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_ws_uri': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_subject_pattern': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_subject_pattern_template': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_moonraker_request': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_moonraker_request': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_moonraker_response': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_moonraker_response': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_klipper_status': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_klipper_status': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_broker_host': string;
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'mqtt_broker_port': number;
}
/**
 * 
 * @export
 * @interface PiNatsAppRequest
 */
export interface PiNatsAppRequest {
    /**
     * 
     * @type {string}
     * @memberof PiNatsAppRequest
     */
    'app_name'?: string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof PiNatsAppRequest
     */
    'json'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PiNatsAppRequest
     */
    'pi': number;
    /**
     * 
     * @type {NatsOrganizationRequest}
     * @memberof PiNatsAppRequest
     */
    'organization': NatsOrganizationRequest;
    /**
     * 
     * @type {number}
     * @memberof PiNatsAppRequest
     */
    'organization_user': number;
}
/**
 * 
 * @export
 * @interface PiRequest
 */
export interface PiRequest {
    /**
     * 
     * @type {SbcEnum}
     * @memberof PiRequest
     */
    'sbc'?: SbcEnum;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof PiRequest
     */
    'hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiRequest
     */
    'fqdn'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PiRequest
     */
    'favorite'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PiRequest
     */
    'setup_finished'?: boolean;
}
/**
 * 
 * @export
 * @interface PiSettings
 */
export interface PiSettings {
    /**
     * 
     * @type {number}
     * @memberof PiSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PiSettings
     */
    'updated_dt': string;
    /**
     * Send camera stream to PrintNanny Cloud
     * @type {boolean}
     * @memberof PiSettings
     */
    'cloud_video_enabled'?: boolean;
    /**
     * Send telemetry and performance profiling data to PrintNanny Cloud
     * @type {boolean}
     * @memberof PiSettings
     */
    'telemetry_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PiSettings
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiSettingsRequest
 */
export interface PiSettingsRequest {
    /**
     * Send camera stream to PrintNanny Cloud
     * @type {boolean}
     * @memberof PiSettingsRequest
     */
    'cloud_video_enabled'?: boolean;
    /**
     * Send telemetry and performance profiling data to PrintNanny Cloud
     * @type {boolean}
     * @memberof PiSettingsRequest
     */
    'telemetry_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PiSettingsRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiSoftwareUpdateCommand
 */
export interface PiSoftwareUpdateCommand {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommand
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommand
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiSoftwareUpdatePayload}
     * @memberof PiSoftwareUpdateCommand
     */
    'payload': PiSoftwareUpdatePayload;
    /**
     * 
     * @type {PiSoftwareUpdateCommandSubjectPatternEnum}
     * @memberof PiSoftwareUpdateCommand
     */
    'subject_pattern': PiSoftwareUpdateCommandSubjectPatternEnum;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommand
     */
    'version': string;
    /**
     * 
     * @type {PiSoftwareUpdateCommandType}
     * @memberof PiSoftwareUpdateCommand
     */
    'event_type': PiSoftwareUpdateCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiSoftwareUpdateCommand
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiSoftwareUpdateCommandRequest
 */
export interface PiSoftwareUpdateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiSoftwareUpdatePayloadRequest}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'payload': PiSoftwareUpdatePayloadRequest;
    /**
     * 
     * @type {PiSoftwareUpdateCommandSubjectPatternEnum}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'subject_pattern': PiSoftwareUpdateCommandSubjectPatternEnum;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'version': string;
    /**
     * 
     * @type {PiSoftwareUpdateCommandType}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'event_type': PiSoftwareUpdateCommandType;
    /**
     * 
     * @type {number}
     * @memberof PiSoftwareUpdateCommandRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiSoftwareUpdateCommandSubjectPatternEnum = {
    PiPiIdCommandSwupdate: 'pi.{pi_id}.command.swupdate'
} as const;

export type PiSoftwareUpdateCommandSubjectPatternEnum = typeof PiSoftwareUpdateCommandSubjectPatternEnum[keyof typeof PiSoftwareUpdateCommandSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiSoftwareUpdateCommandType = {
    Swupdate: 'Swupdate',
    SwupdateRollback: 'SwupdateRollback'
} as const;

export type PiSoftwareUpdateCommandType = typeof PiSoftwareUpdateCommandType[keyof typeof PiSoftwareUpdateCommandType];


/**
 * 
 * @export
 * @interface PiSoftwareUpdatePayload
 */
export interface PiSoftwareUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'wic_tarball_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'wic_bmap_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'manifest_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'swu_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'version_id': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayload
     */
    'version_codename': string;
}
/**
 * 
 * @export
 * @interface PiSoftwareUpdatePayloadRequest
 */
export interface PiSoftwareUpdatePayloadRequest {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'wic_tarball_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'wic_bmap_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'manifest_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'swu_url': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'version_id': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdatePayloadRequest
     */
    'version_codename': string;
}
/**
 * 
 * @export
 * @interface PiSoftwareUpdateStatus
 */
export interface PiSoftwareUpdateStatus {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatus
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatus
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiSoftwareUpdateStatusSubjectPatternEnum}
     * @memberof PiSoftwareUpdateStatus
     */
    'subject_pattern': PiSoftwareUpdateStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiSoftwareUpdateStatus
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatus
     */
    'version': string;
    /**
     * 
     * @type {PiSoftwareUpdateStatusType}
     * @memberof PiSoftwareUpdateStatus
     */
    'event_type': PiSoftwareUpdateStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiSoftwareUpdateStatus
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PiSoftwareUpdateStatusRequest
 */
export interface PiSoftwareUpdateStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'created_dt'?: string;
    /**
     * 
     * @type {PiSoftwareUpdateStatusSubjectPatternEnum}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'subject_pattern': PiSoftwareUpdateStatusSubjectPatternEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'version': string;
    /**
     * 
     * @type {PiSoftwareUpdateStatusType}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'event_type': PiSoftwareUpdateStatusType;
    /**
     * 
     * @type {number}
     * @memberof PiSoftwareUpdateStatusRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PiSoftwareUpdateStatusSubjectPatternEnum = {
    PiPiIdStatusSwupdate: 'pi.{pi_id}.status.swupdate'
} as const;

export type PiSoftwareUpdateStatusSubjectPatternEnum = typeof PiSoftwareUpdateStatusSubjectPatternEnum[keyof typeof PiSoftwareUpdateStatusSubjectPatternEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const PiSoftwareUpdateStatusType = {
    SwupdateStarted: 'SwupdateStarted',
    SwupdateSuccess: 'SwupdateSuccess',
    SwupdateError: 'SwupdateError'
} as const;

export type PiSoftwareUpdateStatusType = typeof PiSoftwareUpdateStatusType[keyof typeof PiSoftwareUpdateStatusType];


/**
 * 
 * @export
 * @interface PiUrls
 */
export interface PiUrls {
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'mission_control': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'octoprint': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'swupdate': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'syncthing': string;
}
/**
 * @type PolymorphicOctoPrintEvent
 * @export
 */
export type PolymorphicOctoPrintEvent = OctoPrintGcodeEvent | OctoPrintPrintJobStatus | OctoPrintPrinterStatus | OctoPrintServerStatus;

/**
 * @type PolymorphicOctoPrintEventRequest
 * @export
 */
export type PolymorphicOctoPrintEventRequest = OctoPrintGcodeEventRequest | OctoPrintPrintJobStatusRequest | OctoPrintPrinterStatusRequest | OctoPrintServerStatusRequest;

/**
 * @type PolymorphicPiCommand
 * @export
 */
export type PolymorphicPiCommand = PiBootCommand | PiCamCommand | PiSoftwareUpdateCommand;

/**
 * @type PolymorphicPiCommandRequest
 * @export
 */
export type PolymorphicPiCommandRequest = PiBootCommandRequest | PiCamCommandRequest | PiSoftwareUpdateCommandRequest;

/**
 * @type PolymorphicPiEvent
 * @export
 */
export type PolymorphicPiEvent = PiBootCommand | PiBootStatus | PiCamCommand | PiCamStatus | PiSoftwareUpdateCommand | PiSoftwareUpdateStatus;

/**
 * @type PolymorphicPiEventRequest
 * @export
 */
export type PolymorphicPiEventRequest = PiBootCommandRequest | PiBootStatusRequest | PiCamCommandRequest | PiCamStatusRequest | PiSoftwareUpdateCommandRequest | PiSoftwareUpdateStatusRequest;

/**
 * @type PolymorphicPiStatus
 * @export
 */
export type PolymorphicPiStatus = PiBootStatus | PiCamStatus | PiSoftwareUpdateStatus;

/**
 * @type PolymorphicPiStatusRequest
 * @export
 */
export type PolymorphicPiStatusRequest = PiBootStatusRequest | PiCamStatusRequest | PiSoftwareUpdateStatusRequest;

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * 
     * @type {DjStripeProduct}
     * @memberof Product
     */
    'djstripe_product': DjStripeProduct;
    /**
     * 
     * @type {Array<DjStripePrice>}
     * @memberof Product
     */
    'prices': Array<DjStripePrice>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sku': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'unit_label': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'statement_descriptor': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_shippable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_preorder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_subscription': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'stripe_price_lookup_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'stripe_product_id'?: string | null;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password1': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password2': string;
}
/**
 * 
 * @export
 * @interface ResendEmailVerificationRequest
 */
export interface ResendEmailVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof ResendEmailVerificationRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RestAuthDetail
 */
export interface RestAuthDetail {
    /**
     * 
     * @type {string}
     * @memberof RestAuthDetail
     */
    'detail': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SbcEnum = {
    Rpi4: 'rpi_4'
} as const;

export type SbcEnum = typeof SbcEnum[keyof typeof SbcEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeApiErrorCode = {
    AccountAlreadyExists: 'account_already_exists',
    AccountCountryInvalidAddress: 'account_country_invalid_address',
    AccountInvalid: 'account_invalid',
    AccountNumberInvalid: 'account_number_invalid',
    AlipayUpgradeRequired: 'alipay_upgrade_required',
    AmountTooLarge: 'amount_too_large',
    AmountTooSmall: 'amount_too_small',
    ApiKeyExpired: 'api_key_expired',
    BalanceInsufficient: 'balance_insufficient',
    BankAccountExists: 'bank_account_exists',
    BankAccountUnusable: 'bank_account_unusable',
    BankAccountUnverified: 'bank_account_unverified',
    BitcoinUpgradeRequired: 'bitcoin_upgrade_required',
    CardDeclined: 'card_declined',
    ChargeAlreadyCaptured: 'charge_already_captured',
    ChargeAlreadyRefunded: 'charge_already_refunded',
    ChargeDisputed: 'charge_disputed',
    ChargeExceedsSourceLimit: 'charge_exceeds_source_limit',
    ChargeExpiredForCapture: 'charge_expired_for_capture',
    CountryUnsupported: 'country_unsupported',
    CouponExpired: 'coupon_expired',
    CustomerMaxSubscriptions: 'customer_max_subscriptions',
    EmailInvalid: 'email_invalid',
    ExpiredCard: 'expired_card',
    IdempotencyKeyInUse: 'idempotency_key_in_use',
    IncorrectAddress: 'incorrect_address',
    IncorrectCvc: 'incorrect_cvc',
    IncorrectNumber: 'incorrect_number',
    IncorrectZip: 'incorrect_zip',
    InstantPayoutsUnsupported: 'instant_payouts_unsupported',
    InvalidCardType: 'invalid_card_type',
    InvalidChargeAmount: 'invalid_charge_amount',
    InvalidCvc: 'invalid_cvc',
    InvalidExpiryMonth: 'invalid_expiry_month',
    InvalidExpiryYear: 'invalid_expiry_year',
    InvalidNumber: 'invalid_number',
    InvalidSourceUsage: 'invalid_source_usage',
    InvalidSwipeData: 'invalid_swipe_data',
    InvoiceNoCustomerLineItems: 'invoice_no_customer_line_items',
    InvoiceNoSubscriptionLineItems: 'invoice_no_subscription_line_items',
    InvoiceNotEditable: 'invoice_not_editable',
    InvoiceUpcomingNone: 'invoice_upcoming_none',
    LivemodeMismatch: 'livemode_mismatch',
    Missing: 'missing',
    NotAllowedOnStandardAccount: 'not_allowed_on_standard_account',
    OrderCreationFailed: 'order_creation_failed',
    OrderRequiredSettings: 'order_required_settings',
    OrderStatusInvalid: 'order_status_invalid',
    OrderUpstreamTimeout: 'order_upstream_timeout',
    OutOfInventory: 'out_of_inventory',
    ParameterInvalidEmpty: 'parameter_invalid_empty',
    ParameterInvalidInteger: 'parameter_invalid_integer',
    ParameterInvalidStringBlank: 'parameter_invalid_string_blank',
    ParameterInvalidStringEmpty: 'parameter_invalid_string_empty',
    ParameterMissing: 'parameter_missing',
    ParameterUnknown: 'parameter_unknown',
    ParametersExclusive: 'parameters_exclusive',
    PaymentIntentAuthenticationFailure: 'payment_intent_authentication_failure',
    PaymentIntentIncompatiblePaymentMethod: 'payment_intent_incompatible_payment_method',
    PaymentIntentInvalidParameter: 'payment_intent_invalid_parameter',
    PaymentIntentPaymentAttemptFailed: 'payment_intent_payment_attempt_failed',
    PaymentIntentUnexpectedState: 'payment_intent_unexpected_state',
    PaymentMethodUnactivated: 'payment_method_unactivated',
    PaymentMethodUnexpectedState: 'payment_method_unexpected_state',
    PayoutsNotAllowed: 'payouts_not_allowed',
    PlatformApiKeyExpired: 'platform_api_key_expired',
    PostalCodeInvalid: 'postal_code_invalid',
    ProcessingError: 'processing_error',
    ProductInactive: 'product_inactive',
    RateLimit: 'rate_limit',
    ResourceAlreadyExists: 'resource_already_exists',
    ResourceMissing: 'resource_missing',
    RoutingNumberInvalid: 'routing_number_invalid',
    SecretKeyRequired: 'secret_key_required',
    SepaUnsupportedAccount: 'sepa_unsupported_account',
    ShippingCalculationFailed: 'shipping_calculation_failed',
    SkuInactive: 'sku_inactive',
    StateUnsupported: 'state_unsupported',
    TaxIdInvalid: 'tax_id_invalid',
    TaxesCalculationFailed: 'taxes_calculation_failed',
    TestmodeChargesOnly: 'testmode_charges_only',
    TlsVersionUnsupported: 'tls_version_unsupported',
    TokenAlreadyUsed: 'token_already_used',
    TokenInUse: 'token_in_use',
    TransfersNotAllowed: 'transfers_not_allowed',
    UpstreamOrderCreationFailed: 'upstream_order_creation_failed',
    UrlInvalid: 'url_invalid'
} as const;

export type StripeApiErrorCode = typeof StripeApiErrorCode[keyof typeof StripeApiErrorCode];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeBillingScheme = {
    PerUnit: 'per_unit',
    Tiered: 'tiered'
} as const;

export type StripeBillingScheme = typeof StripeBillingScheme[keyof typeof StripeBillingScheme];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeConfirmationMethod = {
    Automatic: 'automatic',
    Manual: 'manual'
} as const;

export type StripeConfirmationMethod = typeof StripeConfirmationMethod[keyof typeof StripeConfirmationMethod];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeCustomerTaxExempt = {
    Exempt: 'exempt',
    None: 'none',
    Reverse: 'reverse'
} as const;

export type StripeCustomerTaxExempt = typeof StripeCustomerTaxExempt[keyof typeof StripeCustomerTaxExempt];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeIntentUsage = {
    OffSession: 'off_session',
    OnSession: 'on_session'
} as const;

export type StripeIntentUsage = typeof StripeIntentUsage[keyof typeof StripeIntentUsage];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePaymentIntentCancellationReason = {
    Abandoned: 'abandoned',
    Automatic: 'automatic',
    Duplicate: 'duplicate',
    FailedInvoice: 'failed_invoice',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    VoidInvoice: 'void_invoice'
} as const;

export type StripePaymentIntentCancellationReason = typeof StripePaymentIntentCancellationReason[keyof typeof StripePaymentIntentCancellationReason];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePaymentIntentStatus = {
    Canceled: 'canceled',
    Processing: 'processing',
    RequiresAction: 'requires_action',
    RequiresCapture: 'requires_capture',
    RequiresConfirmation: 'requires_confirmation',
    RequiresPaymentMethod: 'requires_payment_method',
    Succeeded: 'succeeded'
} as const;

export type StripePaymentIntentStatus = typeof StripePaymentIntentStatus[keyof typeof StripePaymentIntentStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceTiersMode = {
    Graduated: 'graduated',
    Volume: 'volume'
} as const;

export type StripePriceTiersMode = typeof StripePriceTiersMode[keyof typeof StripePriceTiersMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripePriceType = {
    OneTime: 'one_time',
    Recurring: 'recurring'
} as const;

export type StripePriceType = typeof StripePriceType[keyof typeof StripePriceType];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeProductType = {
    Good: 'good',
    Service: 'service'
} as const;

export type StripeProductType = typeof StripeProductType[keyof typeof StripeProductType];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeSessionBillingAddressCollection = {
    Auto: 'auto',
    Required: 'required'
} as const;

export type StripeSessionBillingAddressCollection = typeof StripeSessionBillingAddressCollection[keyof typeof StripeSessionBillingAddressCollection];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeSessionMode = {
    Payment: 'payment',
    Setup: 'setup',
    Subscription: 'subscription'
} as const;

export type StripeSessionMode = typeof StripeSessionMode[keyof typeof StripeSessionMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeSourceCodeVerificationStatus = {
    Failed: 'failed',
    Pending: 'pending',
    Succeeded: 'succeeded'
} as const;

export type StripeSourceCodeVerificationStatus = typeof StripeSourceCodeVerificationStatus[keyof typeof StripeSourceCodeVerificationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const StripeSubmitTypeStatus = {
    Auto: 'auto',
    Book: 'book',
    Donate: 'donate',
    Pay: 'pay'
} as const;

export type StripeSubmitTypeStatus = typeof StripeSubmitTypeStatus[keyof typeof StripeSubmitTypeStatus];


/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_size_pretty': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_size_pretty': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_size_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'updated_dt': string;
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfo
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfo
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfo
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfo
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'ram': number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfo
     */
    'os_version_id': string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfo
     */
    'os_build_id': string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof SystemInfo
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof SystemInfo
     */
    'uptime': number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_size': number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_used': number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_size': number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_used': number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_size': number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_used': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface SystemInfoRequest
 */
export interface SystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'ram': number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'os_version_id': string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'os_build_id': string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof SystemInfoRequest
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'uptime': number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'rootfs_size': number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'rootfs_used': number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'bootfs_size': number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'bootfs_used': number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'datafs_size': number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'datafs_used': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'pi': number;
}
/**
 * Serializer for Token model.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_beta_tester': boolean;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'first_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'last_name'?: string | null;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface WebrtcStream
 */
export interface WebrtcStream {
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStream
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'admin_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'admin_secret': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'admin_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'api_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_token': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_url': string;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof WebrtcStream
     */
    'config_type'?: JanusConfigType;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'created_dt': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'id': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebrtcStream
     */
    'info': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStream
     */
    'is_admin': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'pi': number;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'pt': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'rtp_domain': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'video_rtp_port': number | null;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'data_rtp_port': number | null;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'rtpmap': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'stream_pin': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'stream_secret': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'ws_url': string;
}
/**
 * 
 * @export
 * @interface WebrtcStreamRequest
 */
export interface WebrtcStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof WebrtcStreamRequest
     */
    'config_type'?: JanusConfigType;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthEmailCreate: async (emailAuthRequest: EmailAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailAuthRequest' is not null or undefined
            assertParamExists('accounts2faAuthEmailCreate', 'emailAuthRequest', emailAuthRequest)
            const localVarPath = `/accounts/2fa-auth/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthTokenCreate: async (callbackTokenAuthRequest: CallbackTokenAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenAuthRequest' is not null or undefined
            assertParamExists('accounts2faAuthTokenCreate', 'callbackTokenAuthRequest', callbackTokenAuthRequest)
            const localVarPath = `/accounts/2fa-auth/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsEmailWaitlistCreate: async (emailWaitlistRequest: EmailWaitlistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailWaitlistRequest' is not null or undefined
            assertParamExists('accountsEmailWaitlistCreate', 'emailWaitlistRequest', emailWaitlistRequest)
            const localVarPath = `/api/accounts/email-waitlist/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailWaitlistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('accountsLoginCreate', 'loginRequest', loginRequest)
            const localVarPath = `/api/accounts/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordChangeCreate: async (passwordChangeRequest: PasswordChangeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('accountsPasswordChangeCreate', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/api/accounts/password/change/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate: async (passwordResetConfirmRequest: PasswordResetConfirmRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetConfirmRequest' is not null or undefined
            assertParamExists('accountsPasswordResetConfirmCreate', 'passwordResetConfirmRequest', passwordResetConfirmRequest)
            const localVarPath = `/api/accounts/password/reset/confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate: async (passwordResetRequest: PasswordResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetRequest' is not null or undefined
            assertParamExists('accountsPasswordResetCreate', 'passwordResetRequest', passwordResetRequest)
            const localVarPath = `/api/accounts/password/reset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationCreate: async (registerRequest: RegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('accountsRegistrationCreate', 'registerRequest', registerRequest)
            const localVarPath = `/api/accounts/registration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationResendEmailCreate: async (resendEmailVerificationRequest: ResendEmailVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendEmailVerificationRequest' is not null or undefined
            assertParamExists('accountsRegistrationResendEmailCreate', 'resendEmailVerificationRequest', resendEmailVerificationRequest)
            const localVarPath = `/api/accounts/registration/resend-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationVerifyEmailCreate: async (verifyEmailRequest: VerifyEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailRequest' is not null or undefined
            assertParamExists('accountsRegistrationVerifyEmailCreate', 'verifyEmailRequest', verifyEmailRequest)
            const localVarPath = `/api/accounts/registration/verify-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserNkeyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/nkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserPartialUpdate: async (patchedUserRequest?: PatchedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserUpdate: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('accountsUserUpdate', 'userRequest', userRequest)
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts2faAuthEmailCreate(emailAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallbackTokenAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts2faAuthTokenCreate(callbackTokenAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailWaitlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsEmailWaitlistCreate(emailWaitlistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLoginCreate(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogoutCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogoutCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordChangeCreate(passwordChangeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetCreate(passwordResetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationCreate(registerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserNkeyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NatsOrganizationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserNkeyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserPartialUpdate(patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserUpdate(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): AxiosPromise<EmailAuth> {
            return localVarFp.accounts2faAuthEmailCreate(emailAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<CallbackTokenAuth> {
            return localVarFp.accounts2faAuthTokenCreate(callbackTokenAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: any): AxiosPromise<EmailWaitlist> {
            return localVarFp.accountsEmailWaitlistCreate(emailWaitlistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate(loginRequest: LoginRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.accountsLoginCreate(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate(options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsLogoutCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordChangeCreate(passwordChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordResetCreate(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationCreate(registerRequest: RegisterRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.accountsRegistrationCreate(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserNkeyRetrieve(options?: any): AxiosPromise<NatsOrganizationUser> {
            return localVarFp.accountsUserNkeyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserPartialUpdate(patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserRetrieve(options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserUpdate(userRequest: UserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserUpdate(userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - interface
 * @export
 * @interface AccountsApi
 */
export interface AccountsApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAuth>;

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): AxiosPromise<CallbackTokenAuth>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {EmailWaitlistRequest} emailWaitlistRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig): AxiosPromise<EmailWaitlist>;

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig): AxiosPromise<Token>;

    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsLogoutCreate(options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @param {PasswordResetRequest} passwordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig): AxiosPromise<Token>;

    /**
     * 
     * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * 
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Providers user nkey credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserNkeyRetrieve(options?: AxiosRequestConfig): AxiosPromise<NatsOrganizationUser>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserRetrieve(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI implements AccountsApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accounts2faAuthEmailCreate(emailAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accounts2faAuthTokenCreate(callbackTokenAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {EmailWaitlistRequest} emailWaitlistRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsEmailWaitlistCreate(emailWaitlistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLoginCreate(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLogoutCreate(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLogoutCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordChangeCreate(passwordChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @param {PasswordResetRequest} passwordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetCreate(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationCreate(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Providers user nkey credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserNkeyRetrieve(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserNkeyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserPartialUpdate(patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserRetrieve(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserUpdate(userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AchievementsApi - axios parameter creator
 * @export
 */
export const AchievementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/achievements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AchievementsApi - functional programming interface
 * @export
 */
export const AchievementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AchievementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async achievementsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAchievementList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.achievementsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AchievementsApi - factory interface
 * @export
 */
export const AchievementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AchievementsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsList(page?: number, options?: any): AxiosPromise<PaginatedAchievementList> {
            return localVarFp.achievementsList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AchievementsApi - interface
 * @export
 * @interface AchievementsApi
 */
export interface AchievementsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApiInterface
     */
    achievementsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedAchievementList>;

}

/**
 * AchievementsApi - object-oriented interface
 * @export
 * @class AchievementsApi
 * @extends {BaseAPI}
 */
export class AchievementsApi extends BaseAPI implements AchievementsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public achievementsList(page?: number, options?: AxiosRequestConfig) {
        return AchievementsApiFp(this.configuration).achievementsList(page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailCreate: async (emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert-settings/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert-settings/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailPartialUpdate: async (id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailPartialUpdate', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEmailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailRetrieve', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailUpdate: async (id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailUpdate', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailCreate(emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEmailAlertSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailCreate(emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailList(page?: number, options?: any): AxiosPromise<PaginatedEmailAlertSettingsList> {
            return localVarFp.alertSettingsEmailList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailRetrieve(id: number, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - interface
 * @export
 * @interface AlertsApi
 */
export interface AlertsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertSettingsEmailList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedEmailAlertSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI implements AlertsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertSettingsEmailCreate(emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertSettingsEmailList(page?: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertSettingsEmailList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertSettingsEmailRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CrashReportsApi - axios parameter creator
 * @export
 */
export const CrashReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsCreate: async (description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/crash-reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/crash-reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsPartialUpdate: async (id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsPartialUpdate', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsRetrieve', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsUpdate: async (id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsUpdate', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrashReportsApi - functional programming interface
 * @export
 */
export const CrashReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrashReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCrashReportList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CrashReportsApi - factory interface
 * @export
 */
export const CrashReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrashReportsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsList(page?: number, options?: any): AxiosPromise<PaginatedCrashReportList> {
            return localVarFp.crashReportsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsRetrieve(id: string, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [user] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrashReportsApi - interface
 * @export
 * @interface CrashReportsApi
 */
export interface CrashReportsApiInterface {
    /**
     * 
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedCrashReportList>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

}

/**
 * CrashReportsApi - object-oriented interface
 * @export
 * @class CrashReportsApi
 * @extends {BaseAPI}
 */
export class CrashReportsApi extends BaseAPI implements CrashReportsApiInterface {
    /**
     * 
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsList(page?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsRetrieve(id: string, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [user] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, user?: number, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, user, pi, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        piUpdateOrCreate: async (piRequest?: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCreate: async (piRequest?: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisDestroy', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisLicenseZipRetrieve: async (piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisLicenseZipRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/license/zip/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisPartialUpdate: async (id: number, patchedPiRequest?: PatchedPiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisPartialUpdate', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisRetrieve', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsCreate: async (piId: number, piSettingsRequest: PiSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSettingsCreate', 'piId', piId)
            // verify required parameter 'piSettingsRequest' is not null or undefined
            assertParamExists('pisSettingsCreate', 'piSettingsRequest', piSettingsRequest)
            const localVarPath = `/api/pis/{pi_id}/settings/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSettingsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/settings/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PatchedPiSettingsRequest} [patchedPiSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsPartialUpdate: async (id: number, piId: number, patchedPiSettingsRequest?: PatchedPiSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSettingsPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSettingsPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPiSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSettingsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSettingsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsUpdate: async (id: number, piId: number, piSettingsRequest: PiSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSettingsUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSettingsUpdate', 'piId', piId)
            // verify required parameter 'piSettingsRequest' is not null or undefined
            assertParamExists('pisSettingsUpdate', 'piSettingsRequest', piSettingsRequest)
            const localVarPath = `/api/pis/{pi_id}/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoCreate: async (piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoCreate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('pisSystemInfoCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoPartialUpdate: async (id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSystemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoUpdate: async (id: number, piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisUpdate: async (id: number, piRequest?: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisUpdate', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate: async (id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate: async (id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate: async (piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/update-or-create/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webrtcStreamUpdateOrCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('webrtcStreamUpdateOrCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/update-or-create/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async piUpdateOrCreate(piRequest?: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.piUpdateOrCreate(piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCreate(piRequest?: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCreate(piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisLicenseZipRetrieve(piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPiList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisPartialUpdate(id, patchedPiRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSettingsCreate(piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSettingsCreate(piId, piSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSettingsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPiSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSettingsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PatchedPiSettingsRequest} [patchedPiSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSettingsPartialUpdate(id: number, piId: number, patchedPiSettingsRequest?: PatchedPiSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSettingsPartialUpdate(id, piId, patchedPiSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSettingsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSettingsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSettingsUpdate(id: number, piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PiSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSettingsUpdate(id, piId, piSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoCreate(piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSystemInfoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoUpdate(id, piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisUpdate(id: number, piRequest?: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisUpdate(id, piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebrtcStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfoUpdateOrCreate(piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        piUpdateOrCreate(piRequest?: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.piUpdateOrCreate(piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCreate(piRequest?: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisCreate(piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.pisDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisLicenseZipRetrieve(piId: number, options?: any): AxiosPromise<any> {
            return localVarFp.pisLicenseZipRetrieve(piId, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisList(page?: number, options?: any): AxiosPromise<PaginatedPiList> {
            return localVarFp.pisList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisPartialUpdate(id, patchedPiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisRetrieve(id: number, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsCreate(piId: number, piSettingsRequest: PiSettingsRequest, options?: any): AxiosPromise<PiSettings> {
            return localVarFp.pisSettingsCreate(piId, piSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPiSettingsList> {
            return localVarFp.pisSettingsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PatchedPiSettingsRequest} [patchedPiSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsPartialUpdate(id: number, piId: number, patchedPiSettingsRequest?: PatchedPiSettingsRequest, options?: any): AxiosPromise<PiSettings> {
            return localVarFp.pisSettingsPartialUpdate(id, piId, patchedPiSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsRetrieve(id: number, piId: number, options?: any): AxiosPromise<PiSettings> {
            return localVarFp.pisSettingsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this pi settings.
         * @param {number} piId 
         * @param {PiSettingsRequest} piSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSettingsUpdate(id: number, piId: number, piSettingsRequest: PiSettingsRequest, options?: any): AxiosPromise<PiSettings> {
            return localVarFp.pisSettingsUpdate(id, piId, piSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoCreate(piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedSystemInfoList> {
            return localVarFp.pisSystemInfoList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoRetrieve(id: number, piId: number, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoUpdate(id, piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} [piRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisUpdate(id: number, piRequest?: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisUpdate(id, piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedWebrtcStreamList> {
            return localVarFp.pisWebrtcStreamsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve(id: number, piId: number, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.systemInfoUpdateOrCreate(piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - interface
 * @export
 * @interface DevicesApi
 */
export interface DevicesApiInterface {
    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    piUpdateOrCreate(piRequest?: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisCreate(piRequest?: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPiList>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PatchedPiRequest} [patchedPiRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * 
     * @param {number} piId 
     * @param {PiSettingsRequest} piSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSettingsCreate(piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<PiSettings>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSettingsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPiSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {PatchedPiSettingsRequest} [patchedPiSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSettingsPartialUpdate(id: number, piId: number, patchedPiSettingsRequest?: PatchedPiSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<PiSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSettingsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<PiSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {PiSettingsRequest} piSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSettingsUpdate(id: number, piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<PiSettings>;

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedSystemInfoList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisUpdate(id: number, piRequest?: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedWebrtcStreamList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI implements DevicesApiInterface {
    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public piUpdateOrCreate(piRequest?: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).piUpdateOrCreate(piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisCreate(piRequest?: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisCreate(piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisDestroy(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisLicenseZipRetrieve(piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisList(page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PatchedPiRequest} [patchedPiRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisPartialUpdate(id, patchedPiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisRetrieve(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {PiSettingsRequest} piSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSettingsCreate(piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSettingsCreate(piId, piSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSettingsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSettingsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {PatchedPiSettingsRequest} [patchedPiSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSettingsPartialUpdate(id: number, piId: number, patchedPiSettingsRequest?: PatchedPiSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSettingsPartialUpdate(id, piId, patchedPiSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSettingsRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSettingsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this pi settings.
     * @param {number} piId 
     * @param {PiSettingsRequest} piSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSettingsUpdate(id: number, piId: number, piSettingsRequest: PiSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSettingsUpdate(id, piId, piSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoCreate(piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoUpdate(id, piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PiRequest} [piRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisUpdate(id: number, piRequest?: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisUpdate(id, piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).systemInfoUpdateOrCreate(piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate: async (polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicOctoPrintEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintEventsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisAllEventsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsCreate: async (polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCommandsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsCommandsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/commands/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCreate: async (polymorphicPiEventRequest?: PolymorphicPiEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisEventsRetrieve', 'id', id)
            const localVarPath = `/api/pis/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsStatusList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsStatusList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/status/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusCreate: async (polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicOctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsCreate(polymorphicOctoPrintEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicOctoPrintEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicOctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisAllEventsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisAllEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCommandsCreate(polymorphicPiCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCommandsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCommandsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsCommandsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsCreate(polymorphicPiEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsStatusList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisStatusCreate(polymorphicPiStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisStatusList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisStatusList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: any): AxiosPromise<PolymorphicOctoPrintEvent> {
            return localVarFp.octoprintEventsCreate(polymorphicOctoPrintEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicOctoPrintEventList> {
            return localVarFp.octoprintEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve(id: string, options?: any): AxiosPromise<PolymorphicOctoPrintEvent> {
            return localVarFp.octoprintEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisAllEventsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiEventList> {
            return localVarFp.pisAllEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: any): AxiosPromise<PolymorphicPiCommand> {
            return localVarFp.pisCommandsCreate(polymorphicPiCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiCommandList> {
            return localVarFp.pisCommandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCommandsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiCommandList> {
            return localVarFp.pisEventsCommandsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: any): AxiosPromise<PolymorphicPiEvent> {
            return localVarFp.pisEventsCreate(polymorphicPiEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiEventList> {
            return localVarFp.pisEventsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsRetrieve(id: number, options?: any): AxiosPromise<PolymorphicPiEvent> {
            return localVarFp.pisEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsStatusList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiStatusList> {
            return localVarFp.pisEventsStatusList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: any): AxiosPromise<PolymorphicPiStatus> {
            return localVarFp.pisStatusCreate(polymorphicPiStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiStatusList> {
            return localVarFp.pisStatusList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicOctoPrintEvent>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicOctoPrintEventList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {string} id A UUID string identifying this base octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<PolymorphicOctoPrintEvent>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisAllEventsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiEventList>;

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiCommand>;

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisCommandsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiCommandList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiCommandList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiEvent>;

    /**
     * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiEventList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisEventsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiEvent>;

    /**
     * Interact with all status events for Raspberry Pi, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiStatusList>;

    /**
     * Interact with all status events for Raspberry Pi
     * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiStatus>;

    /**
     * Interact with all status events for Raspberry Pi
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pisStatusList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiStatusList>;

}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).octoprintEventsCreate(polymorphicOctoPrintEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).octoprintEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {string} id A UUID string identifying this base octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).octoprintEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisAllEventsList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisAllEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisCommandsCreate(polymorphicPiCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisCommandsList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisCommandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisEventsCommandsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisEventsCreate(polymorphicPiEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisEventsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisEventsRetrieve(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisEventsStatusList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi
     * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisStatusCreate(polymorphicPiStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pisStatusList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).pisStatusList(page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JanusApi - axios parameter creator
 * @export
 */
export const JanusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate: async (id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate: async (id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JanusApi - functional programming interface
 * @export
 */
export const JanusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JanusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebrtcStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JanusApi - factory interface
 * @export
 */
export const JanusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JanusApiFp(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedWebrtcStreamList> {
            return localVarFp.pisWebrtcStreamsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve(id: number, piId: number, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JanusApi - interface
 * @export
 * @interface JanusApi
 */
export interface JanusApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedWebrtcStreamList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

}

/**
 * JanusApi - object-oriented interface
 * @export
 * @class JanusApi
 * @extends {BaseAPI}
 */
export class JanusApi extends BaseAPI implements JanusApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OctoprintApi - axios parameter creator
 * @export
 */
export const OctoprintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate: async (hostname: string, name: string, octoprintVersion: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'hostname', hostname)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'name', name)
            // verify required parameter 'octoprintVersion' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'octoprintVersion', octoprintVersion)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'file', file)
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (hostname !== undefined) { 
                localVarFormParams.append('hostname', hostname as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (octoprintVersion !== undefined) { 
                localVarFormParams.append('octoprint_version', octoprintVersion as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintBackupsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/backups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCreate: async (octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintCreate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate: async (polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicOctoPrintEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintEventsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate: async (name: string, file: any, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'file', file)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'hash', hash)
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (hash !== undefined) { 
                localVarFormParams.append('hash', hash as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintGcodeFilesRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPartialUpdate: async (id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate: async (id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate: async (id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'id', id)
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintProfileUpdateOrCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintServerUpdateOrCreate: async (octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintServerUpdateOrCreate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate: async (octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsCreate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate: async (id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate: async (id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsUpdate', 'id', id)
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsUpdate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate: async (octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsUpdateOrCreate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintUpdate: async (id: number, octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintUpdate', 'id', id)
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintUpdate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisOctoprintList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisOctoprintList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/octoprint/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OctoprintApi - functional programming interface
 * @export
 */
export const OctoprintApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OctoprintApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintBackupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintCreate(octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicOctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsCreate(polymorphicOctoPrintEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicOctoPrintEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicOctoPrintEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesCreate(name, file, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGcodeFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrinterProfileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintServerUpdateOrCreate(octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintUpdate(id, octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisOctoprintList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisOctoprintList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OctoprintApi - factory interface
 * @export
 */
export const OctoprintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OctoprintApiFp(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintBackupList> {
            return localVarFp.octoprintBackupsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintCreate(octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: any): AxiosPromise<PolymorphicOctoPrintEvent> {
            return localVarFp.octoprintEventsCreate(polymorphicOctoPrintEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicOctoPrintEventList> {
            return localVarFp.octoprintEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {string} id A UUID string identifying this base octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve(id: string, options?: any): AxiosPromise<PolymorphicOctoPrintEvent> {
            return localVarFp.octoprintEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList> {
            return localVarFp.octoprintGcodeFilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve(id: number, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintServerList> {
            return localVarFp.octoprintList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrinterProfileList> {
            return localVarFp.octoprintPrinterProfilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintServerUpdateOrCreate(octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintSettingsList> {
            return localVarFp.octoprintSettingsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintUpdate(id, octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisOctoprintList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedOctoPrintServerList> {
            return localVarFp.pisOctoprintList(piId, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OctoprintApi - interface
 * @export
 * @interface OctoprintApi
 */
export interface OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintBackupList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicOctoPrintEvent>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintEventsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicOctoPrintEventList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {string} id A UUID string identifying this base octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<PolymorphicOctoPrintEvent>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedGcodeFileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintServerList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrinterProfileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    pisOctoprintList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintServerList>;

}

/**
 * OctoprintApi - object-oriented interface
 * @export
 * @class OctoprintApi
 * @extends {BaseAPI}
 */
export class OctoprintApi extends BaseAPI implements OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintCreate(octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicOctoPrintEventRequest} [polymorphicOctoPrintEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintEventsCreate(polymorphicOctoPrintEventRequest?: PolymorphicOctoPrintEventRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintEventsCreate(polymorphicOctoPrintEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintEventsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {string} id A UUID string identifying this base octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintEventsRetrieve(id: string, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintServerUpdateOrCreate(octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintUpdate(id, octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public pisOctoprintList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).pisOctoprintList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PisApi - axios parameter creator
 * @export
 */
export const PisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisAllEventsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsCreate: async (polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/commands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCommandsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsCommandsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/commands/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCreate: async (polymorphicPiEventRequest?: PolymorphicPiEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisEventsRetrieve', 'id', id)
            const localVarPath = `/api/pis/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsStatusList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisEventsStatusList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/events/status/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusCreate: async (polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicPiStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PisApi - functional programming interface
 * @export
 */
export const PisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PisApiAxiosParamCreator(configuration)
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisAllEventsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisAllEventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCommandsCreate(polymorphicPiCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCommandsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCommandsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsCommandsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsCreate(polymorphicPiEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisEventsStatusList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicPiStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisStatusCreate(polymorphicPiStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisStatusList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicPiStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisStatusList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PisApi - factory interface
 * @export
 */
export const PisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PisApiFp(configuration)
    return {
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisAllEventsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiEventList> {
            return localVarFp.pisAllEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: any): AxiosPromise<PolymorphicPiCommand> {
            return localVarFp.pisCommandsCreate(polymorphicPiCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all Raspberry Pi remote commands
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCommandsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiCommandList> {
            return localVarFp.pisCommandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCommandsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiCommandList> {
            return localVarFp.pisEventsCommandsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: any): AxiosPromise<PolymorphicPiEvent> {
            return localVarFp.pisEventsCreate(polymorphicPiEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiEventList> {
            return localVarFp.pisEventsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all events inheriting from BasePiEvent
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsRetrieve(id: number, options?: any): AxiosPromise<PolymorphicPiEvent> {
            return localVarFp.pisEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi, filtered by a single Pi
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisEventsStatusList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiStatusList> {
            return localVarFp.pisEventsStatusList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: any): AxiosPromise<PolymorphicPiStatus> {
            return localVarFp.pisStatusCreate(polymorphicPiStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Interact with all status events for Raspberry Pi
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisStatusList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicPiStatusList> {
            return localVarFp.pisStatusList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PisApi - interface
 * @export
 * @interface PisApi
 */
export interface PisApiInterface {
    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisAllEventsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiEventList>;

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiCommand>;

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisCommandsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiCommandList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiCommandList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiEvent>;

    /**
     * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiEventList>;

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisEventsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiEvent>;

    /**
     * Interact with all status events for Raspberry Pi, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiStatusList>;

    /**
     * Interact with all status events for Raspberry Pi
     * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicPiStatus>;

    /**
     * Interact with all status events for Raspberry Pi
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApiInterface
     */
    pisStatusList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicPiStatusList>;

}

/**
 * PisApi - object-oriented interface
 * @export
 * @class PisApi
 * @extends {BaseAPI}
 */
export class PisApi extends BaseAPI implements PisApiInterface {
    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisAllEventsList(page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisAllEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {PolymorphicPiCommandRequest} [polymorphicPiCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisCommandsCreate(polymorphicPiCommandRequest?: PolymorphicPiCommandRequest, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisCommandsCreate(polymorphicPiCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all Raspberry Pi remote commands
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisCommandsList(page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisCommandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisEventsCommandsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisEventsCommandsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {PolymorphicPiEventRequest} [polymorphicPiEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisEventsCreate(polymorphicPiEventRequest?: PolymorphicPiEventRequest, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisEventsCreate(polymorphicPiEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisEventsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisEventsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all events inheriting from BasePiEvent
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisEventsRetrieve(id: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi, filtered by a single Pi
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisEventsStatusList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisEventsStatusList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi
     * @param {PolymorphicPiStatusRequest} [polymorphicPiStatusRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisStatusCreate(polymorphicPiStatusRequest?: PolymorphicPiStatusRequest, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisStatusCreate(polymorphicPiStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Interact with all status events for Raspberry Pi
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PisApi
     */
    public pisStatusList(page?: number, options?: AxiosRequestConfig) {
        return PisApiFp(this.configuration).pisStatusList(page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailCreate: async (emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert-settings/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert-settings/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailPartialUpdate: async (id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailPartialUpdate', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEmailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailRetrieve', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailUpdate: async (id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertSettingsEmailUpdate', 'id', id)
            const localVarPath = `/api/alert-settings/email/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailCreate(emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedEmailAlertSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailCreate(emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailList(page?: number, options?: any): AxiosPromise<PaginatedEmailAlertSettingsList> {
            return localVarFp.alertSettingsEmailList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailRetrieve(id: number, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this email alert settings.
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - interface
 * @export
 * @interface SettingsApi
 */
export interface SettingsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    alertSettingsEmailList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedEmailAlertSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI implements SettingsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public alertSettingsEmailCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).alertSettingsEmailCreate(emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public alertSettingsEmailList(page?: number, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).alertSettingsEmailList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public alertSettingsEmailPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).alertSettingsEmailPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public alertSettingsEmailRetrieve(id: number, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).alertSettingsEmailRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this email alert settings.
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public alertSettingsEmailUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).alertSettingsEmailUpdate(id, emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopApi - axios parameter creator
 * @export
 */
export const ShopApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCheckoutSuccessRetrieve: async (stripeCheckoutSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeCheckoutSessionId' is not null or undefined
            assertParamExists('shopCheckoutSuccessRetrieve', 'stripeCheckoutSessionId', stripeCheckoutSessionId)
            const localVarPath = `/api/shop/checkout/success/{stripe_checkout_session_id}`
                .replace(`{${"stripe_checkout_session_id"}}`, encodeURIComponent(String(stripeCheckoutSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate: async (orderCheckoutRequest: OrderCheckoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCheckoutRequest' is not null or undefined
            assertParamExists('shopOrdersCreate', 'orderCheckoutRequest', orderCheckoutRequest)
            const localVarPath = `/api/shop/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCheckoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shop/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopApi - functional programming interface
 * @export
 */
export const ShopApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCheckout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersCreate(orderCheckoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopApi - factory interface
 * @export
 */
export const ShopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopApiFp(configuration)
    return {
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: any): AxiosPromise<Order> {
            return localVarFp.shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: any): AxiosPromise<OrderCheckout> {
            return localVarFp.shopOrdersCreate(orderCheckoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList(page?: number, options?: any): AxiosPromise<PaginatedProductList> {
            return localVarFp.shopProductsList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopApi - interface
 * @export
 * @interface ShopApi
 */
export interface ShopApiInterface {
    /**
     * 
     * @param {string} stripeCheckoutSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * 
     * @param {OrderCheckoutRequest} orderCheckoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig): AxiosPromise<OrderCheckout>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopProductsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedProductList>;

}

/**
 * ShopApi - object-oriented interface
 * @export
 * @class ShopApi
 * @extends {BaseAPI}
 */
export class ShopApi extends BaseAPI implements ShopApiInterface {
    /**
     * 
     * @param {string} stripeCheckoutSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderCheckoutRequest} orderCheckoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersCreate(orderCheckoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsList(page?: number, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsList(page, options).then((request) => request(this.axios, this.basePath));
    }
}


