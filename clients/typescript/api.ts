/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    updated_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    user?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    dismissed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    time?: string;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface AlertBulkResponse
 */
export interface AlertBulkResponse {
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    received: number;
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    updated: number;
}
/**
 * 
 * @export
 * @interface AlertMethod
 */
export interface AlertMethod {
    /**
     * 
     * @type {string}
     * @memberof AlertMethod
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof AlertMethod
     */
    value: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AlertMethodsEnum {
    Ui = 'UI',
    Email = 'EMAIL',
    Discord = 'DISCORD'
}

/**
 * @type AlertPolymorphic
 * @export
 */
export type AlertPolymorphic = Alert | ManualVideoUploadAlert | PrintSessionAlert | ProgressAlert | RemoteControlCommandAlert;

/**
 * @type AlertPolymorphicRequest
 * @export
 */
export type AlertPolymorphicRequest = AlertRequest | ManualVideoUploadAlertRequest | PrintSessionAlertRequest | ProgressAlertRequest | RemoteControlCommandAlertRequest;

/**
 * 
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AlertRequest
     */
    dismissed?: boolean;
}
/**
 * 
 * @export
 * @interface AlertSettings
 */
export interface AlertSettings {
    /**
     * 
     * @type {number}
     * @memberof AlertSettings
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AlertSettings
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertSettings
     */
    updated_dt?: string;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof AlertSettings
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof AlertSettings
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof AlertSettings
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AlertSettings
     */
    polymorphic_ctype?: number;
}
/**
 * @type AlertSettingsPolymorphic
 * @export
 */
export type AlertSettingsPolymorphic = AlertSettings | CommandAlertSettings | ProgressAlertSettings;

/**
 * @type AlertSettingsPolymorphicRequest
 * @export
 */
export type AlertSettingsPolymorphicRequest = AlertSettingsRequest | CommandAlertSettingsRequest | ProgressAlertSettingsRequest;

/**
 * 
 * @export
 * @interface AlertSettingsRequest
 */
export interface AlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof AlertSettingsRequest
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof AlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof AlertSettingsRequest
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AlertTypeEnum {
    Command = 'COMMAND',
    PrintProgress = 'PRINT_PROGRESS',
    ManualVideoUpload = 'MANUAL_VIDEO_UPLOAD',
    PrintSession = 'PRINT_SESSION'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ArtifactTypesEnum {
    Tflite = 'TFLITE',
    Tf1 = 'TF1',
    Tf2SavedModel = 'TF2_SAVED_MODEL',
    Tf2Hdf5 = 'TF2_HDF5'
}

/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface CommandAlertSettings
 */
export interface CommandAlertSettings {
    /**
     * 
     * @type {number}
     * @memberof CommandAlertSettings
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandAlertSettings
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandAlertSettings
     */
    updated_dt?: string;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof CommandAlertSettings
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof CommandAlertSettings
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof CommandAlertSettings
     */
    enabled?: boolean;
    /**
     * Fires on web camera <strong>Snapshot</strong> command
     * @type {Array<SnapshotEnum>}
     * @memberof CommandAlertSettings
     */
    snapshot?: Array<SnapshotEnum>;
    /**
     * Fires on <strong>MonitoringStop<strong> updates.   Helps debug unexpected Print Nanny crashes.
     * @type {Array<MonitoringStopEnum>}
     * @memberof CommandAlertSettings
     */
    monitoring_stop?: Array<MonitoringStopEnum>;
    /**
     * Fires on <strong>MonitoringStop</strong> updates. Helpful if you want to confirm monitoring started without a problem.
     * @type {Array<MonitoringStartEnum>}
     * @memberof CommandAlertSettings
     */
    monitoring_start?: Array<MonitoringStartEnum>;
    /**
     * Fires on <strong>StopPrint</strong> updates. Get notified as soon as a print job finishes. 
     * @type {Array<PrintStartEnum>}
     * @memberof CommandAlertSettings
     */
    print_start?: Array<PrintStartEnum>;
    /**
     * Fires on <strong>PrintStart</strong> command status changes. Helpful for verifying a print job started without a problem.
     * @type {Array<PrintStopEnum>}
     * @memberof CommandAlertSettings
     */
    print_stop?: Array<PrintStopEnum>;
    /**
     * Fires on <strong>PausePrint</strong> command status changes. Helpful for verifying a print was paused successfully.
     * @type {Array<PrintPauseEnum>}
     * @memberof CommandAlertSettings
     */
    print_pause?: Array<PrintPauseEnum>;
    /**
     * Fires on <strong>ResumePrint</strong> command status changes Helpful for verifying a print was resumed.
     * @type {Array<PrintResumeEnum>}
     * @memberof CommandAlertSettings
     */
    print_resume?: Array<PrintResumeEnum>;
    /**
     * Fires on <strong>MoveNozzle</strong>command status changes. Helpful for debugging connectivity between Print Nanny and OctoPrint
     * @type {Array<MoveNozzleEnum>}
     * @memberof CommandAlertSettings
     */
    move_nozzle?: Array<MoveNozzleEnum>;
    /**
     * 
     * @type {number}
     * @memberof CommandAlertSettings
     */
    polymorphic_ctype?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandAlertSettings
     */
    user?: number;
}
/**
 * 
 * @export
 * @interface CommandAlertSettingsRequest
 */
export interface CommandAlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof CommandAlertSettingsRequest
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof CommandAlertSettingsRequest
     */
    enabled?: boolean;
    /**
     * Fires on web camera <strong>Snapshot</strong> command
     * @type {Array<SnapshotEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    snapshot?: Array<SnapshotEnum>;
    /**
     * Fires on <strong>MonitoringStop<strong> updates.   Helps debug unexpected Print Nanny crashes.
     * @type {Array<MonitoringStopEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    monitoring_stop?: Array<MonitoringStopEnum>;
    /**
     * Fires on <strong>MonitoringStop</strong> updates. Helpful if you want to confirm monitoring started without a problem.
     * @type {Array<MonitoringStartEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    monitoring_start?: Array<MonitoringStartEnum>;
    /**
     * Fires on <strong>StopPrint</strong> updates. Get notified as soon as a print job finishes. 
     * @type {Array<PrintStartEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    print_start?: Array<PrintStartEnum>;
    /**
     * Fires on <strong>PrintStart</strong> command status changes. Helpful for verifying a print job started without a problem.
     * @type {Array<PrintStopEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    print_stop?: Array<PrintStopEnum>;
    /**
     * Fires on <strong>PausePrint</strong> command status changes. Helpful for verifying a print was paused successfully.
     * @type {Array<PrintPauseEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    print_pause?: Array<PrintPauseEnum>;
    /**
     * Fires on <strong>ResumePrint</strong> command status changes Helpful for verifying a print was resumed.
     * @type {Array<PrintResumeEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    print_resume?: Array<PrintResumeEnum>;
    /**
     * Fires on <strong>MoveNozzle</strong>command status changes. Helpful for debugging connectivity between Print Nanny and OctoPrint
     * @type {Array<MoveNozzleEnum>}
     * @memberof CommandAlertSettingsRequest
     */
    move_nozzle?: Array<MoveNozzleEnum>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CommandEnum {
    MonitoringStop = 'monitoring_stop',
    MonitoringStart = 'monitoring_start',
    Snapshot = 'snapshot',
    PrintStart = 'print_start',
    PrintStop = 'print_stop',
    PrintPause = 'print_pause',
    PrintResume = 'print_resume',
    MoveNozzle = 'move_nozzle'
}

/**
 * 
 * @export
 * @interface CreatePrintSessionAlertRequest
 */
export interface CreatePrintSessionAlertRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePrintSessionAlertRequest
     */
    print_session: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePrintSessionAlertRequest
     */
    annotated_video: string;
}
/**
 * 
 * @export
 * @interface DeviceCalibration
 */
export interface DeviceCalibration {
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    updated_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibration
     */
    fpm?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DeviceCalibration
     */
    coordinates?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeviceCalibration
     */
    mask: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    config_file?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceCalibration
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface DeviceCalibrationRequest
 */
export interface DeviceCalibrationRequest {
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceCalibrationRequest
     */
    fpm?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DeviceCalibrationRequest
     */
    coordinates?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeviceCalibrationRequest
     */
    mask: Array<number>;
    /**
     * 
     * @type {any}
     * @memberof DeviceCalibrationRequest
     */
    config_file?: any | null;
}
/**
 * 
 * @export
 * @interface Experiment
 */
export interface Experiment {
    /**
     * 
     * @type {number}
     * @memberof Experiment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    created_dt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Experiment
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    hypothesis: string;
    /**
     * 
     * @type {Nested}
     * @memberof Experiment
     */
    control?: Nested;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof Experiment
     */
    treatments?: Array<Nested>;
    /**
     * 
     * @type {string}
     * @memberof Experiment
     */
    notion_url?: string | null;
}
/**
 * 
 * @export
 * @interface ExperimentDeviceConfig
 */
export interface ExperimentDeviceConfig {
    /**
     * 
     * @type {number}
     * @memberof ExperimentDeviceConfig
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExperimentDeviceConfig
     */
    created_dt?: string;
    /**
     * 
     * @type {Nested}
     * @memberof ExperimentDeviceConfig
     */
    experiment?: Nested;
    /**
     * 
     * @type {Nested}
     * @memberof ExperimentDeviceConfig
     */
    artifact?: Nested;
}
/**
 * 
 * @export
 * @interface GcodeFile
 */
export interface GcodeFile {
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    user?: number;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    file_hash: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    octoprint_device: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface GcodeFileRequest
 */
export interface GcodeFileRequest {
    /**
     * 
     * @type {string}
     * @memberof GcodeFileRequest
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof GcodeFileRequest
     */
    file: any;
    /**
     * 
     * @type {string}
     * @memberof GcodeFileRequest
     */
    file_hash: string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFileRequest
     */
    octoprint_device: string;
}
/**
 * 
 * @export
 * @interface ManualVideoUploadAlert
 */
export interface ManualVideoUploadAlert {
    /**
     * 
     * @type {string}
     * @memberof ManualVideoUploadAlert
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualVideoUploadAlert
     */
    updated_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof ManualVideoUploadAlert
     */
    user?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ManualVideoUploadAlert
     */
    dismissed?: boolean;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof ManualVideoUploadAlert
     */
    alert_type: AlertTypeEnum;
}
/**
 * 
 * @export
 * @interface ManualVideoUploadAlertRequest
 */
export interface ManualVideoUploadAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ManualVideoUploadAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof ManualVideoUploadAlertRequest
     */
    alert_type: AlertTypeEnum;
}
/**
 * 
 * @export
 * @interface ModelArtifact
 */
export interface ModelArtifact {
    /**
     * 
     * @type {number}
     * @memberof ModelArtifact
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    labels?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    artifacts?: string;
    /**
     * 
     * @type {Array<ArtifactTypesEnum>}
     * @memberof ModelArtifact
     */
    artifact_types?: Array<ArtifactTypesEnum>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelArtifact
     */
    metadata?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ModelArtifact
     */
    url?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MonitoringModeEnum {
    ActiveLearning = 'active_learning',
    Lite = 'lite'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MonitoringStartEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MonitoringStopEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum MoveNozzleEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    created_dt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Nested
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    hypothesis: string;
    /**
     * 
     * @type {string}
     * @memberof Nested
     */
    notion_url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Nested
     */
    control: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Nested
     */
    treatments?: Array<number>;
}
/**
 * 
 * @export
 * @interface OctoPrintDevice
 */
export interface OctoPrintDevice {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    last_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    public_key?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    fingerprint?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintDevice
     */
    cloudiot_device?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_name?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_path?: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_num_id?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDevice
     */
    cpu_flags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    hardware: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    revision: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDevice
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    virtualenv: string;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrintDevice
     */
    monitoring_active?: boolean;
    /**
     * 
     * @type {MonitoringModeEnum}
     * @memberof OctoPrintDevice
     */
    monitoring_mode?: MonitoringModeEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    cloudiot_device_configs?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDevice
     */
    manage_url?: string;
}
/**
 * 
 * @export
 * @interface OctoPrintDeviceKey
 */
export interface OctoPrintDeviceKey {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    last_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    public_key?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    fingerprint?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_name?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_path?: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_num_id?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDeviceKey
     */
    cpu_flags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    hardware: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    revision: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceKey
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    virtualenv: string;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrintDeviceKey
     */
    monitoring_active?: boolean;
    /**
     * 
     * @type {MonitoringModeEnum}
     * @memberof OctoPrintDeviceKey
     */
    monitoring_mode?: MonitoringModeEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    print_nanny_client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    private_key?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    private_key_checksum?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    public_key_checksum: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    cloudiot_device_configs?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OctoPrintDeviceKey
     */
    ca_certs: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceKey
     */
    manage_url?: string;
}
/**
 * 
 * @export
 * @interface OctoPrintDeviceRequest
 */
export interface OctoPrintDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceRequest
     */
    last_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    platform: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OctoPrintDeviceRequest
     */
    cpu_flags: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    hardware: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    revision: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    serial: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceRequest
     */
    cores: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintDeviceRequest
     */
    ram: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    python_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    pip_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    virtualenv: string;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrintDeviceRequest
     */
    monitoring_active?: boolean;
    /**
     * 
     * @type {MonitoringModeEnum}
     * @memberof OctoPrintDeviceRequest
     */
    monitoring_mode?: MonitoringModeEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    octoprint_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintDeviceRequest
     */
    print_nanny_client_version: string;
}
/**
 * 
 * @export
 * @interface OctoPrintEvent
 */
export interface OctoPrintEvent {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    created_dt?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    device: number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    user?: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {OctoPrintEventEventTypeEnum}
     * @memberof OctoPrintEvent
     */
    event_type: OctoPrintEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    print_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    url?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OctoPrintEventEventTypeEnum {
    ClientAuthed = 'ClientAuthed',
    ClientClosed = 'ClientClosed',
    ClientDeauthed = 'ClientDeauthed',
    ClientOpened = 'ClientOpened',
    SettingsUpdated = 'SettingsUpdated',
    UserLoggedIn = 'UserLoggedIn',
    UserLoggedOut = 'UserLoggedOut',
    FileAdded = 'FileAdded',
    FileRemoved = 'FileRemoved',
    FolderAdded = 'FolderAdded',
    FolderRemoved = 'FolderRemoved',
    TransferDone = 'TransferDone',
    TransferFailed = 'TransferFailed',
    TransferStarted = 'TransferStarted',
    UpdatedFiles = 'UpdatedFiles',
    Upload = 'Upload',
    CaptureDone = 'CaptureDone',
    CaptureFailed = 'CaptureFailed',
    CaptureStart = 'CaptureStart',
    MovieDone = 'MovieDone',
    MovieFailed = 'MovieFailed',
    MovieRendering = 'MovieRendering',
    PostRollEnd = 'PostRollEnd',
    PostRollStart = 'PostRollStart',
    SlicingCancelled = 'SlicingCancelled',
    SlicingDone = 'SlicingDone',
    SlicingFailed = 'SlicingFailed',
    SlicingProfileAdded = 'SlicingProfileAdded',
    SlicingProfileDeleted = 'SlicingProfileDeleted',
    SlicingProfileModified = 'SlicingProfileModified',
    SlicingStarted = 'SlicingStarted',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    PrinterReset = 'PrinterReset',
    PrinterStateChanged = 'PrinterStateChanged',
    FirmwareData = 'FirmwareData',
    PrinterProfileAdded = 'PrinterProfileAdded',
    PrinterProfileDeleted = 'PrinterProfileDeleted',
    PrinterProfileModified = 'PrinterProfileModified',
    PrintProgress = 'PrintProgress',
    PluginPiSupportThrottleState = 'plugin_pi_support_throttle_state',
    Shutdown = 'Shutdown',
    Startup = 'Startup'
}

/**
 * 
 * @export
 * @interface OctoPrintEventRequest
 */
export interface OctoPrintEventRequest {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    client_version: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEventRequest
     */
    octoprint_version: string;
    /**
     * 
     * @type {OctoPrintEventEventTypeEnum}
     * @memberof OctoPrintEventRequest
     */
    event_type: OctoPrintEventEventTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    print_session?: number | null;
}
/**
 * 
 * @export
 * @interface PaginatedAlertPolymorphicList
 */
export interface PaginatedAlertPolymorphicList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlertPolymorphicList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertPolymorphicList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertPolymorphicList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<AlertPolymorphic>}
     * @memberof PaginatedAlertPolymorphicList
     */
    results?: Array<AlertPolymorphic>;
}
/**
 * 
 * @export
 * @interface PaginatedAlertSettingsPolymorphicList
 */
export interface PaginatedAlertSettingsPolymorphicList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlertSettingsPolymorphicList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertSettingsPolymorphicList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertSettingsPolymorphicList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<AlertSettingsPolymorphic>}
     * @memberof PaginatedAlertSettingsPolymorphicList
     */
    results?: Array<AlertSettingsPolymorphic>;
}
/**
 * 
 * @export
 * @interface PaginatedDeviceCalibrationList
 */
export interface PaginatedDeviceCalibrationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeviceCalibrationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceCalibrationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceCalibrationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceCalibration>}
     * @memberof PaginatedDeviceCalibrationList
     */
    results?: Array<DeviceCalibration>;
}
/**
 * 
 * @export
 * @interface PaginatedExperimentDeviceConfigList
 */
export interface PaginatedExperimentDeviceConfigList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExperimentDeviceConfig>}
     * @memberof PaginatedExperimentDeviceConfigList
     */
    results?: Array<ExperimentDeviceConfig>;
}
/**
 * 
 * @export
 * @interface PaginatedExperimentList
 */
export interface PaginatedExperimentList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExperimentList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExperimentList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Experiment>}
     * @memberof PaginatedExperimentList
     */
    results?: Array<Experiment>;
}
/**
 * 
 * @export
 * @interface PaginatedGcodeFileList
 */
export interface PaginatedGcodeFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGcodeFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<GcodeFile>}
     * @memberof PaginatedGcodeFileList
     */
    results?: Array<GcodeFile>;
}
/**
 * 
 * @export
 * @interface PaginatedModelArtifactList
 */
export interface PaginatedModelArtifactList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedModelArtifactList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModelArtifactList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedModelArtifactList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ModelArtifact>}
     * @memberof PaginatedModelArtifactList
     */
    results?: Array<ModelArtifact>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintDeviceList
 */
export interface PaginatedOctoPrintDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintDeviceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintDeviceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintDeviceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<OctoPrintDevice>}
     * @memberof PaginatedOctoPrintDeviceList
     */
    results?: Array<OctoPrintDevice>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintEventList
 */
export interface PaginatedOctoPrintEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<OctoPrintEvent>}
     * @memberof PaginatedOctoPrintEventList
     */
    results?: Array<OctoPrintEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPluginEventList
 */
export interface PaginatedPluginEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPluginEventList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPluginEventList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPluginEventList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PluginEvent>}
     * @memberof PaginatedPluginEventList
     */
    results?: Array<PluginEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintSessionAlertList
 */
export interface PaginatedPrintSessionAlertList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintSessionAlertList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionAlertList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionAlertList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintSessionAlert>}
     * @memberof PaginatedPrintSessionAlertList
     */
    results?: Array<PrintSessionAlert>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintSessionList
 */
export interface PaginatedPrintSessionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintSessionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintSession>}
     * @memberof PaginatedPrintSessionList
     */
    results?: Array<PrintSession>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintSessionStateList
 */
export interface PaginatedPrintSessionStateList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintSessionStateList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionStateList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintSessionStateList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrintSessionState>}
     * @memberof PaginatedPrintSessionStateList
     */
    results?: Array<PrintSessionState>;
}
/**
 * 
 * @export
 * @interface PaginatedPrinterProfileList
 */
export interface PaginatedPrinterProfileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrinterProfileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrinterProfileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrinterProfileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PrinterProfile>}
     * @memberof PaginatedPrinterProfileList
     */
    results?: Array<PrinterProfile>;
}
/**
 * 
 * @export
 * @interface PaginatedRemoteControlCommandList
 */
export interface PaginatedRemoteControlCommandList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRemoteControlCommandList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlCommandList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlCommandList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RemoteControlCommand>}
     * @memberof PaginatedRemoteControlCommandList
     */
    results?: Array<RemoteControlCommand>;
}
/**
 * 
 * @export
 * @interface PaginatedRemoteControlSnapshotList
 */
export interface PaginatedRemoteControlSnapshotList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRemoteControlSnapshotList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlSnapshotList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRemoteControlSnapshotList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RemoteControlSnapshot>}
     * @memberof PaginatedRemoteControlSnapshotList
     */
    results?: Array<RemoteControlSnapshot>;
}
/**
 * 
 * @export
 * @interface PaginatedUserList
 */
export interface PaginatedUserList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof PaginatedUserList
     */
    results?: Array<User>;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface PatchedAlertBulkRequestRequest
 */
export interface PatchedAlertBulkRequestRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedAlertBulkRequestRequest
     */
    ids?: Array<number>;
}
/**
 * @type PatchedAlertPolymorphicRequest
 * @export
 */
export type PatchedAlertPolymorphicRequest = PatchedAlertRequest | PatchedManualVideoUploadAlertRequest | PatchedPrintSessionAlertRequest | PatchedProgressAlertRequest | PatchedRemoteControlCommandAlertRequest;

/**
 * 
 * @export
 * @interface PatchedAlertRequest
 */
export interface PatchedAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAlertRequest
     */
    dismissed?: boolean;
}
/**
 * @type PatchedAlertSettingsPolymorphicRequest
 * @export
 */
export type PatchedAlertSettingsPolymorphicRequest = PatchedAlertSettingsRequest | PatchedCommandAlertSettingsRequest | PatchedProgressAlertSettingsRequest;

/**
 * 
 * @export
 * @interface PatchedAlertSettingsRequest
 */
export interface PatchedAlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PatchedAlertSettingsRequest
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof PatchedAlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof PatchedAlertSettingsRequest
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedCommandAlertSettingsRequest
 */
export interface PatchedCommandAlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    enabled?: boolean;
    /**
     * Fires on web camera <strong>Snapshot</strong> command
     * @type {Array<SnapshotEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    snapshot?: Array<SnapshotEnum>;
    /**
     * Fires on <strong>MonitoringStop<strong> updates.   Helps debug unexpected Print Nanny crashes.
     * @type {Array<MonitoringStopEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    monitoring_stop?: Array<MonitoringStopEnum>;
    /**
     * Fires on <strong>MonitoringStop</strong> updates. Helpful if you want to confirm monitoring started without a problem.
     * @type {Array<MonitoringStartEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    monitoring_start?: Array<MonitoringStartEnum>;
    /**
     * Fires on <strong>StopPrint</strong> updates. Get notified as soon as a print job finishes. 
     * @type {Array<PrintStartEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    print_start?: Array<PrintStartEnum>;
    /**
     * Fires on <strong>PrintStart</strong> command status changes. Helpful for verifying a print job started without a problem.
     * @type {Array<PrintStopEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    print_stop?: Array<PrintStopEnum>;
    /**
     * Fires on <strong>PausePrint</strong> command status changes. Helpful for verifying a print was paused successfully.
     * @type {Array<PrintPauseEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    print_pause?: Array<PrintPauseEnum>;
    /**
     * Fires on <strong>ResumePrint</strong> command status changes Helpful for verifying a print was resumed.
     * @type {Array<PrintResumeEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    print_resume?: Array<PrintResumeEnum>;
    /**
     * Fires on <strong>MoveNozzle</strong>command status changes. Helpful for debugging connectivity between Print Nanny and OctoPrint
     * @type {Array<MoveNozzleEnum>}
     * @memberof PatchedCommandAlertSettingsRequest
     */
    move_nozzle?: Array<MoveNozzleEnum>;
}
/**
 * 
 * @export
 * @interface PatchedDeviceCalibrationRequest
 */
export interface PatchedDeviceCalibrationRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedDeviceCalibrationRequest
     */
    fpm?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedDeviceCalibrationRequest
     */
    coordinates?: { [key: string]: any; } | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedDeviceCalibrationRequest
     */
    mask?: Array<number>;
    /**
     * 
     * @type {any}
     * @memberof PatchedDeviceCalibrationRequest
     */
    config_file?: any | null;
}
/**
 * 
 * @export
 * @interface PatchedGcodeFileRequest
 */
export interface PatchedGcodeFileRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedGcodeFileRequest
     */
    name?: string;
    /**
     * 
     * @type {any}
     * @memberof PatchedGcodeFileRequest
     */
    file?: any;
    /**
     * 
     * @type {string}
     * @memberof PatchedGcodeFileRequest
     */
    file_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedGcodeFileRequest
     */
    octoprint_device?: string;
}
/**
 * 
 * @export
 * @interface PatchedManualVideoUploadAlertRequest
 */
export interface PatchedManualVideoUploadAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedManualVideoUploadAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PatchedManualVideoUploadAlertRequest
     */
    alert_type?: AlertTypeEnum;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintDeviceRequest
 */
export interface PatchedOctoPrintDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    last_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    platform?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    cpu_flags?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    hardware?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    serial?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    cores?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    ram?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    python_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    pip_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    virtualenv?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    monitoring_active?: boolean;
    /**
     * 
     * @type {MonitoringModeEnum}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    monitoring_mode?: MonitoringModeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    octoprint_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    plugin_version?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintDeviceRequest
     */
    print_nanny_client_version?: string;
}
/**
 * 
 * @export
 * @interface PatchedPrintSessionAlertRequest
 */
export interface PatchedPrintSessionAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrintSessionAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrintSessionAlertRequest
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrintSessionAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {PrintSessionAlertAlertSubtypeEnum}
     * @memberof PatchedPrintSessionAlertRequest
     */
    alert_subtype?: PrintSessionAlertAlertSubtypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PatchedPrintSessionAlertRequest
     */
    annotated_video?: any;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionAlertRequest
     */
    print_session?: number;
}
/**
 * 
 * @export
 * @interface PatchedPrintSessionRequest
 */
export interface PatchedPrintSessionRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrintSessionRequest
     */
    session?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedPrintSessionRequest
     */
    progress?: { [key: string]: any; };
    /**
     * 
     * @type {StatusEnum}
     * @memberof PatchedPrintSessionRequest
     */
    status?: StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintSessionRequest
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrintSessionRequest
     */
    gcode_filename?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedPrinterProfileRequest
 */
export interface PatchedPrinterProfileRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    octoprint_device?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPrinterProfileRequest
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    octoprint_key?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrinterProfileRequest
     */
    volume_width?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedProgressAlertRequest
 */
export interface PatchedProgressAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedProgressAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedProgressAlertRequest
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedProgressAlertRequest
     */
    dismissed?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof PatchedProgressAlertRequest
     */
    progress_percent?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedProgressAlertRequest
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedProgressAlertRequest
     */
    device?: number;
}
/**
 * 
 * @export
 * @interface PatchedProgressAlertSettingsRequest
 */
export interface PatchedProgressAlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PatchedProgressAlertSettingsRequest
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof PatchedProgressAlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof PatchedProgressAlertSettingsRequest
     */
    enabled?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof PatchedProgressAlertSettingsRequest
     */
    on_progress_percent?: number;
}
/**
 * 
 * @export
 * @interface PatchedRemoteControlCommandAlertRequest
 */
export interface PatchedRemoteControlCommandAlertRequest {
    /**
     * 
     * @type {RemoteControlCommandAlertAlertSubtypeEnum}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    alert_subtype?: RemoteControlCommandAlertAlertSubtypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    color?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedRemoteControlCommandAlertRequest
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface PatchedRemoteControlCommandRequest
 */
export interface PatchedRemoteControlCommandRequest {
    /**
     * 
     * @type {CommandEnum}
     * @memberof PatchedRemoteControlCommandRequest
     */
    command?: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedRemoteControlCommandRequest
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRemoteControlCommandRequest
     */
    device?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandRequest
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRemoteControlCommandRequest
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedRemoteControlCommandRequest
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedRemoteControlCommandRequest
     */
    metadata?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface PatchedRemoteControlSnapshotRequest
 */
export interface PatchedRemoteControlSnapshotRequest {
    /**
     * 
     * @type {any}
     * @memberof PatchedRemoteControlSnapshotRequest
     */
    image?: any;
    /**
     * 
     * @type {number}
     * @memberof PatchedRemoteControlSnapshotRequest
     */
    command?: number;
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface PluginEvent
 */
export interface PluginEvent {
    /**
     * 
     * @type {number}
     * @memberof PluginEvent
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PluginEvent
     */
    created_dt?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PluginEvent
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PluginEvent
     */
    device: number;
    /**
     * 
     * @type {number}
     * @memberof PluginEvent
     */
    user?: number;
    /**
     * 
     * @type {string}
     * @memberof PluginEvent
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof PluginEvent
     */
    client_version: string;
    /**
     * 
     * @type {string}
     * @memberof PluginEvent
     */
    octoprint_version: string;
    /**
     * 
     * @type {PluginEventEventTypeEnum}
     * @memberof PluginEvent
     */
    event_type: PluginEventEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PluginEvent
     */
    url?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PluginEventEventTypeEnum {
    DeviceRegisterStart = 'device_register_start',
    DeviceRegisterDone = 'device_register_done',
    DeviceRegisterFailed = 'device_register_failed',
    PrinterProfileSyncStart = 'printer_profile_sync_start',
    PrinterProfileSyncDone = 'printer_profile_sync_done',
    PrinterProfileSyncFailed = 'printer_profile_sync_failed'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintPauseEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintResumeEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @interface PrintSession
 */
export interface PrintSession {
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    updated_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    octoprint_device: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    session: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSession
     */
    progress?: { [key: string]: any; };
    /**
     * 
     * @type {StatusEnum}
     * @memberof PrintSession
     */
    status?: StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSession
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    gcode_filename?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSession
     */
    should_alert?: string;
}
/**
 * 
 * @export
 * @interface PrintSessionAlert
 */
export interface PrintSessionAlert {
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionAlert
     */
    time?: string;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof PrintSessionAlert
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof PrintSessionAlert
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionAlert
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionAlert
     */
    updated_dt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlert
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlert
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlert
     */
    dismissed?: boolean;
    /**
     * 
     * @type {PrintSessionAlertAlertSubtypeEnum}
     * @memberof PrintSessionAlert
     */
    alert_subtype?: PrintSessionAlertAlertSubtypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionAlert
     */
    annotated_video: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlert
     */
    polymorphic_ctype?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlert
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlert
     */
    octoprint_device?: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlert
     */
    print_session: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintSessionAlertAlertSubtypeEnum {
    Success = 'SUCCESS',
    Failure = 'FAILURE'
}

/**
 * 
 * @export
 * @interface PrintSessionAlertRequest
 */
export interface PrintSessionAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlertRequest
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PrintSessionAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {PrintSessionAlertAlertSubtypeEnum}
     * @memberof PrintSessionAlertRequest
     */
    alert_subtype?: PrintSessionAlertAlertSubtypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PrintSessionAlertRequest
     */
    annotated_video: any;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionAlertRequest
     */
    print_session: number;
}
/**
 * 
 * @export
 * @interface PrintSessionRequest
 */
export interface PrintSessionRequest {
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionRequest
     */
    session: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSessionRequest
     */
    progress?: { [key: string]: any; };
    /**
     * 
     * @type {StatusEnum}
     * @memberof PrintSessionRequest
     */
    status?: StatusEnum;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    printer_profile?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionRequest
     */
    gcode_file?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionRequest
     */
    gcode_filename?: string | null;
}
/**
 * 
 * @export
 * @interface PrintSessionState
 */
export interface PrintSessionState {
    /**
     * 
     * @type {number}
     * @memberof PrintSessionState
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    created_dt?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSessionState
     */
    event_data?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionState
     */
    device: number;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionState
     */
    user?: number;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    plugin_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    client_version: string;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    octoprint_version: string;
    /**
     * 
     * @type {PrintSessionStateEventTypeEnum}
     * @memberof PrintSessionState
     */
    event_type: PrintSessionStateEventTypeEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSessionState
     */
    state?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PrintSessionState
     */
    current_z?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintSessionState
     */
    progress?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    job_data_file: string;
    /**
     * 
     * @type {number}
     * @memberof PrintSessionState
     */
    print_session?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrintSessionState
     */
    url?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintSessionStateEventTypeEnum {
    Error = 'Error',
    PrintCancelled = 'PrintCancelled',
    PrintCancelling = 'PrintCancelling',
    PrintDone = 'PrintDone',
    PrintFailed = 'PrintFailed',
    PrintPaused = 'PrintPaused',
    PrintResumed = 'PrintResumed',
    PrintStarted = 'PrintStarted'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintStartEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PrintStopEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @interface PrinterProfile
 */
export interface PrinterProfile {
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfile
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    octoprint_key: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterProfile
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfile
     */
    volume_width?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfile
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface PrinterProfileRequest
 */
export interface PrinterProfileRequest {
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    octoprint_device: number;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_e_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_e_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_x_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_x_inverted?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_y_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_y_speed?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    axes_z_inverted?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    axes_z_speed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    extruder_count?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    extruder_nozzle_diameter?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    extruder_shared_nozzle?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    heated_bed?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PrinterProfileRequest
     */
    heated_chamber?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    model?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    octoprint_key: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrinterProfileRequest
     */
    volume_custom_box?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    volume_formfactor?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PrinterProfileRequest
     */
    volume_origin?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PrinterProfileRequest
     */
    volume_width?: number | null;
}
/**
 * 
 * @export
 * @interface ProgressAlert
 */
export interface ProgressAlert {
    /**
     * 
     * @type {number}
     * @memberof ProgressAlert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProgressAlert
     */
    time?: string;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof ProgressAlert
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof ProgressAlert
     */
    alert_type?: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProgressAlert
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgressAlert
     */
    updated_dt?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlert
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlert
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlert
     */
    dismissed?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof ProgressAlert
     */
    progress_percent?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlert
     */
    polymorphic_ctype?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlert
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlert
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlert
     */
    device: number;
}
/**
 * 
 * @export
 * @interface ProgressAlertRequest
 */
export interface ProgressAlertRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlertRequest
     */
    sent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProgressAlertRequest
     */
    dismissed?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof ProgressAlertRequest
     */
    progress_percent?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlertRequest
     */
    octoprint_device?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlertRequest
     */
    device: number;
}
/**
 * 
 * @export
 * @interface ProgressAlertSettings
 */
export interface ProgressAlertSettings {
    /**
     * 
     * @type {number}
     * @memberof ProgressAlertSettings
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProgressAlertSettings
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgressAlertSettings
     */
    updated_dt?: string;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof ProgressAlertSettings
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof ProgressAlertSettings
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof ProgressAlertSettings
     */
    enabled?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof ProgressAlertSettings
     */
    on_progress_percent?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlertSettings
     */
    polymorphic_ctype?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgressAlertSettings
     */
    user?: number;
}
/**
 * 
 * @export
 * @interface ProgressAlertSettingsRequest
 */
export interface ProgressAlertSettingsRequest {
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof ProgressAlertSettingsRequest
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof ProgressAlertSettingsRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * Enable or disable this alert channel
     * @type {boolean}
     * @memberof ProgressAlertSettingsRequest
     */
    enabled?: boolean;
    /**
     * Progress notification interval. Example: 25 will notify you at 25%, 50%, 75%, and 100% progress
     * @type {number}
     * @memberof ProgressAlertSettingsRequest
     */
    on_progress_percent?: number;
}
/**
 * 
 * @export
 * @interface RemoteControlCommand
 */
export interface RemoteControlCommand {
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    created_dt?: string;
    /**
     * 
     * @type {CommandEnum}
     * @memberof RemoteControlCommand
     */
    command: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommand
     */
    device: number;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommand
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommand
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommand
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommand
     */
    metadata?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommand
     */
    octoprint_event_type?: string;
}
/**
 * 
 * @export
 * @interface RemoteControlCommandAlert
 */
export interface RemoteControlCommandAlert {
    /**
     * 
     * @type {RemoteControlCommandAlertAlertSubtypeEnum}
     * @memberof RemoteControlCommandAlert
     */
    alert_subtype: RemoteControlCommandAlertAlertSubtypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof RemoteControlCommandAlert
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof RemoteControlCommandAlert
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    dashboard_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandAlert
     */
    dismissed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    metadata?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    icon: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandAlert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandAlert
     */
    seen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    snapshot_url?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlert
     */
    updated_dt?: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandAlert
     */
    user?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RemoteControlCommandAlertAlertSubtypeEnum {
    Received = 'RECEIVED',
    Success = 'SUCCESS',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface RemoteControlCommandAlertRequest
 */
export interface RemoteControlCommandAlertRequest {
    /**
     * 
     * @type {RemoteControlCommandAlertAlertSubtypeEnum}
     * @memberof RemoteControlCommandAlertRequest
     */
    alert_subtype: RemoteControlCommandAlertAlertSubtypeEnum;
    /**
     * 
     * @type {Array<AlertMethodsEnum>}
     * @memberof RemoteControlCommandAlertRequest
     */
    alert_methods?: Array<AlertMethodsEnum>;
    /**
     * 
     * @type {AlertTypeEnum}
     * @memberof RemoteControlCommandAlertRequest
     */
    alert_type: AlertTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlertRequest
     */
    color: string;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandAlertRequest
     */
    dismissed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlertRequest
     */
    icon: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlertRequest
     */
    description: string;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandAlertRequest
     */
    seen?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlCommandAlertRequest
     */
    title: string;
}
/**
 * 
 * @export
 * @interface RemoteControlCommandRequest
 */
export interface RemoteControlCommandRequest {
    /**
     * 
     * @type {CommandEnum}
     * @memberof RemoteControlCommandRequest
     */
    command: CommandEnum;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandRequest
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlCommandRequest
     */
    device: number;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandRequest
     */
    received?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteControlCommandRequest
     */
    success?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommandRequest
     */
    iotcore_response?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RemoteControlCommandRequest
     */
    metadata?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RemoteControlSnapshot
 */
export interface RemoteControlSnapshot {
    /**
     * 
     * @type {number}
     * @memberof RemoteControlSnapshot
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlSnapshot
     */
    created_dt?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlSnapshot
     */
    image: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlSnapshot
     */
    command: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlSnapshot
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface RemoteControlSnapshotCreateResponse
 */
export interface RemoteControlSnapshotCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof RemoteControlSnapshotCreateResponse
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlSnapshotCreateResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RemoteControlSnapshotCreateResponse
     */
    created_dt?: string;
}
/**
 * 
 * @export
 * @interface RemoteControlSnapshotRequest
 */
export interface RemoteControlSnapshotRequest {
    /**
     * 
     * @type {any}
     * @memberof RemoteControlSnapshotRequest
     */
    image: any;
    /**
     * 
     * @type {number}
     * @memberof RemoteControlSnapshotRequest
     */
    command: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SnapshotEnum {
    Received = 'RECEIVED',
    Failed = 'FAILED',
    Success = 'SUCCESS'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum StatusEnum {
    MonitoringActive = 'monitoring_active',
    RenderingVideo = 'rendering_video',
    DoneATimelapseOfYourPrintJobIsReady = 'doneA timelapse of your print job is ready!'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    email: string;
}

/**
 * AlertSettingsApi - axios parameter creator
 * @export
 */
export const AlertSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert_settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsMethodsRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alert_settings/methods/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {PatchedAlertSettingsPolymorphicRequest} [patchedAlertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsPartialUpdate: async (id: number, patchedAlertSettingsPolymorphicRequest?: PatchedAlertSettingsPolymorphicRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertSettingsPartialUpdate.');
            }
            const localVarPath = `/api/alert_settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedAlertSettingsPolymorphicRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedAlertSettingsPolymorphicRequest !== undefined ? patchedAlertSettingsPolymorphicRequest : {})
                : (patchedAlertSettingsPolymorphicRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertSettingsRetrieve.');
            }
            const localVarPath = `/api/alert_settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {AlertSettingsPolymorphicRequest} [alertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsUpdate: async (id: number, alertSettingsPolymorphicRequest?: AlertSettingsPolymorphicRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertSettingsUpdate.');
            }
            const localVarPath = `/api/alert_settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof alertSettingsPolymorphicRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(alertSettingsPolymorphicRequest !== undefined ? alertSettingsPolymorphicRequest : {})
                : (alertSettingsPolymorphicRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertSettingsApi - functional programming interface
 * @export
 */
export const AlertSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAlertSettingsPolymorphicList>> {
            const localVarAxiosArgs = await AlertSettingsApiAxiosParamCreator(configuration).alertSettingsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsMethodsRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertMethod>> {
            const localVarAxiosArgs = await AlertSettingsApiAxiosParamCreator(configuration).alertSettingsMethodsRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {PatchedAlertSettingsPolymorphicRequest} [patchedAlertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsPartialUpdate(id: number, patchedAlertSettingsPolymorphicRequest?: PatchedAlertSettingsPolymorphicRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertSettingsPolymorphic>> {
            const localVarAxiosArgs = await AlertSettingsApiAxiosParamCreator(configuration).alertSettingsPartialUpdate(id, patchedAlertSettingsPolymorphicRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertSettingsPolymorphic>> {
            const localVarAxiosArgs = await AlertSettingsApiAxiosParamCreator(configuration).alertSettingsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {AlertSettingsPolymorphicRequest} [alertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertSettingsUpdate(id: number, alertSettingsPolymorphicRequest?: AlertSettingsPolymorphicRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertSettingsPolymorphic>> {
            const localVarAxiosArgs = await AlertSettingsApiAxiosParamCreator(configuration).alertSettingsUpdate(id, alertSettingsPolymorphicRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlertSettingsApi - factory interface
 * @export
 */
export const AlertSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsList(page?: number, options?: any): AxiosPromise<PaginatedAlertSettingsPolymorphicList> {
            return AlertSettingsApiFp(configuration).alertSettingsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsMethodsRetrieve(options?: any): AxiosPromise<AlertMethod> {
            return AlertSettingsApiFp(configuration).alertSettingsMethodsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {PatchedAlertSettingsPolymorphicRequest} [patchedAlertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsPartialUpdate(id: number, patchedAlertSettingsPolymorphicRequest?: PatchedAlertSettingsPolymorphicRequest, options?: any): AxiosPromise<AlertSettingsPolymorphic> {
            return AlertSettingsApiFp(configuration).alertSettingsPartialUpdate(id, patchedAlertSettingsPolymorphicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsRetrieve(id: number, options?: any): AxiosPromise<AlertSettingsPolymorphic> {
            return AlertSettingsApiFp(configuration).alertSettingsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert settings.
         * @param {AlertSettingsPolymorphicRequest} [alertSettingsPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertSettingsUpdate(id: number, alertSettingsPolymorphicRequest?: AlertSettingsPolymorphicRequest, options?: any): AxiosPromise<AlertSettingsPolymorphic> {
            return AlertSettingsApiFp(configuration).alertSettingsUpdate(id, alertSettingsPolymorphicRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertSettingsApi - interface
 * @export
 * @interface AlertSettingsApi
 */
export interface AlertSettingsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApiInterface
     */
    alertSettingsList(page?: number, options?: any): AxiosPromise<PaginatedAlertSettingsPolymorphicList>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApiInterface
     */
    alertSettingsMethodsRetrieve(options?: any): AxiosPromise<AlertMethod>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {PatchedAlertSettingsPolymorphicRequest} [patchedAlertSettingsPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApiInterface
     */
    alertSettingsPartialUpdate(id: number, patchedAlertSettingsPolymorphicRequest?: PatchedAlertSettingsPolymorphicRequest, options?: any): AxiosPromise<AlertSettingsPolymorphic>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApiInterface
     */
    alertSettingsRetrieve(id: number, options?: any): AxiosPromise<AlertSettingsPolymorphic>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {AlertSettingsPolymorphicRequest} [alertSettingsPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApiInterface
     */
    alertSettingsUpdate(id: number, alertSettingsPolymorphicRequest?: AlertSettingsPolymorphicRequest, options?: any): AxiosPromise<AlertSettingsPolymorphic>;

}

/**
 * AlertSettingsApi - object-oriented interface
 * @export
 * @class AlertSettingsApi
 * @extends {BaseAPI}
 */
export class AlertSettingsApi extends BaseAPI implements AlertSettingsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApi
     */
    public alertSettingsList(page?: number, options?: any) {
        return AlertSettingsApiFp(this.configuration).alertSettingsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApi
     */
    public alertSettingsMethodsRetrieve(options?: any) {
        return AlertSettingsApiFp(this.configuration).alertSettingsMethodsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {PatchedAlertSettingsPolymorphicRequest} [patchedAlertSettingsPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApi
     */
    public alertSettingsPartialUpdate(id: number, patchedAlertSettingsPolymorphicRequest?: PatchedAlertSettingsPolymorphicRequest, options?: any) {
        return AlertSettingsApiFp(this.configuration).alertSettingsPartialUpdate(id, patchedAlertSettingsPolymorphicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApi
     */
    public alertSettingsRetrieve(id: number, options?: any) {
        return AlertSettingsApiFp(this.configuration).alertSettingsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert settings.
     * @param {AlertSettingsPolymorphicRequest} [alertSettingsPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertSettingsApi
     */
    public alertSettingsUpdate(id: number, alertSettingsPolymorphicRequest?: AlertSettingsPolymorphicRequest, options?: any) {
        return AlertSettingsApiFp(this.configuration).alertSettingsUpdate(id, alertSettingsPolymorphicRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsDismiss: async (patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/dismiss/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedAlertBulkRequestRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedAlertBulkRequestRequest !== undefined ? patchedAlertBulkRequestRequest : {})
                : (patchedAlertBulkRequestRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {PatchedAlertPolymorphicRequest} [patchedAlertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPartialUpdate: async (id: number, patchedAlertPolymorphicRequest?: PatchedAlertPolymorphicRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertsPartialUpdate.');
            }
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedAlertPolymorphicRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedAlertPolymorphicRequest !== undefined ? patchedAlertPolymorphicRequest : {})
                : (patchedAlertPolymorphicRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecentRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/recent/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertsRetrieve.');
            }
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen: async (patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/seen/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedAlertBulkRequestRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedAlertBulkRequestRequest !== undefined ? patchedAlertBulkRequestRequest : {})
                : (patchedAlertBulkRequestRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnreadRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/unread/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {AlertPolymorphicRequest} [alertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUpdate: async (id: number, alertPolymorphicRequest?: AlertPolymorphicRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling alertsUpdate.');
            }
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof alertPolymorphicRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(alertPolymorphicRequest !== undefined ? alertPolymorphicRequest : {})
                : (alertPolymorphicRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePrintSessionAlertRequest} createPrintSessionAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertCreate: async (createPrintSessionAlertRequest: CreatePrintSessionAlertRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPrintSessionAlertRequest' is not null or undefined
            if (createPrintSessionAlertRequest === null || createPrintSessionAlertRequest === undefined) {
                throw new RequiredError('createPrintSessionAlertRequest','Required parameter createPrintSessionAlertRequest was null or undefined when calling printSessionAlertCreate.');
            }
            const localVarPath = `/api/print-session-alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createPrintSessionAlertRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createPrintSessionAlertRequest !== undefined ? createPrintSessionAlertRequest : {})
                : (createPrintSessionAlertRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-session-alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertsRetrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling printSessionAlertsRetrieve.');
            }
            const localVarPath = `/api/print-session-alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsDismiss(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsDismiss(patchedAlertBulkRequestRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAlertPolymorphicList>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {PatchedAlertPolymorphicRequest} [patchedAlertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPartialUpdate(id: number, patchedAlertPolymorphicRequest?: PatchedAlertPolymorphicRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPolymorphic>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsPartialUpdate(id, patchedAlertPolymorphicRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsRecentRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPolymorphic>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsRecentRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPolymorphic>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsSeen(patchedAlertBulkRequestRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsUnreadRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPolymorphic>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsUnreadRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {AlertPolymorphicRequest} [alertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsUpdate(id: number, alertPolymorphicRequest?: AlertPolymorphicRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertPolymorphic>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).alertsUpdate(id, alertPolymorphicRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreatePrintSessionAlertRequest} createPrintSessionAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionAlertCreate(createPrintSessionAlertRequest: CreatePrintSessionAlertRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSessionAlert>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).printSessionAlertCreate(createPrintSessionAlertRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionAlertsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintSessionAlertList>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).printSessionAlertsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionAlertsRetrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSessionAlert>> {
            const localVarAxiosArgs = await AlertsApiAxiosParamCreator(configuration).printSessionAlertsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsDismiss(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse> {
            return AlertsApiFp(configuration).alertsDismiss(patchedAlertBulkRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList(page?: number, options?: any): AxiosPromise<PaginatedAlertPolymorphicList> {
            return AlertsApiFp(configuration).alertsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {PatchedAlertPolymorphicRequest} [patchedAlertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPartialUpdate(id: number, patchedAlertPolymorphicRequest?: PatchedAlertPolymorphicRequest, options?: any): AxiosPromise<AlertPolymorphic> {
            return AlertsApiFp(configuration).alertsPartialUpdate(id, patchedAlertPolymorphicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecentRetrieve(options?: any): AxiosPromise<AlertPolymorphic> {
            return AlertsApiFp(configuration).alertsRecentRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRetrieve(id: number, options?: any): AxiosPromise<AlertPolymorphic> {
            return AlertsApiFp(configuration).alertsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse> {
            return AlertsApiFp(configuration).alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnreadRetrieve(options?: any): AxiosPromise<AlertPolymorphic> {
            return AlertsApiFp(configuration).alertsUnreadRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert.
         * @param {AlertPolymorphicRequest} [alertPolymorphicRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUpdate(id: number, alertPolymorphicRequest?: AlertPolymorphicRequest, options?: any): AxiosPromise<AlertPolymorphic> {
            return AlertsApiFp(configuration).alertsUpdate(id, alertPolymorphicRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePrintSessionAlertRequest} createPrintSessionAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertCreate(createPrintSessionAlertRequest: CreatePrintSessionAlertRequest, options?: any): AxiosPromise<PrintSessionAlert> {
            return AlertsApiFp(configuration).printSessionAlertCreate(createPrintSessionAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionAlertList> {
            return AlertsApiFp(configuration).printSessionAlertsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionAlertsRetrieve(id: string, options?: any): AxiosPromise<PrintSessionAlert> {
            return AlertsApiFp(configuration).printSessionAlertsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - interface
 * @export
 * @interface AlertsApi
 */
export interface AlertsApiInterface {
    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsDismiss(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsList(page?: number, options?: any): AxiosPromise<PaginatedAlertPolymorphicList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {PatchedAlertPolymorphicRequest} [patchedAlertPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPartialUpdate(id: number, patchedAlertPolymorphicRequest?: PatchedAlertPolymorphicRequest, options?: any): AxiosPromise<AlertPolymorphic>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsRecentRetrieve(options?: any): AxiosPromise<AlertPolymorphic>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsRetrieve(id: number, options?: any): AxiosPromise<AlertPolymorphic>;

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsUnreadRetrieve(options?: any): AxiosPromise<AlertPolymorphic>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {AlertPolymorphicRequest} [alertPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsUpdate(id: number, alertPolymorphicRequest?: AlertPolymorphicRequest, options?: any): AxiosPromise<AlertPolymorphic>;

    /**
     * 
     * @param {CreatePrintSessionAlertRequest} createPrintSessionAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    printSessionAlertCreate(createPrintSessionAlertRequest: CreatePrintSessionAlertRequest, options?: any): AxiosPromise<PrintSessionAlert>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    printSessionAlertsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionAlertList>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    printSessionAlertsRetrieve(id: string, options?: any): AxiosPromise<PrintSessionAlert>;

}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI implements AlertsApiInterface {
    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsDismiss(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any) {
        return AlertsApiFp(this.configuration).alertsDismiss(patchedAlertBulkRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsList(page?: number, options?: any) {
        return AlertsApiFp(this.configuration).alertsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {PatchedAlertPolymorphicRequest} [patchedAlertPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPartialUpdate(id: number, patchedAlertPolymorphicRequest?: PatchedAlertPolymorphicRequest, options?: any) {
        return AlertsApiFp(this.configuration).alertsPartialUpdate(id, patchedAlertPolymorphicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsRecentRetrieve(options?: any) {
        return AlertsApiFp(this.configuration).alertsRecentRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsRetrieve(id: number, options?: any) {
        return AlertsApiFp(this.configuration).alertsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any) {
        return AlertsApiFp(this.configuration).alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsUnreadRetrieve(options?: any) {
        return AlertsApiFp(this.configuration).alertsUnreadRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert.
     * @param {AlertPolymorphicRequest} [alertPolymorphicRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsUpdate(id: number, alertPolymorphicRequest?: AlertPolymorphicRequest, options?: any) {
        return AlertsApiFp(this.configuration).alertsUpdate(id, alertPolymorphicRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreatePrintSessionAlertRequest} createPrintSessionAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public printSessionAlertCreate(createPrintSessionAlertRequest: CreatePrintSessionAlertRequest, options?: any) {
        return AlertsApiFp(this.configuration).printSessionAlertCreate(createPrintSessionAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public printSessionAlertsList(page?: number, options?: any) {
        return AlertsApiFp(this.configuration).printSessionAlertsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public printSessionAlertsRetrieve(id: string, options?: any) {
        return AlertsApiFp(this.configuration).printSessionAlertsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthTokenApi - axios parameter creator
 * @export
 */
export const AuthTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling authTokenCreate.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling authTokenCreate.');
            }
            const localVarPath = `/api/auth-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthTokenApi - functional programming interface
 * @export
 */
export const AuthTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await AuthTokenApiAxiosParamCreator(configuration).authTokenCreate(username, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthTokenApi - factory interface
 * @export
 */
export const AuthTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(username: string, password: string, options?: any): AxiosPromise<AuthToken> {
            return AuthTokenApiFp(configuration).authTokenCreate(username, password, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthTokenApi - interface
 * @export
 * @interface AuthTokenApi
 */
export interface AuthTokenApiInterface {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthTokenApiInterface
     */
    authTokenCreate(username: string, password: string, options?: any): AxiosPromise<AuthToken>;

}

/**
 * AuthTokenApi - object-oriented interface
 * @export
 * @class AuthTokenApi
 * @extends {BaseAPI}
 */
export class AuthTokenApi extends BaseAPI implements AuthTokenApiInterface {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthTokenApi
     */
    public authTokenCreate(username: string, password: string, options?: any) {
        return AuthTokenApiFp(this.configuration).authTokenCreate(username, password, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCoreEventsEnumRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint-events/enum/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate: async (octoPrintEventRequest: OctoPrintEventRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintEventRequest' is not null or undefined
            if (octoPrintEventRequest === null || octoPrintEventRequest === undefined) {
                throw new RequiredError('octoPrintEventRequest','Required parameter octoPrintEventRequest was null or undefined when calling octoprintEventsCreate.');
            }
            const localVarPath = `/api/octoprint-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof octoPrintEventRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(octoPrintEventRequest !== undefined ? octoPrintEventRequest : {})
                : (octoPrintEventRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling octoprintEventsRetrieve.');
            }
            const localVarPath = `/api/octoprint-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsEnumRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plugin-events/enum/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/plugin-events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pluginEventsRetrieve.');
            }
            const localVarPath = `/api/plugin-events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printJobStatesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-job-states/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print session state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printJobStatesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling printJobStatesRetrieve.');
            }
            const localVarPath = `/api/print-job-states/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionEventEnumRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-job-states/enum/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintCoreEventsEnumRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).octoprintCoreEventsEnumRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).octoprintEventsCreate(octoPrintEventRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintEventList>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).octoprintEventsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).octoprintEventsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginEventsEnumRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).pluginEventsEnumRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginEventsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPluginEventList>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).pluginEventsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pluginEventsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).pluginEventsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printJobStatesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintSessionStateList>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).printJobStatesList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print session state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printJobStatesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSessionState>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).printJobStatesRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionEventEnumRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).printSessionEventEnumRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCoreEventsEnumRetrieve(options?: any): AxiosPromise<string> {
            return EventsApiFp(configuration).octoprintCoreEventsEnumRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintEventRequest} octoPrintEventRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): AxiosPromise<OctoPrintEvent> {
            return EventsApiFp(configuration).octoprintEventsCreate(octoPrintEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintEventList> {
            return EventsApiFp(configuration).octoprintEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintEventsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintEvent> {
            return EventsApiFp(configuration).octoprintEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsEnumRetrieve(options?: any): AxiosPromise<string> {
            return EventsApiFp(configuration).pluginEventsEnumRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsList(page?: number, options?: any): AxiosPromise<PaginatedPluginEventList> {
            return EventsApiFp(configuration).pluginEventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this plugin event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pluginEventsRetrieve(id: number, options?: any): AxiosPromise<PluginEvent> {
            return EventsApiFp(configuration).pluginEventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printJobStatesList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionStateList> {
            return EventsApiFp(configuration).printJobStatesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this print session state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printJobStatesRetrieve(id: number, options?: any): AxiosPromise<PrintSessionState> {
            return EventsApiFp(configuration).printJobStatesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionEventEnumRetrieve(options?: any): AxiosPromise<string> {
            return EventsApiFp(configuration).printSessionEventEnumRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintCoreEventsEnumRetrieve(options?: any): AxiosPromise<string>;

    /**
     * 
     * @param {OctoPrintEventRequest} octoPrintEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any): AxiosPromise<OctoPrintEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    octoprintEventsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintEvent>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pluginEventsEnumRetrieve(options?: any): AxiosPromise<string>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pluginEventsList(page?: number, options?: any): AxiosPromise<PaginatedPluginEventList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this plugin event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    pluginEventsRetrieve(id: number, options?: any): AxiosPromise<PluginEvent>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    printJobStatesList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionStateList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this print session state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    printJobStatesRetrieve(id: number, options?: any): AxiosPromise<PrintSessionState>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    printSessionEventEnumRetrieve(options?: any): AxiosPromise<string>;

}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintCoreEventsEnumRetrieve(options?: any) {
        return EventsApiFp(this.configuration).octoprintCoreEventsEnumRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintEventRequest} octoPrintEventRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsCreate(octoPrintEventRequest: OctoPrintEventRequest, options?: any) {
        return EventsApiFp(this.configuration).octoprintEventsCreate(octoPrintEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsList(page?: number, options?: any) {
        return EventsApiFp(this.configuration).octoprintEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public octoprintEventsRetrieve(id: number, options?: any) {
        return EventsApiFp(this.configuration).octoprintEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pluginEventsEnumRetrieve(options?: any) {
        return EventsApiFp(this.configuration).pluginEventsEnumRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pluginEventsList(page?: number, options?: any) {
        return EventsApiFp(this.configuration).pluginEventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this plugin event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public pluginEventsRetrieve(id: number, options?: any) {
        return EventsApiFp(this.configuration).pluginEventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public printJobStatesList(page?: number, options?: any) {
        return EventsApiFp(this.configuration).printJobStatesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this print session state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public printJobStatesRetrieve(id: number, options?: any) {
        return EventsApiFp(this.configuration).printJobStatesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public printSessionEventEnumRetrieve(options?: any) {
        return EventsApiFp(this.configuration).printSessionEventEnumRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MlOpsApi - axios parameter creator
 * @export
 */
export const MlOpsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationUpdateOrCreate: async (deviceCalibrationRequest: DeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceCalibrationRequest' is not null or undefined
            if (deviceCalibrationRequest === null || deviceCalibrationRequest === undefined) {
                throw new RequiredError('deviceCalibrationRequest','Required parameter deviceCalibrationRequest was null or undefined when calling deviceCalibrationUpdateOrCreate.');
            }
            const localVarPath = `/api/device-calibrations/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof deviceCalibrationRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(deviceCalibrationRequest !== undefined ? deviceCalibrationRequest : {})
                : (deviceCalibrationRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/device-calibrations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsPartialUpdate: async (id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceCalibrationsPartialUpdate.');
            }
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedDeviceCalibrationRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedDeviceCalibrationRequest !== undefined ? patchedDeviceCalibrationRequest : {})
                : (patchedDeviceCalibrationRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceCalibrationsRetrieve.');
            }
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsUpdate: async (id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deviceCalibrationsUpdate.');
            }
            // verify required parameter 'deviceCalibrationRequest' is not null or undefined
            if (deviceCalibrationRequest === null || deviceCalibrationRequest === undefined) {
                throw new RequiredError('deviceCalibrationRequest','Required parameter deviceCalibrationRequest was null or undefined when calling deviceCalibrationsUpdate.');
            }
            const localVarPath = `/api/device-calibrations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof deviceCalibrationRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(deviceCalibrationRequest !== undefined ? deviceCalibrationRequest : {})
                : (deviceCalibrationRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentDeviceConfigsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/experiment-device-configs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentDeviceConfigsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling experimentDeviceConfigsRetrieve.');
            }
            const localVarPath = `/api/experiment-device-configs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/experiments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling experimentsRetrieve.');
            }
            const localVarPath = `/api/experiments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelArtifactsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/model-artifacts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelArtifactsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modelArtifactsRetrieve.');
            }
            const localVarPath = `/api/model-artifacts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlOpsApi - functional programming interface
 * @export
 */
export const MlOpsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeviceCalibrationList>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).deviceCalibrationsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).deviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).deviceCalibrationsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCalibration>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).deviceCalibrationsUpdate(id, deviceCalibrationRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentDeviceConfigsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExperimentDeviceConfigList>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).experimentDeviceConfigsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentDeviceConfigsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExperimentDeviceConfig>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).experimentDeviceConfigsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExperimentList>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).experimentsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async experimentsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Experiment>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).experimentsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelArtifactsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedModelArtifactList>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).modelArtifactsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelArtifactsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelArtifact>> {
            const localVarAxiosArgs = await MlOpsApiAxiosParamCreator(configuration).modelArtifactsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MlOpsApi - factory interface
 * @export
 */
export const MlOpsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return MlOpsApiFp(configuration).deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsList(page?: number, options?: any): AxiosPromise<PaginatedDeviceCalibrationList> {
            return MlOpsApiFp(configuration).deviceCalibrationsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return MlOpsApiFp(configuration).deviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsRetrieve(id: number, options?: any): AxiosPromise<DeviceCalibration> {
            return MlOpsApiFp(configuration).deviceCalibrationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device calibration.
         * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration> {
            return MlOpsApiFp(configuration).deviceCalibrationsUpdate(id, deviceCalibrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentDeviceConfigsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentDeviceConfigList> {
            return MlOpsApiFp(configuration).experimentDeviceConfigsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment device config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentDeviceConfigsRetrieve(id: number, options?: any): AxiosPromise<ExperimentDeviceConfig> {
            return MlOpsApiFp(configuration).experimentDeviceConfigsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentList> {
            return MlOpsApiFp(configuration).experimentsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this experiment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        experimentsRetrieve(id: number, options?: any): AxiosPromise<Experiment> {
            return MlOpsApiFp(configuration).experimentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelArtifactsList(page?: number, options?: any): AxiosPromise<PaginatedModelArtifactList> {
            return MlOpsApiFp(configuration).modelArtifactsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this model artifact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelArtifactsRetrieve(id: number, options?: any): AxiosPromise<ModelArtifact> {
            return MlOpsApiFp(configuration).modelArtifactsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlOpsApi - interface
 * @export
 * @interface MlOpsApi
 */
export interface MlOpsApiInterface {
    /**
     * 
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationsList(page?: number, options?: any): AxiosPromise<PaginatedDeviceCalibrationList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationsRetrieve(id: number, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    deviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any): AxiosPromise<DeviceCalibration>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    experimentDeviceConfigsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentDeviceConfigList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment device config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    experimentDeviceConfigsRetrieve(id: number, options?: any): AxiosPromise<ExperimentDeviceConfig>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    experimentsList(page?: number, options?: any): AxiosPromise<PaginatedExperimentList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    experimentsRetrieve(id: number, options?: any): AxiosPromise<Experiment>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    modelArtifactsList(page?: number, options?: any): AxiosPromise<PaginatedModelArtifactList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this model artifact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApiInterface
     */
    modelArtifactsRetrieve(id: number, options?: any): AxiosPromise<ModelArtifact>;

}

/**
 * MlOpsApi - object-oriented interface
 * @export
 * @class MlOpsApi
 * @extends {BaseAPI}
 */
export class MlOpsApi extends BaseAPI implements MlOpsApiInterface {
    /**
     * 
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationUpdateOrCreate(deviceCalibrationRequest: DeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationUpdateOrCreate(deviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {PatchedDeviceCalibrationRequest} [patchedDeviceCalibrationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationsPartialUpdate(id: number, patchedDeviceCalibrationRequest?: PatchedDeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationsPartialUpdate(id, patchedDeviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this device calibration.
     * @param {DeviceCalibrationRequest} deviceCalibrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public deviceCalibrationsUpdate(id: number, deviceCalibrationRequest: DeviceCalibrationRequest, options?: any) {
        return MlOpsApiFp(this.configuration).deviceCalibrationsUpdate(id, deviceCalibrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public experimentDeviceConfigsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).experimentDeviceConfigsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment device config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public experimentDeviceConfigsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).experimentDeviceConfigsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public experimentsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).experimentsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this experiment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public experimentsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).experimentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public modelArtifactsList(page?: number, options?: any) {
        return MlOpsApiFp(this.configuration).modelArtifactsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this model artifact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlOpsApi
     */
    public modelArtifactsRetrieve(id: number, options?: any) {
        return MlOpsApiFp(this.configuration).modelArtifactsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteControlApi - axios parameter creator
 * @export
 */
export const RemoteControlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsPartialUpdate: async (id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commandsPartialUpdate.');
            }
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedRemoteControlCommandRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedRemoteControlCommandRequest !== undefined ? patchedRemoteControlCommandRequest : {})
                : (patchedRemoteControlCommandRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commandsRetrieve.');
            }
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsUpdate: async (id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling commandsUpdate.');
            }
            // verify required parameter 'remoteControlCommandRequest' is not null or undefined
            if (remoteControlCommandRequest === null || remoteControlCommandRequest === undefined) {
                throw new RequiredError('remoteControlCommandRequest','Required parameter remoteControlCommandRequest was null or undefined when calling commandsUpdate.');
            }
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof remoteControlCommandRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(remoteControlCommandRequest !== undefined ? remoteControlCommandRequest : {})
                : (remoteControlCommandRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesCreate: async (name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling gcodeFilesCreate.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling gcodeFilesCreate.');
            }
            // verify required parameter 'fileHash' is not null or undefined
            if (fileHash === null || fileHash === undefined) {
                throw new RequiredError('fileHash','Required parameter fileHash was null or undefined when calling gcodeFilesCreate.');
            }
            // verify required parameter 'octoprintDevice' is not null or undefined
            if (octoprintDevice === null || octoprintDevice === undefined) {
                throw new RequiredError('octoprintDevice','Required parameter octoprintDevice was null or undefined when calling gcodeFilesCreate.');
            }
            const localVarPath = `/api/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesPartialUpdate: async (id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gcodeFilesPartialUpdate.');
            }
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesRetrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gcodeFilesRetrieve.');
            }
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdate: async (id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling gcodeFilesUpdate.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling gcodeFilesUpdate.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling gcodeFilesUpdate.');
            }
            // verify required parameter 'fileHash' is not null or undefined
            if (fileHash === null || fileHash === undefined) {
                throw new RequiredError('fileHash','Required parameter fileHash was null or undefined when calling gcodeFilesUpdate.');
            }
            // verify required parameter 'octoprintDevice' is not null or undefined
            if (octoprintDevice === null || octoprintDevice === undefined) {
                throw new RequiredError('octoprintDevice','Required parameter octoprintDevice was null or undefined when calling gcodeFilesUpdate.');
            }
            const localVarPath = `/api/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdateOrCreate: async (name: string, file: any, fileHash: string, octoprintDevice: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling gcodeFilesUpdateOrCreate.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling gcodeFilesUpdateOrCreate.');
            }
            // verify required parameter 'fileHash' is not null or undefined
            if (fileHash === null || fileHash === undefined) {
                throw new RequiredError('fileHash','Required parameter fileHash was null or undefined when calling gcodeFilesUpdateOrCreate.');
            }
            // verify required parameter 'octoprintDevice' is not null or undefined
            if (octoprintDevice === null || octoprintDevice === undefined) {
                throw new RequiredError('octoprintDevice','Required parameter octoprintDevice was null or undefined when calling gcodeFilesUpdateOrCreate.');
            }
            const localVarPath = `/api/gcode-files/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileHash !== undefined) { 
                localVarFormParams.append('file_hash', fileHash as any);
            }
    
            if (octoprintDevice !== undefined) { 
                localVarFormParams.append('octoprint_device', octoprintDevice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesCreate: async (octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            if (octoPrintDeviceRequest === null || octoPrintDeviceRequest === undefined) {
                throw new RequiredError('octoPrintDeviceRequest','Required parameter octoPrintDeviceRequest was null or undefined when calling octoprintDevicesCreate.');
            }
            const localVarPath = `/api/octoprint-devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof octoPrintDeviceRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(octoPrintDeviceRequest !== undefined ? octoPrintDeviceRequest : {})
                : (octoPrintDeviceRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint-devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesPartialUpdate: async (id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling octoprintDevicesPartialUpdate.');
            }
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedOctoPrintDeviceRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedOctoPrintDeviceRequest !== undefined ? patchedOctoPrintDeviceRequest : {})
                : (patchedOctoPrintDeviceRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling octoprintDevicesRetrieve.');
            }
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdate: async (id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling octoprintDevicesUpdate.');
            }
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            if (octoPrintDeviceRequest === null || octoPrintDeviceRequest === undefined) {
                throw new RequiredError('octoPrintDeviceRequest','Required parameter octoPrintDeviceRequest was null or undefined when calling octoprintDevicesUpdate.');
            }
            const localVarPath = `/api/octoprint-devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof octoPrintDeviceRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(octoPrintDeviceRequest !== undefined ? octoPrintDeviceRequest : {})
                : (octoPrintDeviceRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdateOrCreate: async (octoPrintDeviceRequest: OctoPrintDeviceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintDeviceRequest' is not null or undefined
            if (octoPrintDeviceRequest === null || octoPrintDeviceRequest === undefined) {
                throw new RequiredError('octoPrintDeviceRequest','Required parameter octoPrintDeviceRequest was null or undefined when calling octoprintDevicesUpdateOrCreate.');
            }
            const localVarPath = `/api/octoprint-devices/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof octoPrintDeviceRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(octoPrintDeviceRequest !== undefined ? octoPrintDeviceRequest : {})
                : (octoPrintDeviceRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionPartialUpdate: async (session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            if (session === null || session === undefined) {
                throw new RequiredError('session','Required parameter session was null or undefined when calling printSessionPartialUpdate.');
            }
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedPrintSessionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedPrintSessionRequest !== undefined ? patchedPrintSessionRequest : {})
                : (patchedPrintSessionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionUpdate: async (session: string, printSessionRequest: PrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            if (session === null || session === undefined) {
                throw new RequiredError('session','Required parameter session was null or undefined when calling printSessionUpdate.');
            }
            // verify required parameter 'printSessionRequest' is not null or undefined
            if (printSessionRequest === null || printSessionRequest === undefined) {
                throw new RequiredError('printSessionRequest','Required parameter printSessionRequest was null or undefined when calling printSessionUpdate.');
            }
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof printSessionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(printSessionRequest !== undefined ? printSessionRequest : {})
                : (printSessionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsCreate: async (printSessionRequest: PrintSessionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printSessionRequest' is not null or undefined
            if (printSessionRequest === null || printSessionRequest === undefined) {
                throw new RequiredError('printSessionRequest','Required parameter printSessionRequest was null or undefined when calling printSessionsCreate.');
            }
            const localVarPath = `/api/print-sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof printSessionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(printSessionRequest !== undefined ? printSessionRequest : {})
                : (printSessionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/print-sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsRetrieve: async (session: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'session' is not null or undefined
            if (session === null || session === undefined) {
                throw new RequiredError('session','Required parameter session was null or undefined when calling printSessionsRetrieve.');
            }
            const localVarPath = `/api/print-sessions/{session}/`
                .replace(`{${"session"}}`, encodeURIComponent(String(session)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesCreate: async (printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printerProfileRequest' is not null or undefined
            if (printerProfileRequest === null || printerProfileRequest === undefined) {
                throw new RequiredError('printerProfileRequest','Required parameter printerProfileRequest was null or undefined when calling printerProfilesCreate.');
            }
            const localVarPath = `/api/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof printerProfileRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(printerProfileRequest !== undefined ? printerProfileRequest : {})
                : (printerProfileRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesList: async (name?: string, page?: number, user?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesPartialUpdate: async (id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling printerProfilesPartialUpdate.');
            }
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedPrinterProfileRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedPrinterProfileRequest !== undefined ? patchedPrinterProfileRequest : {})
                : (patchedPrinterProfileRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling printerProfilesRetrieve.');
            }
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdate: async (id: number, printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling printerProfilesUpdate.');
            }
            // verify required parameter 'printerProfileRequest' is not null or undefined
            if (printerProfileRequest === null || printerProfileRequest === undefined) {
                throw new RequiredError('printerProfileRequest','Required parameter printerProfileRequest was null or undefined when calling printerProfilesUpdate.');
            }
            const localVarPath = `/api/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof printerProfileRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(printerProfileRequest !== undefined ? printerProfileRequest : {})
                : (printerProfileRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdateOrCreate: async (printerProfileRequest: PrinterProfileRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'printerProfileRequest' is not null or undefined
            if (printerProfileRequest === null || printerProfileRequest === undefined) {
                throw new RequiredError('printerProfileRequest','Required parameter printerProfileRequest was null or undefined when calling printerProfilesUpdateOrCreate.');
            }
            const localVarPath = `/api/printer-profiles/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof printerProfileRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(printerProfileRequest !== undefined ? printerProfileRequest : {})
                : (printerProfileRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsCreate: async (image: any, command: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling snapshotsCreate.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling snapshotsCreate.');
            }
            const localVarPath = `/api/snapshots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (command !== undefined) { 
                localVarFormParams.append('command', command as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/snapshots/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} [image] 
         * @param {number} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsPartialUpdate: async (id: number, image?: any, command?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling snapshotsPartialUpdate.');
            }
            const localVarPath = `/api/snapshots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (command !== undefined) { 
                localVarFormParams.append('command', command as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling snapshotsRetrieve.');
            }
            const localVarPath = `/api/snapshots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsUpdate: async (id: number, image: any, command: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling snapshotsUpdate.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling snapshotsUpdate.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling snapshotsUpdate.');
            }
            const localVarPath = `/api/snapshots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (command !== undefined) { 
                localVarFormParams.append('command', command as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validCommandsRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/valid/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteControlApi - functional programming interface
 * @export
 */
export const RemoteControlApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRemoteControlCommandList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).commandsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).commandsPartialUpdate(id, patchedRemoteControlCommandRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).commandsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlCommand>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).commandsUpdate(id, remoteControlCommandRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesCreate(name, file, fileHash, octoprintDevice, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGcodeFileList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesRetrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesCreate(octoPrintDeviceRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintDeviceList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesUpdate(id, octoPrintDeviceRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintDevice>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printSessionPartialUpdate(session, patchedPrintSessionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printSessionUpdate(session, printSessionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printSessionsCreate(printSessionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintSessionList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printSessionsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printSessionsRetrieve(session: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printSessionsRetrieve(session, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintSession>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesCreate(printerProfileRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesList(name?: string, page?: number, user?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrinterProfileList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesList(name, page, user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesPartialUpdate(id, patchedPrinterProfileRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesUpdate(id, printerProfileRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrinterProfile>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).printerProfilesUpdateOrCreate(printerProfileRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsCreate(image: any, command: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlSnapshotCreateResponse>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).snapshotsCreate(image, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRemoteControlSnapshotList>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).snapshotsList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} [image] 
         * @param {number} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsPartialUpdate(id: number, image?: any, command?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlSnapshot>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).snapshotsPartialUpdate(id, image, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlSnapshot>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).snapshotsRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapshotsUpdate(id: number, image: any, command: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteControlSnapshot>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).snapshotsUpdate(id, image, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validCommandsRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await RemoteControlApiAxiosParamCreator(configuration).validCommandsRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemoteControlApi - factory interface
 * @export
 */
export const RemoteControlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlCommandList> {
            return RemoteControlApiFp(configuration).commandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand> {
            return RemoteControlApiFp(configuration).commandsPartialUpdate(id, patchedRemoteControlCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlCommand> {
            return RemoteControlApiFp(configuration).commandsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control command.
         * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand> {
            return RemoteControlApiFp(configuration).commandsUpdate(id, remoteControlCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return RemoteControlApiFp(configuration).gcodeFilesCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList> {
            return RemoteControlApiFp(configuration).gcodeFilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {string} [fileHash] 
         * @param {string} [octoprintDevice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): AxiosPromise<GcodeFile> {
            return RemoteControlApiFp(configuration).gcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesRetrieve(id: string, options?: any): AxiosPromise<GcodeFile> {
            return RemoteControlApiFp(configuration).gcodeFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return RemoteControlApiFp(configuration).gcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} fileHash 
         * @param {string} octoprintDevice 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile> {
            return RemoteControlApiFp(configuration).gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return RemoteControlApiFp(configuration).octoprintDevicesCreate(octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintDeviceList> {
            return RemoteControlApiFp(configuration).octoprintDevicesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return RemoteControlApiFp(configuration).octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesRetrieve(id: number, options?: any): AxiosPromise<OctoPrintDevice> {
            return RemoteControlApiFp(configuration).octoprintDevicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print device.
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return RemoteControlApiFp(configuration).octoprintDevicesUpdate(id, octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice> {
            return RemoteControlApiFp(configuration).octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return RemoteControlApiFp(configuration).printSessionPartialUpdate(session, patchedPrintSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return RemoteControlApiFp(configuration).printSessionUpdate(session, printSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrintSessionRequest} printSessionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession> {
            return RemoteControlApiFp(configuration).printSessionsCreate(printSessionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionList> {
            return RemoteControlApiFp(configuration).printSessionsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} session 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printSessionsRetrieve(session: string, options?: any): AxiosPromise<PrintSession> {
            return RemoteControlApiFp(configuration).printSessionsRetrieve(session, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrintSession> {
            return RemoteControlApiFp(configuration).printerProfilesCreate(printerProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesList(name?: string, page?: number, user?: number, options?: any): AxiosPromise<PaginatedPrinterProfileList> {
            return RemoteControlApiFp(configuration).printerProfilesList(name, page, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return RemoteControlApiFp(configuration).printerProfilesPartialUpdate(id, patchedPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesRetrieve(id: number, options?: any): AxiosPromise<PrinterProfile> {
            return RemoteControlApiFp(configuration).printerProfilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this printer profile.
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return RemoteControlApiFp(configuration).printerProfilesUpdate(id, printerProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrinterProfileRequest} printerProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile> {
            return RemoteControlApiFp(configuration).printerProfilesUpdateOrCreate(printerProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsCreate(image: any, command: number, options?: any): AxiosPromise<RemoteControlSnapshotCreateResponse> {
            return RemoteControlApiFp(configuration).snapshotsCreate(image, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlSnapshotList> {
            return RemoteControlApiFp(configuration).snapshotsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} [image] 
         * @param {number} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsPartialUpdate(id: number, image?: any, command?: number, options?: any): AxiosPromise<RemoteControlSnapshot> {
            return RemoteControlApiFp(configuration).snapshotsPartialUpdate(id, image, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlSnapshot> {
            return RemoteControlApiFp(configuration).snapshotsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this remote control snapshot.
         * @param {any} image 
         * @param {number} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapshotsUpdate(id: number, image: any, command: number, options?: any): AxiosPromise<RemoteControlSnapshot> {
            return RemoteControlApiFp(configuration).snapshotsUpdate(id, image, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validCommandsRetrieve(options?: any): AxiosPromise<string> {
            return RemoteControlApiFp(configuration).validCommandsRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RemoteControlApi - interface
 * @export
 * @interface RemoteControlApi
 */
export interface RemoteControlApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    commandsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlCommandList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    commandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    commandsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    commandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any): AxiosPromise<RemoteControlCommand>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList>;

    /**
     * 
     * @param {string} id 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {string} [fileHash] 
     * @param {string} [octoprintDevice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesRetrieve(id: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintDeviceList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesRetrieve(id: number, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any): AxiosPromise<OctoPrintDevice>;

    /**
     * 
     * @param {string} session 
     * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {string} session 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionsList(page?: number, options?: any): AxiosPromise<PaginatedPrintSessionList>;

    /**
     * 
     * @param {string} session 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printSessionsRetrieve(session: string, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrintSession>;

    /**
     * 
     * @param {string} [name] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesList(name?: string, page?: number, user?: number, options?: any): AxiosPromise<PaginatedPrinterProfileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesRetrieve(id: number, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any): AxiosPromise<PrinterProfile>;

    /**
     * 
     * @param {any} image 
     * @param {number} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    snapshotsCreate(image: any, command: number, options?: any): AxiosPromise<RemoteControlSnapshotCreateResponse>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    snapshotsList(page?: number, options?: any): AxiosPromise<PaginatedRemoteControlSnapshotList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {any} [image] 
     * @param {number} [command] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    snapshotsPartialUpdate(id: number, image?: any, command?: number, options?: any): AxiosPromise<RemoteControlSnapshot>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    snapshotsRetrieve(id: number, options?: any): AxiosPromise<RemoteControlSnapshot>;

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {any} image 
     * @param {number} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    snapshotsUpdate(id: number, image: any, command: number, options?: any): AxiosPromise<RemoteControlSnapshot>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApiInterface
     */
    validCommandsRetrieve(options?: any): AxiosPromise<string>;

}

/**
 * RemoteControlApi - object-oriented interface
 * @export
 * @class RemoteControlApi
 * @extends {BaseAPI}
 */
export class RemoteControlApi extends BaseAPI implements RemoteControlApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public commandsList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).commandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {PatchedRemoteControlCommandRequest} [patchedRemoteControlCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public commandsPartialUpdate(id: number, patchedRemoteControlCommandRequest?: PatchedRemoteControlCommandRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).commandsPartialUpdate(id, patchedRemoteControlCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public commandsRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).commandsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control command.
     * @param {RemoteControlCommandRequest} remoteControlCommandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public commandsUpdate(id: number, remoteControlCommandRequest: RemoteControlCommandRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).commandsUpdate(id, remoteControlCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {string} [fileHash] 
     * @param {string} [octoprintDevice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesPartialUpdate(id: string, name?: string, file?: any, fileHash?: string, octoprintDevice?: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesPartialUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesRetrieve(id: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesUpdate(id: string, name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesUpdate(id, name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} fileHash 
     * @param {string} octoprintDevice 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public gcodeFilesUpdateOrCreate(name: string, file: any, fileHash: string, octoprintDevice: string, options?: any) {
        return RemoteControlApiFp(this.configuration).gcodeFilesUpdateOrCreate(name, file, fileHash, octoprintDevice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesCreate(octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {PatchedOctoPrintDeviceRequest} [patchedOctoPrintDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesPartialUpdate(id: number, patchedOctoPrintDeviceRequest?: PatchedOctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesPartialUpdate(id, patchedOctoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print device.
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesUpdate(id: number, octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesUpdate(id, octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintDeviceRequest} octoPrintDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest: OctoPrintDeviceRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).octoprintDevicesUpdateOrCreate(octoPrintDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {PatchedPrintSessionRequest} [patchedPrintSessionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionPartialUpdate(session: string, patchedPrintSessionRequest?: PatchedPrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionPartialUpdate(session, patchedPrintSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionUpdate(session: string, printSessionRequest: PrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionUpdate(session, printSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrintSessionRequest} printSessionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionsCreate(printSessionRequest: PrintSessionRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionsCreate(printSessionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionsList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} session 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printSessionsRetrieve(session: string, options?: any) {
        return RemoteControlApiFp(this.configuration).printSessionsRetrieve(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesCreate(printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesCreate(printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesList(name?: string, page?: number, user?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesList(name, page, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PatchedPrinterProfileRequest} [patchedPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesPartialUpdate(id: number, patchedPrinterProfileRequest?: PatchedPrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesPartialUpdate(id, patchedPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this printer profile.
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesUpdate(id: number, printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesUpdate(id, printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrinterProfileRequest} printerProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public printerProfilesUpdateOrCreate(printerProfileRequest: PrinterProfileRequest, options?: any) {
        return RemoteControlApiFp(this.configuration).printerProfilesUpdateOrCreate(printerProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} image 
     * @param {number} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public snapshotsCreate(image: any, command: number, options?: any) {
        return RemoteControlApiFp(this.configuration).snapshotsCreate(image, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public snapshotsList(page?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).snapshotsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {any} [image] 
     * @param {number} [command] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public snapshotsPartialUpdate(id: number, image?: any, command?: number, options?: any) {
        return RemoteControlApiFp(this.configuration).snapshotsPartialUpdate(id, image, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public snapshotsRetrieve(id: number, options?: any) {
        return RemoteControlApiFp(this.configuration).snapshotsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this remote control snapshot.
     * @param {any} image 
     * @param {number} command 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public snapshotsUpdate(id: number, image: any, command: number, options?: any) {
        return RemoteControlApiFp(this.configuration).snapshotsUpdate(id, image, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteControlApi
     */
    public validCommandsRetrieve(options?: any) {
        return RemoteControlApiFp(this.configuration).validCommandsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await SchemaApiAxiosParamCreator(configuration).schemaRetrieve(lang, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return SchemaApiFp(configuration).schemaRetrieve(lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any) {
        return SchemaApiFp(this.configuration).schemaRetrieve(lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUserRequest?: PatchedUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersPartialUpdate.');
            }
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof patchedUserRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(patchedUserRequest !== undefined ? patchedUserRequest : {})
                : (patchedUserRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersRetrieve.');
            }
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, userRequest: UserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling usersUpdate.');
            }
            // verify required parameter 'userRequest' is not null or undefined
            if (userRequest === null || userRequest === undefined) {
                throw new RequiredError('userRequest','Required parameter userRequest was null or undefined when calling usersUpdate.');
            }
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userRequest !== undefined ? userRequest : {})
                : (userRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserList>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersList(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersMeRetrieve(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersPartialUpdate(id, patchedUserRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersRetrieve(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, userRequest: UserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).usersUpdate(id, userRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(page?: number, options?: any): AxiosPromise<PaginatedUserList> {
            return UsersApiFp(configuration).usersList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).usersPartialUpdate(id, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, userRequest: UserRequest, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).usersUpdate(id, userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersList(page?: number, options?: any): AxiosPromise<PaginatedUserList>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMeRetrieve(options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersRetrieve(id: number, options?: any): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUpdate(id: number, userRequest: UserRequest, options?: any): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(page?: number, options?: any) {
        return UsersApiFp(this.configuration).usersList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: any) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: any) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, userRequest: UserRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUpdate(id, userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


