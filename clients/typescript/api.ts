/* tslint:disable */
/* eslint-disable */
/**
 * printnanny-api-client
 * Official API client library forprintnanny.ai print-nanny.com
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: leigh@printnanny.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'time': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'gcode_file': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'print_progress': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'time_elapsed': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'time_remaining': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'manage_device_url': string | null;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'octoprint_device'?: number | null;
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof Alert
     */
    'event_type'?: EventTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'seen'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'sent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'message': string;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface AlertBulkResponse
 */
export interface AlertBulkResponse {
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    'received': number;
    /**
     * 
     * @type {number}
     * @memberof AlertBulkResponse
     */
    'updated': number;
}
/**
 * 
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
    /**
     * 
     * @type {number}
     * @memberof AlertRequest
     */
    'octoprint_device'?: number | null;
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof AlertRequest
     */
    'event_type'?: EventTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRequest
     */
    'seen'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRequest
     */
    'sent'?: boolean;
}
/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuthRequest
 */
export interface CallbackTokenAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'token': string;
}
/**
 * Takes a user and a token, verifies the token belongs to the user and validates the alias that the token was sent from.
 * @export
 * @interface CallbackTokenVerification
 */
export interface CallbackTokenVerification {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerification
     */
    'token': string;
}
/**
 * Takes a user and a token, verifies the token belongs to the user and validates the alias that the token was sent from.
 * @export
 * @interface CallbackTokenVerificationRequest
 */
export interface CallbackTokenVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenVerificationRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CloudiotDevice
 */
export interface CloudiotDevice {
    /**
     * 
     * @type {number}
     * @memberof CloudiotDevice
     */
    'num_id': number;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'command_topic': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'event_topic': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'config_topic': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'state_topic': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'gcp_resource': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'gcp_project_id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'gcp_region': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'gcp_cloudiot_device_registry': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'mqtt_bridge_hostname': string;
    /**
     * 
     * @type {number}
     * @memberof CloudiotDevice
     */
    'mqtt_bridge_port': number;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'mqtt_client_id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CloudiotDevice
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof CloudiotDevice
     */
    'device': number;
    /**
     * 
     * @type {number}
     * @memberof CloudiotDevice
     */
    'public_key': number;
}
/**
 * 
 * @export
 * @interface CloudiotDeviceRequest
 */
export interface CloudiotDeviceRequest {
    /**
     * 
     * @type {number}
     * @memberof CloudiotDeviceRequest
     */
    'public_key': number;
}
/**
 * Generic auth response serializer
 * @export
 * @interface DetailResponse
 */
export interface DetailResponse {
    /**
     * 
     * @type {string}
     * @memberof DetailResponse
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'id': number;
    /**
     * 
     * @type {CloudiotDevice}
     * @memberof Device
     */
    'cloudiot_device': CloudiotDevice;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'cloud_url': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'edge_url': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'video_test_url': string;
    /**
     * 
     * @type {JanusAuth}
     * @memberof Device
     */
    'janus_auth': JanusAuth;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'janus_local_url': string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'monitoring_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'setup_complete'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof Device
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'octoprint_url': string;
    /**
     * 
     * @type {DeviceReleaseChannel}
     * @memberof Device
     */
    'release_channel'?: DeviceReleaseChannel;
    /**
     * 
     * @type {SystemInfo}
     * @memberof Device
     */
    'system_info': SystemInfo;
    /**
     * 
     * @type {PublicKey}
     * @memberof Device
     */
    'public_key': PublicKey;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'updated_dt': string;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof Device
     */
    'hostname'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeviceReleaseChannel = {
    Stable: 'stable',
    Nightly: 'nightly'
} as const;

export type DeviceReleaseChannel = typeof DeviceReleaseChannel[keyof typeof DeviceReleaseChannel];


/**
 * 
 * @export
 * @interface DeviceRequest
 */
export interface DeviceRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRequest
     */
    'monitoring_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRequest
     */
    'setup_complete'?: boolean;
    /**
     * 
     * @type {DeviceReleaseChannel}
     * @memberof DeviceRequest
     */
    'release_channel'?: DeviceReleaseChannel;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof DeviceRequest
     */
    'hostname'?: string;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuthRequest
 */
export interface EmailAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailAuthRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'code': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EventSource = {
    Octoprint: 'octoprint',
    PrintnannyOs: 'printnanny_os',
    PrintnannyWebapp: 'printnanny_webapp',
    Mainsail: 'mainsail'
} as const;

export type EventSource = typeof EventSource[keyof typeof EventSource];


/**
 * 
 * @export
 * @enum {string}
 */

export const EventTypeEnum = {
    PrintHealth: 'PrintHealth',
    PrintStatus: 'PrintStatus',
    PrintNannyWebapp: 'PrintNannyWebapp',
    PrintProgress: 'PrintProgress',
    PrintDone: 'PrintDone',
    PrintFailed: 'PrintFailed',
    PrintPaused: 'PrintPaused',
    PrintResumed: 'PrintResumed',
    PrintStarted: 'PrintStarted',
    PrintCancelled: 'PrintCancelled'
} as const;

export type EventTypeEnum = typeof EventTypeEnum[keyof typeof EventTypeEnum];


/**
 * 
 * @export
 * @interface GcodeFile
 */
export interface GcodeFile {
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface JanusAuth
 */
export interface JanusAuth {
    /**
     * 
     * @type {number}
     * @memberof JanusAuth
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof JanusAuth
     */
    'admin_secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JanusAuth
     */
    'api_token'?: string;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof JanusAuth
     */
    'config_type'?: JanusConfigType;
    /**
     * 
     * @type {string}
     * @memberof JanusAuth
     */
    'created_dt': string;
    /**
     * 
     * @type {number}
     * @memberof JanusAuth
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface JanusAuthRequest
 */
export interface JanusAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof JanusAuthRequest
     */
    'admin_secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JanusAuthRequest
     */
    'api_token'?: string;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof JanusAuthRequest
     */
    'config_type'?: JanusConfigType;
    /**
     * 
     * @type {number}
     * @memberof JanusAuthRequest
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface JanusCloudStream
 */
export interface JanusCloudStream {
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'id': number;
    /**
     * 
     * @type {JanusAuth}
     * @memberof JanusCloudStream
     */
    'auth': JanusAuth;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'api_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'api_url': string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'admin_url': string;
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'admin_port': number;
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'rtp_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'rtp_domain': string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'ws_url': string;
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'config_type': string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'updated_dt': string;
    /**
     * 
     * @type {boolean}
     * @memberof JanusCloudStream
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStream
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JanusCloudStream
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStream
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface JanusCloudStreamRequest
 */
export interface JanusCloudStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof JanusCloudStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStreamRequest
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof JanusCloudStreamRequest
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JanusCloudStreamRequest
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JanusCloudStreamRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JanusConfigType = {
    Cloud: 'cloud',
    Edge: 'edge'
} as const;

export type JanusConfigType = typeof JanusConfigType[keyof typeof JanusConfigType];


/**
 * 
 * @export
 * @interface JanusEdgeStream
 */
export interface JanusEdgeStream {
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'id': number;
    /**
     * 
     * @type {JanusAuth}
     * @memberof JanusEdgeStream
     */
    'auth': JanusAuth;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'api_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'api_url': string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'admin_url': string;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'admin_port': number;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'rtp_domain': string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'ws_url': string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'config_type': string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'updated_dt': string;
    /**
     * 
     * @type {boolean}
     * @memberof JanusEdgeStream
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStream
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JanusEdgeStream
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'rtp_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStream
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface JanusEdgeStreamRequest
 */
export interface JanusEdgeStreamRequest {
    /**
     * 
     * @type {JanusAuthRequest}
     * @memberof JanusEdgeStreamRequest
     */
    'auth': JanusAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStreamRequest
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStreamRequest
     */
    'api_port': number;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStreamRequest
     */
    'admin_port': number;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStreamRequest
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStreamRequest
     */
    'rtp_domain': string;
    /**
     * 
     * @type {boolean}
     * @memberof JanusEdgeStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStreamRequest
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof JanusEdgeStreamRequest
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JanusEdgeStreamRequest
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStreamRequest
     */
    'rtp_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof JanusEdgeStreamRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface JanusStream
 */
export interface JanusStream {
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'id': number;
    /**
     * 
     * @type {JanusAuth}
     * @memberof JanusStream
     */
    'auth': JanusAuth;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'api_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'api_url': string;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'admin_url': string;
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'admin_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'rtp_domain': string;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'ws_url': string;
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'config_type': string;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'updated_dt': string;
    /**
     * 
     * @type {boolean}
     * @memberof JanusStream
     */
    'active': boolean;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof JanusStream
     */
    'pin': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof JanusStream
     */
    'info': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'rtp_port': number;
    /**
     * 
     * @type {number}
     * @memberof JanusStream
     */
    'device': number;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface MobileAuthRequest
 */
export interface MobileAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof MobileAuthRequest
     */
    'mobile': string;
}
/**
 * 
 * @export
 * @interface OctoPrintBackup
 */
export interface OctoPrintBackup {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'file': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrintEvent
 */
export interface OctoPrintEvent {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    'id': number;
    /**
     * 
     * @type {OctoPrintEventModelEnum}
     * @memberof OctoPrintEvent
     */
    'model': OctoPrintEventModelEnum;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintEvent
     */
    'created_dt': string;
    /**
     * 
     * @type {EventSource}
     * @memberof OctoPrintEvent
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof OctoPrintEvent
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {OctoPrintEventEventNameEnum}
     * @memberof OctoPrintEvent
     */
    'event_name': OctoPrintEventEventNameEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEvent
     */
    'payload'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    'polymorphic_ctype': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    'octoprint_install': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEvent
     */
    'device': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintEventEventNameEnum = {
    Startup: 'Startup',
    Shutdown: 'Shutdown',
    PrintProgress: 'PrintProgress',
    Connecting: 'Connecting',
    Connected: 'Connected',
    Disconnecting: 'Disconnecting',
    Disconnected: 'Disconnected',
    Error: 'Error',
    PrintStarted: 'PrintStarted',
    PrintFailed: 'PrintFailed',
    PrintDone: 'PrintDone',
    PrintCancelling: 'PrintCancelling',
    PrintCancelled: 'PrintCancelled',
    PrintPaused: 'PrintPaused',
    PrintResumed: 'PrintResumed'
} as const;

export type OctoPrintEventEventNameEnum = typeof OctoPrintEventEventNameEnum[keyof typeof OctoPrintEventEventNameEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OctoPrintEventModelEnum = {
    OctoPrintEvent: 'OctoPrintEvent'
} as const;

export type OctoPrintEventModelEnum = typeof OctoPrintEventModelEnum[keyof typeof OctoPrintEventModelEnum];


/**
 * 
 * @export
 * @interface OctoPrintEventRequest
 */
export interface OctoPrintEventRequest {
    /**
     * 
     * @type {OctoPrintEventModelEnum}
     * @memberof OctoPrintEventRequest
     */
    'model': OctoPrintEventModelEnum;
    /**
     * 
     * @type {EventSource}
     * @memberof OctoPrintEventRequest
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof OctoPrintEventRequest
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {OctoPrintEventEventNameEnum}
     * @memberof OctoPrintEventRequest
     */
    'event_name': OctoPrintEventEventNameEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrintEventRequest
     */
    'payload'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    'octoprint_install': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintEventRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface OctoPrintInstall
 */
export interface OctoPrintInstall {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintInstall
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'pip_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'python_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'printnanny_plugin_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstall
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintInstall
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintInstall
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface OctoPrintInstallRequest
 */
export interface OctoPrintInstallRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstallRequest
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstallRequest
     */
    'pip_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstallRequest
     */
    'python_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintInstallRequest
     */
    'printnanny_plugin_version': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintInstallRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface OctoPrintSettings
 */
export interface OctoPrintSettings {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'id': number;
    /**
     * Sync Gcode files to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_backups'?: boolean;
    /**
     * Start PrintNanny monitoring automatically when a print job begins
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'monitoring_auto_start'?: boolean;
    /**
     * Pause failing print jobs automatically
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'monitoring_auto_pause'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrintSettingsRequest
 */
export interface OctoPrintSettingsRequest {
    /**
     * Sync Gcode files to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * Start PrintNanny monitoring automatically when a print job begins
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'monitoring_auto_start'?: boolean;
    /**
     * Pause failing print jobs automatically
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'monitoring_auto_pause'?: boolean;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfile
 */
export interface OctoPrinterProfile {
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfile
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_width'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfileRequest
 */
export interface OctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * 
 * @export
 * @interface PaginatedAlertList
 */
export interface PaginatedAlertList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAlertList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAlertList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof PaginatedAlertList
     */
    'results'?: Array<Alert>;
}
/**
 * 
 * @export
 * @interface PaginatedCloudiotDeviceList
 */
export interface PaginatedCloudiotDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCloudiotDeviceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCloudiotDeviceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCloudiotDeviceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CloudiotDevice>}
     * @memberof PaginatedCloudiotDeviceList
     */
    'results'?: Array<CloudiotDevice>;
}
/**
 * 
 * @export
 * @interface PaginatedDeviceList
 */
export interface PaginatedDeviceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedDeviceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedDeviceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Device>}
     * @memberof PaginatedDeviceList
     */
    'results'?: Array<Device>;
}
/**
 * 
 * @export
 * @interface PaginatedGcodeFileList
 */
export interface PaginatedGcodeFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGcodeFileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GcodeFile>}
     * @memberof PaginatedGcodeFileList
     */
    'results'?: Array<GcodeFile>;
}
/**
 * 
 * @export
 * @interface PaginatedJanusAuthList
 */
export interface PaginatedJanusAuthList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedJanusAuthList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusAuthList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusAuthList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<JanusAuth>}
     * @memberof PaginatedJanusAuthList
     */
    'results'?: Array<JanusAuth>;
}
/**
 * 
 * @export
 * @interface PaginatedJanusCloudStreamList
 */
export interface PaginatedJanusCloudStreamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedJanusCloudStreamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusCloudStreamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusCloudStreamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<JanusCloudStream>}
     * @memberof PaginatedJanusCloudStreamList
     */
    'results'?: Array<JanusCloudStream>;
}
/**
 * 
 * @export
 * @interface PaginatedJanusEdgeStreamList
 */
export interface PaginatedJanusEdgeStreamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedJanusEdgeStreamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusEdgeStreamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusEdgeStreamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<JanusEdgeStream>}
     * @memberof PaginatedJanusEdgeStreamList
     */
    'results'?: Array<JanusEdgeStream>;
}
/**
 * 
 * @export
 * @interface PaginatedJanusStreamList
 */
export interface PaginatedJanusStreamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedJanusStreamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusStreamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedJanusStreamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<JanusStream>}
     * @memberof PaginatedJanusStreamList
     */
    'results'?: Array<JanusStream>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintBackupList
 */
export interface PaginatedOctoPrintBackupList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintBackupList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintBackup>}
     * @memberof PaginatedOctoPrintBackupList
     */
    'results'?: Array<OctoPrintBackup>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintInstallList
 */
export interface PaginatedOctoPrintInstallList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintInstallList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintInstallList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintInstallList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintInstall>}
     * @memberof PaginatedOctoPrintInstallList
     */
    'results'?: Array<OctoPrintInstall>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintSettingsList
 */
export interface PaginatedOctoPrintSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintSettings>}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'results'?: Array<OctoPrintSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrinterProfileList
 */
export interface PaginatedOctoPrinterProfileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrinterProfile>}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'results'?: Array<OctoPrinterProfile>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicCommandList
 */
export interface PaginatedPolymorphicCommandList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicCommandList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicCommandList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicCommandList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicCommand>}
     * @memberof PaginatedPolymorphicCommandList
     */
    'results'?: Array<PolymorphicCommand>;
}
/**
 * 
 * @export
 * @interface PaginatedPolymorphicEventList
 */
export interface PaginatedPolymorphicEventList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPolymorphicEventList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicEventList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPolymorphicEventList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PolymorphicEvent>}
     * @memberof PaginatedPolymorphicEventList
     */
    'results'?: Array<PolymorphicEvent>;
}
/**
 * 
 * @export
 * @interface PaginatedPublicKeyList
 */
export interface PaginatedPublicKeyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPublicKeyList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPublicKeyList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPublicKeyList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PublicKey>}
     * @memberof PaginatedPublicKeyList
     */
    'results'?: Array<PublicKey>;
}
/**
 * 
 * @export
 * @interface PaginatedSystemInfoList
 */
export interface PaginatedSystemInfoList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSystemInfoList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SystemInfo>}
     * @memberof PaginatedSystemInfoList
     */
    'results'?: Array<SystemInfo>;
}
/**
 * Do not use underscores in this serializer - linitation of Firebase Cloud Messaging
 * @export
 * @interface Partner3DGeeksAlert
 */
export interface Partner3DGeeksAlert {
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'event': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'printer': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'print': string;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    'currentTime': number;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    'timeLeft': number;
    /**
     * 
     * @type {number}
     * @memberof Partner3DGeeksAlert
     */
    'percent': number;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'image': string | null;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksAlert
     */
    'action': string;
}
/**
 * Please do not include any personally-identifying info or sensitive info in partner serializers
 * @export
 * @interface Partner3DGeeksMetadata
 */
export interface Partner3DGeeksMetadata {
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'model': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'print_nanny_plugin_version': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'print_nanny_client_version': string;
    /**
     * 
     * @type {string}
     * @memberof Partner3DGeeksMetadata
     */
    'verified': string;
}
/**
 * Serializer used in POST /api/alerts/seen and POST /api/alerts/dismiss requests
 * @export
 * @interface PatchedAlertBulkRequestRequest
 */
export interface PatchedAlertBulkRequestRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedAlertBulkRequestRequest
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedAlertRequest
 */
export interface PatchedAlertRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedAlertRequest
     */
    'octoprint_device'?: number | null;
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof PatchedAlertRequest
     */
    'event_type'?: EventTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAlertRequest
     */
    'seen'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAlertRequest
     */
    'sent'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedCloudiotDeviceRequest
 */
export interface PatchedCloudiotDeviceRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedCloudiotDeviceRequest
     */
    'public_key'?: number;
}
/**
 * 
 * @export
 * @interface PatchedDeviceRequest
 */
export interface PatchedDeviceRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedDeviceRequest
     */
    'monitoring_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedDeviceRequest
     */
    'setup_complete'?: boolean;
    /**
     * 
     * @type {DeviceReleaseChannel}
     * @memberof PatchedDeviceRequest
     */
    'release_channel'?: DeviceReleaseChannel;
    /**
     * Please enter the hostname you set in the Raspberry Pi Imager\'s Advanced Options menu (without .local extension)
     * @type {string}
     * @memberof PatchedDeviceRequest
     */
    'hostname'?: string;
}
/**
 * 
 * @export
 * @interface PatchedJanusCloudStreamRequest
 */
export interface PatchedJanusCloudStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedJanusCloudStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusCloudStreamRequest
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusCloudStreamRequest
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedJanusCloudStreamRequest
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusCloudStreamRequest
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface PatchedJanusEdgeStreamRequest
 */
export interface PatchedJanusEdgeStreamRequest {
    /**
     * 
     * @type {JanusAuthRequest}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'auth'?: JanusAuthRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'api_domain'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'api_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'admin_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'ws_port'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'rtp_domain'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'pin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'info'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'rtp_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedJanusEdgeStreamRequest
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintInstallRequest
 */
export interface PatchedOctoPrintInstallRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintInstallRequest
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintInstallRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintInstallRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintInstallRequest
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintInstallRequest
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintSettingsRequest
 */
export interface PatchedOctoPrintSettingsRequest {
    /**
     * Sync Gcode files to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * Start PrintNanny monitoring automatically when a print job begins
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'monitoring_auto_start'?: boolean;
    /**
     * Pause failing print jobs automatically
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'monitoring_auto_pause'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrinterProfileRequest
 */
export interface PatchedOctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'octoprint_key'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedPublicKeyRequest
 */
export interface PatchedPublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPublicKeyRequest
     */
    'pem'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPublicKeyRequest
     */
    'cipher'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPublicKeyRequest
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPublicKeyRequest
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPublicKeyRequest
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface PatchedSystemInfoRequest
 */
export interface PatchedSystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'machine_id'?: string;
    /**
     * Populated from /proc/cpuinfo HARDWARE
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'hardware'?: string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'revision'?: string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'model'?: string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'serial'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'ram'?: number;
    /**
     * PrintNanny OS image version string from /boot/image_version.txt
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'image_version'?: string;
    /**
     * PrintNanny OS ansible collection version string. Releaes: https://github.com/bitsy-ai/ansible-collection-printnanny
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'ansible_collection_version'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'email'?: string;
}
/**
 * @type PolymorphicCommand
 * @export
 */
export type PolymorphicCommand = WebRTCCommand;

/**
 * @type PolymorphicCommandRequest
 * @export
 */
export type PolymorphicCommandRequest = WebRTCCommandRequest;

/**
 * @type PolymorphicEvent
 * @export
 */
export type PolymorphicEvent = OctoPrintEvent | TestEvent | WebRTCCommand | WebRTCEvent;

/**
 * @type PolymorphicEventRequest
 * @export
 */
export type PolymorphicEventRequest = OctoPrintEventRequest | TestEventRequest | WebRTCCommandRequest | WebRTCEventRequest;

/**
 * 
 * @export
 * @interface PrintNannyApiConfig
 */
export interface PrintNannyApiConfig {
    /**
     * 
     * @type {string}
     * @memberof PrintNannyApiConfig
     */
    'bearer_access_token': string | null;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyApiConfig
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyApiConfig
     */
    'static_url': string;
    /**
     * 
     * @type {string}
     * @memberof PrintNannyApiConfig
     */
    'dashboard_url': string;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {number}
     * @memberof PublicKey
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'pem': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'cipher': string;
    /**
     * 
     * @type {number}
     * @memberof PublicKey
     */
    'length': number;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof PublicKey
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface PublicKeyRequest
 */
export interface PublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'pem': string;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'cipher': string;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyRequest
     */
    'length': number;
    /**
     * 
     * @type {string}
     * @memberof PublicKeyRequest
     */
    'fingerprint': string;
    /**
     * 
     * @type {number}
     * @memberof PublicKeyRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'updated_dt': string;
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfo
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo HARDWARE
     * @type {string}
     * @memberof SystemInfo
     */
    'hardware': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfo
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfo
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfo
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'ram': number;
    /**
     * PrintNanny OS image version string from /boot/image_version.txt
     * @type {string}
     * @memberof SystemInfo
     */
    'image_version': string;
    /**
     * PrintNanny OS ansible collection version string. Releaes: https://github.com/bitsy-ai/ansible-collection-printnanny
     * @type {string}
     * @memberof SystemInfo
     */
    'ansible_collection_version': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface SystemInfoRequest
 */
export interface SystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo HARDWARE
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'hardware': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'ram': number;
    /**
     * PrintNanny OS image version string from /boot/image_version.txt
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'image_version': string;
    /**
     * PrintNanny OS ansible collection version string. Releaes: https://github.com/bitsy-ai/ansible-collection-printnanny
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'ansible_collection_version': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'device': number;
}
/**
 * 
 * @export
 * @interface TestEvent
 */
export interface TestEvent {
    /**
     * 
     * @type {number}
     * @memberof TestEvent
     */
    'id': number;
    /**
     * 
     * @type {TestEventModel}
     * @memberof TestEvent
     */
    'model': TestEventModel;
    /**
     * 
     * @type {string}
     * @memberof TestEvent
     */
    'created_dt': string;
    /**
     * 
     * @type {EventSource}
     * @memberof TestEvent
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof TestEvent
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {TestEventName}
     * @memberof TestEvent
     */
    'event_name': TestEventName;
    /**
     * Broadcast to mqtt topic: /devices/{device-id}/commands/
     * @type {boolean}
     * @memberof TestEvent
     */
    'send_mqtt'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TestEvent
     */
    'polymorphic_ctype': number;
    /**
     * 
     * @type {number}
     * @memberof TestEvent
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof TestEvent
     */
    'device': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TestEventModel = {
    TestEvent: 'TestEvent'
} as const;

export type TestEventModel = typeof TestEventModel[keyof typeof TestEventModel];


/**
 * 
 * @export
 * @enum {string}
 */

export const TestEventName = {
    Ping: 'mqtt_ping',
    Pong: 'mqtt_pong'
} as const;

export type TestEventName = typeof TestEventName[keyof typeof TestEventName];


/**
 * 
 * @export
 * @interface TestEventRequest
 */
export interface TestEventRequest {
    /**
     * 
     * @type {TestEventModel}
     * @memberof TestEventRequest
     */
    'model': TestEventModel;
    /**
     * 
     * @type {EventSource}
     * @memberof TestEventRequest
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof TestEventRequest
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {TestEventName}
     * @memberof TestEventRequest
     */
    'event_name': TestEventName;
    /**
     * Broadcast to mqtt topic: /devices/{device-id}/commands/
     * @type {boolean}
     * @memberof TestEventRequest
     */
    'send_mqtt'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TestEventRequest
     */
    'device': number;
}
/**
 * Our default response serializer.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface WebRTCCommand
 */
export interface WebRTCCommand {
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommand
     */
    'id': number;
    /**
     * 
     * @type {WebRTCCommandModelEnum}
     * @memberof WebRTCCommand
     */
    'model': WebRTCCommandModelEnum;
    /**
     * 
     * @type {string}
     * @memberof WebRTCCommand
     */
    'created_dt': string;
    /**
     * 
     * @type {EventSource}
     * @memberof WebRTCCommand
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof WebRTCCommand
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {WebRTCCommandEventNameEnum}
     * @memberof WebRTCCommand
     */
    'event_name': WebRTCCommandEventNameEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebRTCCommand
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommand
     */
    'polymorphic_ctype': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommand
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommand
     */
    'device': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommand
     */
    'stream': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebRTCCommandEventNameEnum = {
    Start: 'stream_start',
    Stop: 'stream_stop'
} as const;

export type WebRTCCommandEventNameEnum = typeof WebRTCCommandEventNameEnum[keyof typeof WebRTCCommandEventNameEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebRTCCommandModelEnum = {
    WebRtcCommand: 'WebRTCCommand'
} as const;

export type WebRTCCommandModelEnum = typeof WebRTCCommandModelEnum[keyof typeof WebRTCCommandModelEnum];


/**
 * 
 * @export
 * @interface WebRTCCommandRequest
 */
export interface WebRTCCommandRequest {
    /**
     * 
     * @type {WebRTCCommandModelEnum}
     * @memberof WebRTCCommandRequest
     */
    'model': WebRTCCommandModelEnum;
    /**
     * 
     * @type {EventSource}
     * @memberof WebRTCCommandRequest
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof WebRTCCommandRequest
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {WebRTCCommandEventNameEnum}
     * @memberof WebRTCCommandRequest
     */
    'event_name': WebRTCCommandEventNameEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebRTCCommandRequest
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommandRequest
     */
    'device': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCCommandRequest
     */
    'stream': number;
}
/**
 * 
 * @export
 * @interface WebRTCEvent
 */
export interface WebRTCEvent {
    /**
     * 
     * @type {number}
     * @memberof WebRTCEvent
     */
    'id': number;
    /**
     * 
     * @type {WebRTCEventModel}
     * @memberof WebRTCEvent
     */
    'model': WebRTCEventModel;
    /**
     * 
     * @type {string}
     * @memberof WebRTCEvent
     */
    'created_dt': string;
    /**
     * 
     * @type {EventSource}
     * @memberof WebRTCEvent
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof WebRTCEvent
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {WebRTCEventName}
     * @memberof WebRTCEvent
     */
    'event_name': WebRTCEventName;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebRTCEvent
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebRTCEvent
     */
    'polymorphic_ctype': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCEvent
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCEvent
     */
    'device': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCEvent
     */
    'stream': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebRTCEventModel = {
    WebRtcEvent: 'WebRTCEvent'
} as const;

export type WebRTCEventModel = typeof WebRTCEventModel[keyof typeof WebRTCEventModel];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebRTCEventName = {
    StartSuccess: 'stream_start_success',
    StartError: 'stream_start_error',
    StopSuccess: 'stream_stop_success',
    StopError: 'stream_stop_error'
} as const;

export type WebRTCEventName = typeof WebRTCEventName[keyof typeof WebRTCEventName];


/**
 * 
 * @export
 * @interface WebRTCEventRequest
 */
export interface WebRTCEventRequest {
    /**
     * 
     * @type {WebRTCEventModel}
     * @memberof WebRTCEventRequest
     */
    'model': WebRTCEventModel;
    /**
     * 
     * @type {EventSource}
     * @memberof WebRTCEventRequest
     */
    'source': EventSource;
    /**
     * Broadcast to events websocket: /ws/events
     * @type {boolean}
     * @memberof WebRTCEventRequest
     */
    'send_ws'?: boolean;
    /**
     * 
     * @type {WebRTCEventName}
     * @memberof WebRTCEventRequest
     */
    'event_name': WebRTCEventName;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebRTCEventRequest
     */
    'data'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WebRTCEventRequest
     */
    'device': number;
    /**
     * 
     * @type {number}
     * @memberof WebRTCEventRequest
     */
    'stream': number;
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPartialUpdate: async (id: number, patchedAlertRequest?: PatchedAlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsPartialUpdate', 'id', id)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/recent/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsRetrieve', 'id', id)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen: async (patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/seen/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAlertBulkRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnread: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/unread/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} [alertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUpdate: async (id: number, alertRequest?: AlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsUpdate', 'id', id)
            const localVarPath = `/api/alerts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAlertList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPartialUpdate(id, patchedAlertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsRecent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsSeen(patchedAlertBulkRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsUnread(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertBulkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsUnread(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} [alertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsUpdate(id: number, alertRequest?: AlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsUpdate(id, alertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList(page?: number, options?: any): AxiosPromise<PaginatedAlertList> {
            return localVarFp.alertsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {PatchedAlertRequest} [patchedAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: any): AxiosPromise<Alert> {
            return localVarFp.alertsPartialUpdate(id, patchedAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRecent(options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsRetrieve(id: number, options?: any): AxiosPromise<Alert> {
            return localVarFp.alertsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUnread(options?: any): AxiosPromise<AlertBulkResponse> {
            return localVarFp.alertsUnread(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this alert message.
         * @param {AlertRequest} [alertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsUpdate(id: number, alertRequest?: AlertRequest, options?: any): AxiosPromise<Alert> {
            return localVarFp.alertsUpdate(id, alertRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - interface
 * @export
 * @interface AlertsApi
 */
export interface AlertsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedAlertList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {PatchedAlertRequest} [patchedAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: AxiosRequestConfig): AxiosPromise<Alert>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsRecent(options?: AxiosRequestConfig): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Alert>;

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: AxiosRequestConfig): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsUnread(options?: AxiosRequestConfig): AxiosPromise<AlertBulkResponse>;

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {AlertRequest} [alertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsUpdate(id: number, alertRequest?: AlertRequest, options?: AxiosRequestConfig): AxiosPromise<Alert>;

}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI implements AlertsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsList(page?: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {PatchedAlertRequest} [patchedAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPartialUpdate(id: number, patchedAlertRequest?: PatchedAlertRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPartialUpdate(id, patchedAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsRecent(options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsRetrieve(id: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PatchedAlertBulkRequestRequest} [patchedAlertBulkRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsSeen(patchedAlertBulkRequestRequest?: PatchedAlertBulkRequestRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsSeen(patchedAlertBulkRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsUnread(options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsUnread(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this alert message.
     * @param {AlertRequest} [alertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsUpdate(id: number, alertRequest?: AlertRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsUpdate(id, alertRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailCreate: async (emailAuthRequest: EmailAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailAuthRequest' is not null or undefined
            assertParamExists('authEmailCreate', 'emailAuthRequest', emailAuthRequest)
            const localVarPath = `/auth/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileCreate: async (mobileAuthRequest: MobileAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mobileAuthRequest' is not null or undefined
            assertParamExists('authMobileCreate', 'mobileAuthRequest', mobileAuthRequest)
            const localVarPath = `/auth/mobile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mobileAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate: async (callbackTokenAuthRequest: CallbackTokenAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenAuthRequest' is not null or undefined
            assertParamExists('authTokenCreate', 'callbackTokenAuthRequest', callbackTokenAuthRequest)
            const localVarPath = `/auth/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyCreate: async (callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenVerificationRequest' is not null or undefined
            assertParamExists('authVerifyCreate', 'callbackTokenVerificationRequest', callbackTokenVerificationRequest)
            const localVarPath = `/auth/verify/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobileCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify/mobile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailCreate(emailAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMobileCreate(mobileAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCreate(callbackTokenAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallbackTokenVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyCreate(callbackTokenVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyEmailCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyEmailCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyMobileCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyMobileCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authEmailCreate(emailAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {MobileAuthRequest} mobileAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authMobileCreate(mobileAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.authTokenCreate(callbackTokenAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
         * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: any): AxiosPromise<CallbackTokenVerification> {
            return localVarFp.authVerifyCreate(callbackTokenVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyEmailCreate(options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authVerifyEmailCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyMobileCreate(options?: any): AxiosPromise<DetailResponse> {
            return localVarFp.authVerifyMobileCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {MobileAuthRequest} mobileAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: AxiosRequestConfig): AxiosPromise<DetailResponse>;

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
     * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<CallbackTokenVerification>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyEmailCreate(options?: AxiosRequestConfig): AxiosPromise<DetailResponse>;

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyMobileCreate(options?: AxiosRequestConfig): AxiosPromise<DetailResponse>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authEmailCreate(emailAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {MobileAuthRequest} mobileAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMobileCreate(mobileAuthRequest: MobileAuthRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMobileCreate(mobileAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenCreate(callbackTokenAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This verifies an alias on correct callback token entry using the same logic as auth. Should be refactored at some point.
     * @param {CallbackTokenVerificationRequest} callbackTokenVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyCreate(callbackTokenVerificationRequest: CallbackTokenVerificationRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyCreate(callbackTokenVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyEmailCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyEmailCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyMobileCreate(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyMobileCreate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigRetreive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigRetreive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintNannyApiConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigRetreive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigRetreive(options?: any): AxiosPromise<PrintNannyApiConfig> {
            return localVarFp.apiConfigRetreive(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - interface
 * @export
 * @interface ClientApi
 */
export interface ClientApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApiInterface
     */
    apiConfigRetreive(options?: AxiosRequestConfig): AxiosPromise<PrintNannyApiConfig>;

}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI implements ClientApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public apiConfigRetreive(options?: AxiosRequestConfig) {
        return ClientApiFp(this.configuration).apiConfigRetreive(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsCreate: async (polymorphicCommandRequest?: PolymorphicCommandRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandsRetrieve', 'id', id)
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsCreate(polymorphicCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: any): AxiosPromise<PolymorphicCommand> {
            return localVarFp.commandsCreate(polymorphicCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicCommandList> {
            return localVarFp.commandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve(id: number, options?: any): AxiosPromise<PolymorphicCommand> {
            return localVarFp.commandsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - interface
 * @export
 * @interface CommandsApi
 */
export interface CommandsApiInterface {
    /**
     * Generic events viewset
     * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApiInterface
     */
    commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicCommand>;

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApiInterface
     */
    commandsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicCommandList>;

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApiInterface
     */
    commandsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PolymorphicCommand>;

}

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI implements CommandsApiInterface {
    /**
     * Generic events viewset
     * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandsCreate(polymorphicCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public commandsList(page?: number, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public commandsRetrieve(id: number, options?: AxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigRetreive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/client`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConfigRetreive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintNannyApiConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConfigRetreive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConfigRetreive(options?: any): AxiosPromise<PrintNannyApiConfig> {
            return localVarFp.apiConfigRetreive(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - interface
 * @export
 * @interface ConfigApi
 */
export interface ConfigApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApiInterface
     */
    apiConfigRetreive(options?: AxiosRequestConfig): AxiosPromise<PrintNannyApiConfig>;

}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI implements ConfigApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public apiConfigRetreive(options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).apiConfigRetreive(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudiotDeviceUpdateOrCreate: async (deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('cloudiotDeviceUpdateOrCreate', 'deviceId', deviceId)
            // verify required parameter 'cloudiotDeviceRequest' is not null or undefined
            assertParamExists('cloudiotDeviceUpdateOrCreate', 'cloudiotDeviceRequest', cloudiotDeviceRequest)
            const localVarPath = `/api/devices/{device_id}/cloudiot/update-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudiotDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotCreate: async (deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesCloudiotCreate', 'deviceId', deviceId)
            // verify required parameter 'cloudiotDeviceRequest' is not null or undefined
            assertParamExists('devicesCloudiotCreate', 'cloudiotDeviceRequest', cloudiotDeviceRequest)
            const localVarPath = `/api/devices/{device_id}/cloudiot/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudiotDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesCloudiotList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/cloudiot/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {PatchedCloudiotDeviceRequest} [patchedCloudiotDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotPartialUpdate: async (deviceId: number, id: string, patchedCloudiotDeviceRequest?: PatchedCloudiotDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesCloudiotPartialUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesCloudiotPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{device_id}/cloudiot/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCloudiotDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesCloudiotRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesCloudiotRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/cloudiot/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotUpdate: async (deviceId: number, id: string, cloudiotDeviceRequest: CloudiotDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesCloudiotUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesCloudiotUpdate', 'id', id)
            // verify required parameter 'cloudiotDeviceRequest' is not null or undefined
            assertParamExists('devicesCloudiotUpdate', 'cloudiotDeviceRequest', cloudiotDeviceRequest)
            const localVarPath = `/api/devices/{device_id}/cloudiot/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudiotDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCreate: async (deviceRequest: DeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceRequest' is not null or undefined
            assertParamExists('devicesCreate', 'deviceRequest', deviceRequest)
            const localVarPath = `/api/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamGetOrCreate: async (deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamGetOrCreate', 'deviceId', deviceId)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamGetOrCreate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/get-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsCreate: async (deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsCreate', 'deviceId', deviceId)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsCreate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusCloudStreamRequest} [patchedJanusCloudStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsPartialUpdate: async (deviceId: number, id: number, patchedJanusCloudStreamRequest?: PatchedJanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsPartialUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedJanusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsUpdate: async (deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'id', id)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamGetOrCreate: async (deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamGetOrCreate', 'deviceId', deviceId)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamGetOrCreate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/get-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsCreate: async (deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsCreate', 'deviceId', deviceId)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsCreate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusEdgeStreamRequest} [patchedJanusEdgeStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsPartialUpdate: async (deviceId: number, id: number, patchedJanusEdgeStreamRequest?: PatchedJanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsPartialUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedJanusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsUpdate: async (deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'id', id)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesOctoprintInstallsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesOctoprintInstallsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/octoprint-installs/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate: async (id: number, patchedDeviceRequest?: PatchedDeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDeviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysCreate: async (deviceId: number, publicKeyRequest: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPublicKeysCreate', 'deviceId', deviceId)
            // verify required parameter 'publicKeyRequest' is not null or undefined
            assertParamExists('devicesPublicKeysCreate', 'publicKeyRequest', publicKeyRequest)
            const localVarPath = `/api/devices/{device_id}/public-keys/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPublicKeysList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/public-keys/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PatchedPublicKeyRequest} [patchedPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysPartialUpdate: async (deviceId: number, id: number, patchedPublicKeyRequest?: PatchedPublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPublicKeysPartialUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesPublicKeysPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{device_id}/public-keys/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPublicKeysRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesPublicKeysRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/public-keys/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysUpdate: async (deviceId: number, id: number, publicKeyRequest: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesPublicKeysUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesPublicKeysUpdate', 'id', id)
            // verify required parameter 'publicKeyRequest' is not null or undefined
            assertParamExists('devicesPublicKeysUpdate', 'publicKeyRequest', publicKeyRequest)
            const localVarPath = `/api/devices/{device_id}/public-keys/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesRetrieve', 'id', id)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} hostname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieveHostname: async (hostname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('devicesRetrieveHostname', 'hostname', hostname)
            const localVarPath = `/api/devices/{hostname}`
                .replace(`{${"hostname"}}`, encodeURIComponent(String(hostname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoCreate: async (deviceId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesSystemInfoCreate', 'deviceId', deviceId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('devicesSystemInfoCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/devices/{device_id}/system-info/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesSystemInfoList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/system-info/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoPartialUpdate: async (deviceId: number, id: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesSystemInfoPartialUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesSystemInfoPartialUpdate', 'id', id)
            const localVarPath = `/api/devices/{device_id}/system-info/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSystemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesSystemInfoRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesSystemInfoRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/system-info/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoUpdate: async (deviceId: number, id: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesSystemInfoUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesSystemInfoUpdate', 'id', id)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('devicesSystemInfoUpdate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/devices/{device_id}/system-info/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} [deviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate: async (id: number, deviceRequest?: DeviceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesUpdate', 'id', id)
            const localVarPath = `/api/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeyUpdateOrCreate: async (deviceId: number, publicKeyRequest: PublicKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('publicKeyUpdateOrCreate', 'deviceId', deviceId)
            // verify required parameter 'publicKeyRequest' is not null or undefined
            assertParamExists('publicKeyUpdateOrCreate', 'publicKeyRequest', publicKeyRequest)
            const localVarPath = `/api/devices/{device_id}/public-keys/update-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate: async (deviceId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'deviceId', deviceId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/devices/{device_id}/system-info/update-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudiotDeviceUpdateOrCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudiotDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudiotDeviceUpdateOrCreate(deviceId, cloudiotDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCloudiotCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudiotDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCloudiotCreate(deviceId, cloudiotDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCloudiotList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCloudiotDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCloudiotList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {PatchedCloudiotDeviceRequest} [patchedCloudiotDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCloudiotPartialUpdate(deviceId: number, id: string, patchedCloudiotDeviceRequest?: PatchedCloudiotDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudiotDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCloudiotPartialUpdate(deviceId, id, patchedCloudiotDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCloudiotRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudiotDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCloudiotRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCloudiotUpdate(deviceId: number, id: string, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCloudiotUpdate(deviceId, id, cloudiotDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCreate(deviceRequest: DeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesCreate(deviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusCloudStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusCloudStreamRequest} [patchedJanusCloudStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsPartialUpdate(deviceId: number, id: number, patchedJanusCloudStreamRequest?: PatchedJanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsPartialUpdate(deviceId, id, patchedJanusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusEdgeStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusEdgeStreamRequest} [patchedJanusEdgeStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsPartialUpdate(deviceId: number, id: number, patchedJanusEdgeStreamRequest?: PatchedJanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsPartialUpdate(deviceId, id, patchedJanusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedDeviceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesOctoprintInstallsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintInstallList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesOctoprintInstallsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPartialUpdate(id, patchedDeviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPublicKeysCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPublicKeysCreate(deviceId, publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPublicKeysList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPublicKeyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPublicKeysList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PatchedPublicKeyRequest} [patchedPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPublicKeysPartialUpdate(deviceId: number, id: number, patchedPublicKeyRequest?: PatchedPublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPublicKeysPartialUpdate(deviceId, id, patchedPublicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPublicKeysRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPublicKeysRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesPublicKeysUpdate(deviceId: number, id: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesPublicKeysUpdate(deviceId, id, publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} hostname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRetrieveHostname(hostname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesRetrieveHostname(hostname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSystemInfoCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSystemInfoCreate(deviceId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSystemInfoList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSystemInfoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSystemInfoList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSystemInfoPartialUpdate(deviceId: number, id: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSystemInfoPartialUpdate(deviceId, id, patchedSystemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSystemInfoRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSystemInfoRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSystemInfoUpdate(deviceId: number, id: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesSystemInfoUpdate(deviceId, id, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} [deviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdate(id: number, deviceRequest?: DeviceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesUpdate(id, deviceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeyUpdateOrCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeyUpdateOrCreate(deviceId, publicKeyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfoUpdateOrCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfoUpdateOrCreate(deviceId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudiotDeviceUpdateOrCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: any): AxiosPromise<CloudiotDevice> {
            return localVarFp.cloudiotDeviceUpdateOrCreate(deviceId, cloudiotDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: any): AxiosPromise<CloudiotDevice> {
            return localVarFp.devicesCloudiotCreate(deviceId, cloudiotDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedCloudiotDeviceList> {
            return localVarFp.devicesCloudiotList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {PatchedCloudiotDeviceRequest} [patchedCloudiotDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotPartialUpdate(deviceId: number, id: string, patchedCloudiotDeviceRequest?: PatchedCloudiotDeviceRequest, options?: any): AxiosPromise<CloudiotDevice> {
            return localVarFp.devicesCloudiotPartialUpdate(deviceId, id, patchedCloudiotDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<CloudiotDevice> {
            return localVarFp.devicesCloudiotRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {string} id 
         * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCloudiotUpdate(deviceId: number, id: string, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.devicesCloudiotUpdate(deviceId, id, cloudiotDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {DeviceRequest} deviceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCreate(deviceRequest: DeviceRequest, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesCreate(deviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusCloudStreamList> {
            return localVarFp.devicesJanusCloudStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusCloudStreamRequest} [patchedJanusCloudStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsPartialUpdate(deviceId: number, id: number, patchedJanusCloudStreamRequest?: PatchedJanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsPartialUpdate(deviceId, id, patchedJanusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusEdgeStreamList> {
            return localVarFp.devicesJanusEdgeStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {PatchedJanusEdgeStreamRequest} [patchedJanusEdgeStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsPartialUpdate(deviceId: number, id: number, patchedJanusEdgeStreamRequest?: PatchedJanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsPartialUpdate(deviceId, id, patchedJanusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusStreamList> {
            return localVarFp.devicesJanusStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusStream> {
            return localVarFp.devicesJanusStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesList(page?: number, options?: any): AxiosPromise<PaginatedDeviceList> {
            return localVarFp.devicesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesOctoprintInstallsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedOctoPrintInstallList> {
            return localVarFp.devicesOctoprintInstallsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesPartialUpdate(id, patchedDeviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.devicesPublicKeysCreate(deviceId, publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedPublicKeyList> {
            return localVarFp.devicesPublicKeysList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PatchedPublicKeyRequest} [patchedPublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysPartialUpdate(deviceId: number, id: number, patchedPublicKeyRequest?: PatchedPublicKeyRequest, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.devicesPublicKeysPartialUpdate(deviceId, id, patchedPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.devicesPublicKeysRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this public key.
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesPublicKeysUpdate(deviceId: number, id: number, publicKeyRequest: PublicKeyRequest, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.devicesPublicKeysUpdate(deviceId, id, publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieve(id: number, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} hostname 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRetrieveHostname(hostname: string, options?: any): AxiosPromise<Device> {
            return localVarFp.devicesRetrieveHostname(hostname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.devicesSystemInfoCreate(deviceId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedSystemInfoList> {
            return localVarFp.devicesSystemInfoList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoPartialUpdate(deviceId: number, id: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.devicesSystemInfoPartialUpdate(deviceId, id, patchedSystemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.devicesSystemInfoRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this system info.
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSystemInfoUpdate(deviceId: number, id: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.devicesSystemInfoUpdate(deviceId, id, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this device.
         * @param {DeviceRequest} [deviceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdate(id: number, deviceRequest?: DeviceRequest, options?: any): AxiosPromise<void> {
            return localVarFp.devicesUpdate(id, deviceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {PublicKeyRequest} publicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeyUpdateOrCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.publicKeyUpdateOrCreate(deviceId, publicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.systemInfoUpdateOrCreate(deviceId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - interface
 * @export
 * @interface DevicesApi
 */
export interface DevicesApiInterface {
    /**
     * 
     * @param {number} deviceId 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    cloudiotDeviceUpdateOrCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<CloudiotDevice>;

    /**
     * 
     * @param {number} deviceId 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCloudiotCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<CloudiotDevice>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCloudiotList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedCloudiotDeviceList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {string} id 
     * @param {PatchedCloudiotDeviceRequest} [patchedCloudiotDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCloudiotPartialUpdate(deviceId: number, id: string, patchedCloudiotDeviceRequest?: PatchedCloudiotDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<CloudiotDevice>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCloudiotRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<CloudiotDevice>;

    /**
     * 
     * @param {number} deviceId 
     * @param {string} id 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCloudiotUpdate(deviceId: number, id: string, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesCreate(deviceRequest: DeviceRequest, options?: AxiosRequestConfig): AxiosPromise<Device>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusCloudStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {PatchedJanusCloudStreamRequest} [patchedJanusCloudStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamsPartialUpdate(deviceId: number, id: number, patchedJanusCloudStreamRequest?: PatchedJanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusEdgeStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {PatchedJanusEdgeStreamRequest} [patchedJanusEdgeStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamsPartialUpdate(deviceId: number, id: number, patchedJanusEdgeStreamRequest?: PatchedJanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusStream>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedDeviceList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesOctoprintInstallsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintInstallList>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: AxiosRequestConfig): AxiosPromise<Device>;

    /**
     * 
     * @param {number} deviceId 
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPublicKeysCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPublicKeysList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPublicKeyList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {PatchedPublicKeyRequest} [patchedPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPublicKeysPartialUpdate(deviceId: number, id: number, patchedPublicKeyRequest?: PatchedPublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPublicKeysRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesPublicKeysUpdate(deviceId: number, id: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Device>;

    /**
     * 
     * @param {string} hostname 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesRetrieveHostname(hostname: string, options?: AxiosRequestConfig): AxiosPromise<Device>;

    /**
     * 
     * @param {number} deviceId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesSystemInfoCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesSystemInfoList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedSystemInfoList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesSystemInfoPartialUpdate(deviceId: number, id: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesSystemInfoRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesSystemInfoUpdate(deviceId: number, id: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {DeviceRequest} [deviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    devicesUpdate(id: number, deviceRequest?: DeviceRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {number} deviceId 
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    publicKeyUpdateOrCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @param {number} deviceId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    systemInfoUpdateOrCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI implements DevicesApiInterface {
    /**
     * 
     * @param {number} deviceId 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public cloudiotDeviceUpdateOrCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).cloudiotDeviceUpdateOrCreate(deviceId, cloudiotDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCloudiotCreate(deviceId: number, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCloudiotCreate(deviceId, cloudiotDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCloudiotList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCloudiotList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {string} id 
     * @param {PatchedCloudiotDeviceRequest} [patchedCloudiotDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCloudiotPartialUpdate(deviceId: number, id: string, patchedCloudiotDeviceRequest?: PatchedCloudiotDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCloudiotPartialUpdate(deviceId, id, patchedCloudiotDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCloudiotRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCloudiotRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {string} id 
     * @param {CloudiotDeviceRequest} cloudiotDeviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCloudiotUpdate(deviceId: number, id: string, cloudiotDeviceRequest: CloudiotDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCloudiotUpdate(deviceId, id, cloudiotDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {DeviceRequest} deviceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesCreate(deviceRequest: DeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesCreate(deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {PatchedJanusCloudStreamRequest} [patchedJanusCloudStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamsPartialUpdate(deviceId: number, id: number, patchedJanusCloudStreamRequest?: PatchedJanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamsPartialUpdate(deviceId, id, patchedJanusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {PatchedJanusEdgeStreamRequest} [patchedJanusEdgeStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamsPartialUpdate(deviceId: number, id: number, patchedJanusEdgeStreamRequest?: PatchedJanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamsPartialUpdate(deviceId, id, patchedJanusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesJanusStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesList(page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesOctoprintInstallsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesOctoprintInstallsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {PatchedDeviceRequest} [patchedDeviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPartialUpdate(id: number, patchedDeviceRequest?: PatchedDeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPartialUpdate(id, patchedDeviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPublicKeysCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPublicKeysCreate(deviceId, publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPublicKeysList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPublicKeysList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {PatchedPublicKeyRequest} [patchedPublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPublicKeysPartialUpdate(deviceId: number, id: number, patchedPublicKeyRequest?: PatchedPublicKeyRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPublicKeysPartialUpdate(deviceId, id, patchedPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPublicKeysRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPublicKeysRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this public key.
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesPublicKeysUpdate(deviceId: number, id: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesPublicKeysUpdate(deviceId, id, publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesRetrieve(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} hostname 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesRetrieveHostname(hostname: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesRetrieveHostname(hostname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesSystemInfoCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSystemInfoCreate(deviceId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesSystemInfoList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSystemInfoList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesSystemInfoPartialUpdate(deviceId: number, id: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSystemInfoPartialUpdate(deviceId, id, patchedSystemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesSystemInfoRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSystemInfoRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this system info.
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesSystemInfoUpdate(deviceId: number, id: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesSystemInfoUpdate(deviceId, id, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this device.
     * @param {DeviceRequest} [deviceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public devicesUpdate(id: number, deviceRequest?: DeviceRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).devicesUpdate(id, deviceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {PublicKeyRequest} publicKeyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public publicKeyUpdateOrCreate(deviceId: number, publicKeyRequest: PublicKeyRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).publicKeyUpdateOrCreate(deviceId, publicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public systemInfoUpdateOrCreate(deviceId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).systemInfoUpdateOrCreate(deviceId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsCreate: async (polymorphicCommandRequest?: PolymorphicCommandRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicCommandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/commands/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandsRetrieve', 'id', id)
            const localVarPath = `/api/commands/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {PolymorphicEventRequest} [polymorphicEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate: async (polymorphicEventRequest?: PolymorphicEventRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(polymorphicEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/events/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsRetrieve', 'id', id)
            const localVarPath = `/api/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsCreate(polymorphicCommandRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicCommandList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicCommand>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {PolymorphicEventRequest} [polymorphicEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsCreate(polymorphicEventRequest?: PolymorphicEventRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsCreate(polymorphicEventRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPolymorphicEventList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolymorphicEvent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Generic events viewset
         * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: any): AxiosPromise<PolymorphicCommand> {
            return localVarFp.commandsCreate(polymorphicCommandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicCommandList> {
            return localVarFp.commandsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandsRetrieve(id: number, options?: any): AxiosPromise<PolymorphicCommand> {
            return localVarFp.commandsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {PolymorphicEventRequest} [polymorphicEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(polymorphicEventRequest?: PolymorphicEventRequest, options?: any): AxiosPromise<PolymorphicEvent> {
            return localVarFp.eventsCreate(polymorphicEventRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(page?: number, options?: any): AxiosPromise<PaginatedPolymorphicEventList> {
            return localVarFp.eventsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Generic events viewset
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRetrieve(id: number, options?: any): AxiosPromise<PolymorphicEvent> {
            return localVarFp.eventsRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * Generic events viewset
     * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicCommand>;

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    commandsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicCommandList>;

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    commandsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PolymorphicCommand>;

    /**
     * Generic events viewset
     * @param {PolymorphicEventRequest} [polymorphicEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    eventsCreate(polymorphicEventRequest?: PolymorphicEventRequest, options?: AxiosRequestConfig): AxiosPromise<PolymorphicEvent>;

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    eventsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPolymorphicEventList>;

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    eventsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<PolymorphicEvent>;

}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * Generic events viewset
     * @param {PolymorphicCommandRequest} [polymorphicCommandRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public commandsCreate(polymorphicCommandRequest?: PolymorphicCommandRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).commandsCreate(polymorphicCommandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public commandsList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).commandsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public commandsRetrieve(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).commandsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {PolymorphicEventRequest} [polymorphicEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsCreate(polymorphicEventRequest?: PolymorphicEventRequest, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsCreate(polymorphicEventRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsList(page?: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generic events viewset
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsRetrieve(id: number, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JanusApi - axios parameter creator
 * @export
 */
export const JanusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamGetOrCreate: async (deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamGetOrCreate', 'deviceId', deviceId)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamGetOrCreate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/get-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsCreate: async (deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsCreate', 'deviceId', deviceId)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsCreate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsUpdate: async (deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'id', id)
            // verify required parameter 'janusCloudStreamRequest' is not null or undefined
            assertParamExists('devicesJanusCloudStreamsUpdate', 'janusCloudStreamRequest', janusCloudStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-cloud-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusCloudStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamGetOrCreate: async (deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamGetOrCreate', 'deviceId', deviceId)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamGetOrCreate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/get-or-create/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsCreate: async (deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsCreate', 'deviceId', deviceId)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsCreate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsUpdate: async (deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'id', id)
            // verify required parameter 'janusEdgeStreamRequest' is not null or undefined
            assertParamExists('devicesJanusEdgeStreamsUpdate', 'janusEdgeStreamRequest', janusEdgeStreamRequest)
            const localVarPath = `/api/devices/{device_id}/janus-edge-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusEdgeStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsList: async (deviceId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusStreamsList', 'deviceId', deviceId)
            const localVarPath = `/api/devices/{device_id}/janus-streams/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsRetrieve: async (deviceId: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('devicesJanusStreamsRetrieve', 'deviceId', deviceId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('devicesJanusStreamsRetrieve', 'id', id)
            const localVarPath = `/api/devices/{device_id}/janus-streams/{id}/`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthCreate: async (userId: number, janusAuthRequest: JanusAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthCreate', 'userId', userId)
            // verify required parameter 'janusAuthRequest' is not null or undefined
            assertParamExists('usersJanusAuthCreate', 'janusAuthRequest', janusAuthRequest)
            const localVarPath = `/api/users/{user_id}/janus-auth/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthList: async (userId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthList', 'userId', userId)
            const localVarPath = `/api/users/{user_id}/janus-auth/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthRetrieve: async (id: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersJanusAuthRetrieve', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthRetrieve', 'userId', userId)
            const localVarPath = `/api/users/{user_id}/janus-auth/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthUpdateOrCreate: async (userId: number, janusAuthRequest: JanusAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthUpdateOrCreate', 'userId', userId)
            // verify required parameter 'janusAuthRequest' is not null or undefined
            assertParamExists('usersJanusAuthUpdateOrCreate', 'janusAuthRequest', janusAuthRequest)
            const localVarPath = `/api/users/{user_id}/janus-auth/update-or-create/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JanusApi - functional programming interface
 * @export
 */
export const JanusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JanusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusCloudStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusCloudStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusEdgeStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusEdgeStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusStreamsList(deviceId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.devicesJanusStreamsRetrieve(deviceId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthCreate(userId, janusAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusAuthList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthList(userId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthRetrieve(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JanusApi - factory interface
 * @export
 */
export const JanusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JanusApiFp(configuration)
    return {
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusCloudStreamList> {
            return localVarFp.devicesJanusCloudStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: any): AxiosPromise<JanusCloudStream> {
            return localVarFp.devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusEdgeStreamList> {
            return localVarFp.devicesJanusEdgeStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: any): AxiosPromise<JanusEdgeStream> {
            return localVarFp.devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsList(deviceId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusStreamList> {
            return localVarFp.devicesJanusStreamsList(deviceId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} deviceId 
         * @param {number} id A unique integer value identifying this janus stream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: any): AxiosPromise<JanusStream> {
            return localVarFp.devicesJanusStreamsRetrieve(deviceId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthCreate(userId, janusAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthList(userId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusAuthList> {
            return localVarFp.usersJanusAuthList(userId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthRetrieve(id: number, userId: number, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthRetrieve(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JanusApi - interface
 * @export
 * @interface JanusApi
 */
export interface JanusApiInterface {
    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusCloudStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusCloudStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusEdgeStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig): AxiosPromise<JanusEdgeStream>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusStreamList>;

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig): AxiosPromise<JanusStream>;

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

    /**
     * 
     * @param {number} userId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusAuthList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this janus auth.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

}

/**
 * JanusApi - object-oriented interface
 * @export
 * @class JanusApi
 * @extends {BaseAPI}
 */
export class JanusApi extends BaseAPI implements JanusApiInterface {
    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusCloudStreamGetOrCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusCloudStreamGetOrCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusCloudStreamsCreate(deviceId: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusCloudStreamsCreate(deviceId, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusCloudStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusCloudStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusCloudStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusCloudStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusCloudStreamRequest} janusCloudStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusCloudStreamsUpdate(deviceId: number, id: number, janusCloudStreamRequest: JanusCloudStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusCloudStreamsUpdate(deviceId, id, janusCloudStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusEdgeStreamGetOrCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusEdgeStreamGetOrCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusEdgeStreamsCreate(deviceId: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusEdgeStreamsCreate(deviceId, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusEdgeStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusEdgeStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusEdgeStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusEdgeStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {JanusEdgeStreamRequest} janusEdgeStreamRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusEdgeStreamsUpdate(deviceId: number, id: number, janusEdgeStreamRequest: JanusEdgeStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusEdgeStreamsUpdate(deviceId, id, janusEdgeStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusStreamsList(deviceId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusStreamsList(deviceId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} deviceId 
     * @param {number} id A unique integer value identifying this janus stream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public devicesJanusStreamsRetrieve(deviceId: number, id: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).devicesJanusStreamsRetrieve(deviceId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).usersJanusAuthCreate(userId, janusAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).usersJanusAuthList(userId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this janus auth.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).usersJanusAuthRetrieve(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OctoprintApi - axios parameter creator
 * @export
 */
export const OctoprintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate: async (hostname: string, name: string, octoprintVersion: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'hostname', hostname)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'name', name)
            // verify required parameter 'octoprintVersion' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'octoprintVersion', octoprintVersion)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'file', file)
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (hostname !== undefined) { 
                localVarFormParams.append('hostname', hostname as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (octoprintVersion !== undefined) { 
                localVarFormParams.append('octoprint_version', octoprintVersion as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintBackupsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/backups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate: async (name: string, file: any, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'file', file)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'hash', hash)
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (hash !== undefined) { 
                localVarFormParams.append('hash', hash as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintGcodeFilesRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallUpdateOrCreate: async (octoPrintInstallRequest: OctoPrintInstallRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintInstallRequest' is not null or undefined
            assertParamExists('octoprintInstallUpdateOrCreate', 'octoPrintInstallRequest', octoPrintInstallRequest)
            const localVarPath = `/api/octoprint/installs/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintInstallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsCreate: async (octoPrintInstallRequest: OctoPrintInstallRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintInstallRequest' is not null or undefined
            assertParamExists('octoprintInstallsCreate', 'octoPrintInstallRequest', octoPrintInstallRequest)
            const localVarPath = `/api/octoprint/installs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintInstallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/installs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {PatchedOctoPrintInstallRequest} [patchedOctoPrintInstallRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsPartialUpdate: async (id: number, patchedOctoPrintInstallRequest?: PatchedOctoPrintInstallRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintInstallsPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/installs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintInstallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsUpdate: async (id: number, octoPrintInstallRequest: OctoPrintInstallRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintInstallsUpdate', 'id', id)
            // verify required parameter 'octoPrintInstallRequest' is not null or undefined
            assertParamExists('octoprintInstallsUpdate', 'octoPrintInstallRequest', octoPrintInstallRequest)
            const localVarPath = `/api/octoprint/installs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintInstallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate: async (id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate: async (id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'id', id)
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintProfileUpdateOrCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate: async (octoPrintSettingsRequest?: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate: async (id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate: async (id: number, octoPrintSettingsRequest?: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsUpdate', 'id', id)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate: async (octoPrintSettingsRequest?: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/settings/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OctoprintApi - functional programming interface
 * @export
 */
export const OctoprintApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OctoprintApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintBackupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesCreate(name, file, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGcodeFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintInstallUpdateOrCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintInstall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintInstallUpdateOrCreate(octoPrintInstallRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintInstallsCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintInstall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintInstallsCreate(octoPrintInstallRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintInstallsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintInstallList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintInstallsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {PatchedOctoPrintInstallRequest} [patchedOctoPrintInstallRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintInstallsPartialUpdate(id: number, patchedOctoPrintInstallRequest?: PatchedOctoPrintInstallRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintInstall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintInstallsPartialUpdate(id, patchedOctoPrintInstallRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintInstallsUpdate(id: number, octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintInstallsUpdate(id, octoPrintInstallRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrinterProfileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdate(id: number, octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OctoprintApi - factory interface
 * @export
 */
export const OctoprintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OctoprintApiFp(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintBackupList> {
            return localVarFp.octoprintBackupsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList> {
            return localVarFp.octoprintGcodeFilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve(id: number, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallUpdateOrCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: any): AxiosPromise<OctoPrintInstall> {
            return localVarFp.octoprintInstallUpdateOrCreate(octoPrintInstallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: any): AxiosPromise<OctoPrintInstall> {
            return localVarFp.octoprintInstallsCreate(octoPrintInstallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintInstallList> {
            return localVarFp.octoprintInstallsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {PatchedOctoPrintInstallRequest} [patchedOctoPrintInstallRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsPartialUpdate(id: number, patchedOctoPrintInstallRequest?: PatchedOctoPrintInstallRequest, options?: any): AxiosPromise<OctoPrintInstall> {
            return localVarFp.octoprintInstallsPartialUpdate(id, patchedOctoPrintInstallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print install.
         * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintInstallsUpdate(id: number, octoPrintInstallRequest: OctoPrintInstallRequest, options?: any): AxiosPromise<void> {
            return localVarFp.octoprintInstallsUpdate(id, octoPrintInstallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrinterProfileList> {
            return localVarFp.octoprintPrinterProfilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<void> {
            return localVarFp.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintSettingsList> {
            return localVarFp.octoprintSettingsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate(id: number, octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: any): AxiosPromise<void> {
            return localVarFp.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OctoprintApi - interface
 * @export
 * @interface OctoprintApi
 */
export interface OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintBackupList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedGcodeFileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintInstallUpdateOrCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintInstall>;

    /**
     * 
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintInstallsCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintInstall>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintInstallsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintInstallList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print install.
     * @param {PatchedOctoPrintInstallRequest} [patchedOctoPrintInstallRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintInstallsPartialUpdate(id: number, patchedOctoPrintInstallRequest?: PatchedOctoPrintInstallRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintInstall>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print install.
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintInstallsUpdate(id: number, octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrinterProfileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdate(id: number, octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

}

/**
 * OctoprintApi - object-oriented interface
 * @export
 * @class OctoprintApi
 * @extends {BaseAPI}
 */
export class OctoprintApi extends BaseAPI implements OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintInstallUpdateOrCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintInstallUpdateOrCreate(octoPrintInstallRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintInstallsCreate(octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintInstallsCreate(octoPrintInstallRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintInstallsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintInstallsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print install.
     * @param {PatchedOctoPrintInstallRequest} [patchedOctoPrintInstallRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintInstallsPartialUpdate(id: number, patchedOctoPrintInstallRequest?: PatchedOctoPrintInstallRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintInstallsPartialUpdate(id, patchedOctoPrintInstallRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print install.
     * @param {OctoPrintInstallRequest} octoPrintInstallRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintInstallsUpdate(id: number, octoPrintInstallRequest: OctoPrintInstallRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintInstallsUpdate(id, octoPrintInstallRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdate(id: number, octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} [octoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest?: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartnersGeeks3dApi - axios parameter creator
 * @export
 */
export const PartnersGeeks3dApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList2: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsList2', 'id', id)
            const localVarPath = `/api/partners/3d-geeks/{id}/alerts/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('metadataRetrieve', 'id', id)
            const localVarPath = `/api/partners/3d-geeks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnersGeeks3dApi - functional programming interface
 * @export
 */
export const PartnersGeeks3dApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnersGeeks3dApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsList2(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner3DGeeksAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsList2(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadataRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Partner3DGeeksMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadataRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartnersGeeks3dApi - factory interface
 * @export
 */
export const PartnersGeeks3dApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnersGeeks3dApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsList2(id: string, options?: any): AxiosPromise<Partner3DGeeksAlert> {
            return localVarFp.alertsList2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 3D Geeks calls this endpoint to validate token & fetch printer metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRetrieve(id: string, options?: any): AxiosPromise<Partner3DGeeksMetadata> {
            return localVarFp.metadataRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnersGeeks3dApi - interface
 * @export
 * @interface PartnersGeeks3dApi
 */
export interface PartnersGeeks3dApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApiInterface
     */
    alertsList2(id: string, options?: AxiosRequestConfig): AxiosPromise<Partner3DGeeksAlert>;

    /**
     * 3D Geeks calls this endpoint to validate token & fetch printer metadata
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApiInterface
     */
    metadataRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Partner3DGeeksMetadata>;

}

/**
 * PartnersGeeks3dApi - object-oriented interface
 * @export
 * @class PartnersGeeks3dApi
 * @extends {BaseAPI}
 */
export class PartnersGeeks3dApi extends BaseAPI implements PartnersGeeks3dApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApi
     */
    public alertsList2(id: string, options?: AxiosRequestConfig) {
        return PartnersGeeks3dApiFp(this.configuration).alertsList2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 3D Geeks calls this endpoint to validate token & fetch printer metadata
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartnersGeeks3dApi
     */
    public metadataRetrieve(id: string, options?: AxiosRequestConfig) {
        return PartnersGeeks3dApiFp(this.configuration).metadataRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthCreate: async (userId: number, janusAuthRequest: JanusAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthCreate', 'userId', userId)
            // verify required parameter 'janusAuthRequest' is not null or undefined
            assertParamExists('usersJanusAuthCreate', 'janusAuthRequest', janusAuthRequest)
            const localVarPath = `/api/users/{user_id}/janus-auth/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthList: async (userId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthList', 'userId', userId)
            const localVarPath = `/api/users/{user_id}/janus-auth/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthRetrieve: async (id: number, userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersJanusAuthRetrieve', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthRetrieve', 'userId', userId)
            const localVarPath = `/api/users/{user_id}/janus-auth/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthUpdateOrCreate: async (userId: number, janusAuthRequest: JanusAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersJanusAuthUpdateOrCreate', 'userId', userId)
            // verify required parameter 'janusAuthRequest' is not null or undefined
            assertParamExists('usersJanusAuthUpdateOrCreate', 'janusAuthRequest', janusAuthRequest)
            const localVarPath = `/api/users/{user_id}/janus-auth/update-or-create/`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(janusAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUserRequest?: PatchedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('usersUpdate', 'userRequest', userRequest)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthCreate(userId, janusAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedJanusAuthList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthList(userId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthRetrieve(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JanusAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthCreate(userId, janusAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthList(userId: number, page?: number, options?: any): AxiosPromise<PaginatedJanusAuthList> {
            return localVarFp.usersJanusAuthList(userId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this janus auth.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthRetrieve(id: number, userId: number, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthRetrieve(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {JanusAuthRequest} janusAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: any): AxiosPromise<JanusAuth> {
            return localVarFp.usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: any): AxiosPromise<User> {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, userRequest: UserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
export interface UsersApiInterface {
    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

    /**
     * 
     * @param {number} userId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedJanusAuthList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this janus auth.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig): AxiosPromise<JanusAuth>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersMeRetrieve(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    usersUpdate(id: number, userRequest: UserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersJanusAuthCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersJanusAuthCreate(userId, janusAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersJanusAuthList(userId: number, page?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersJanusAuthList(userId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this janus auth.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersJanusAuthRetrieve(id: number, userId: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersJanusAuthRetrieve(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {JanusAuthRequest} janusAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersJanusAuthUpdateOrCreate(userId: number, janusAuthRequest: JanusAuthRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersJanusAuthUpdateOrCreate(userId, janusAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, userRequest: UserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


