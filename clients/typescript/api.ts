/* tslint:disable */
/* eslint-disable */
/**
 * printnanny-api-client
 * Official API client library for printnanny.ai
 *
 * The version of the OpenAPI document: 0.134.2
 * Contact: leigh@printnanny.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Achievement
 */
export interface Achievement {
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'created_dt': string;
    /**
     * 
     * @type {AchievementTypeEnum}
     * @memberof Achievement
     */
    'type': AchievementTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    'user': number;
}
/**
 * * `FreeBeta` - Participated in free beta program * `FoundingMember` - Supported PrintNanny by pre-ordering an annual subscription * `Cloud Starter` - Subscribed to PrintNanny Cloud Starter plan * `Cloud Scaler` - Subscribed to PrintNanny Cloud Scaler plan
 * @export
 * @enum {string}
 */

export const AchievementTypeEnum = {
    FreeBeta: 'FreeBeta',
    FoundingMember: 'FoundingMember',
    CloudStarter: 'Cloud Starter',
    CloudScaler: 'Cloud Scaler'
} as const;

export type AchievementTypeEnum = typeof AchievementTypeEnum[keyof typeof AchievementTypeEnum];


/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuth
 */
export interface CallbackTokenAuth {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuth
     */
    'token': string;
}
/**
 * Abstract class inspired by DRF\'s own token serializer. Returns a user if valid, None or a message if not.
 * @export
 * @interface CallbackTokenAuthRequest
 */
export interface CallbackTokenAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof CallbackTokenAuthRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CameraSnapshot
 */
export interface CameraSnapshot {
    /**
     * 
     * @type {string}
     * @memberof CameraSnapshot
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CameraSnapshot
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CameraSnapshot
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof CameraSnapshot
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface CrashReport
 */
export interface CrashReport {
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'os_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'os_logs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'browser_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'browser_logs'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'serial'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'posthog_session'?: string | null;
    /**
     * 
     * @type {CrashReportStatusEnum}
     * @memberof CrashReport
     */
    'status'?: CrashReportStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CrashReport
     */
    'support_comment'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CrashReport
     */
    'user': number | null;
    /**
     * 
     * @type {number}
     * @memberof CrashReport
     */
    'pi'?: number | null;
}
/**
 * * `Investigating` - Your report is being investigated, thank you! * `Fixed` - A fix for your issue has been released. Please submit another crash report if the problem persists.
 * @export
 * @enum {string}
 */

export const CrashReportStatusEnum = {
    Investigating: 'Investigating',
    Fixed: 'Fixed'
} as const;

export type CrashReportStatusEnum = typeof CrashReportStatusEnum[keyof typeof CrashReportStatusEnum];


/**
 * * `pass` - Submission received positive (thumbs up) feedback * `fail` - Submission received negative (thumbs down) feedback * `na` - Submission received N/A (not applicable)
 * @export
 * @enum {string}
 */

export const DemoFeedbackEnum = {
    Pass: 'pass',
    Fail: 'fail',
    Na: 'na'
} as const;

export type DemoFeedbackEnum = typeof DemoFeedbackEnum[keyof typeof DemoFeedbackEnum];


/**
 * 
 * @export
 * @interface DemoSubmission
 */
export interface DemoSubmission {
    /**
     * 
     * @type {string}
     * @memberof DemoSubmission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DemoSubmission
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof DemoSubmission
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof DemoSubmission
     */
    'submission': string;
    /**
     * 
     * @type {string}
     * @memberof DemoSubmission
     */
    'result': string;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmission
     */
    'feedback_nozzle': DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmission
     */
    'feedback_adhesion': DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmission
     */
    'feedback_spaghetti': DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmission
     */
    'feedback_print': DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmission
     */
    'feedback_raft': DemoFeedbackEnum | null;
}
/**
 * 
 * @export
 * @interface DemoSubmissionFeedbackRequest
 */
export interface DemoSubmissionFeedbackRequest {
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmissionFeedbackRequest
     */
    'feedback_nozzle'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmissionFeedbackRequest
     */
    'feedback_adhesion'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmissionFeedbackRequest
     */
    'feedback_spaghetti'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmissionFeedbackRequest
     */
    'feedback_print'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof DemoSubmissionFeedbackRequest
     */
    'feedback_raft'?: DemoFeedbackEnum | null;
}
/**
 * 
 * @export
 * @interface DjStripeCharge
 */
export interface DjStripeCharge {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCharge
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeApiErrorCode}
     * @memberof DjStripeCharge
     */
    'failure_code': StripeApiErrorCode;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCharge
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'description'?: string | null;
    /**
     * Amount charged (as decimal).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount': string;
    /**
     * Amount (as decimal) captured (can be less than the amount attribute on the charge if a partial capture was issued).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount_captured'?: string | null;
    /**
     * Amount (as decimal) refunded (can be less than the amount attribute on the charge if a partial refund was issued).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'amount_refunded': string;
    /**
     * ID of the Connect application that created the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application'?: string;
    /**
     * The amount (as decimal) of the application fee (if any) requested for the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application_fee_amount'?: string | null;
    /**
     * Billing information associated with the PaymentMethod at the time of the transaction.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'billing_details'?: { [key: string]: any; } | null;
    /**
     * The full statement descriptor that is passed to card networks, and that is displayed on your customers\' credit card and bank statements. Allows you to see what the statement descriptor looks like after the static and dynamic portions are combined.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'calculated_statement_descriptor'?: string;
    /**
     * If the charge was created without capturing, this boolean represents whether or not it is still uncaptured or has since been captured.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'captured'?: boolean;
    /**
     * The currency in which the charge was made.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'currency': string;
    /**
     * Whether the charge has been disputed.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'disputed'?: boolean;
    /**
     * Message to user further explaining reason for charge failure if available.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'failure_message'?: string;
    /**
     * Hash with information on fraud assessments for the charge.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'fraud_details'?: { [key: string]: any; } | null;
    /**
     * Details about whether or not the payment was accepted, and why.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'outcome'?: { [key: string]: any; } | null;
    /**
     * True if the charge succeeded, or was successfully authorized for later capture, False otherwise.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'paid'?: boolean;
    /**
     * Details about the payment method at the time of the transaction.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'payment_method_details'?: { [key: string]: any; } | null;
    /**
     * The email address that the receipt for this charge was sent to.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_email'?: string;
    /**
     * The transaction number that appears on email receipts sent for this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_number'?: string;
    /**
     * This is the URL to view the receipt for this charge. The receipt is kept up-to-date to the latest state of the charge, including any refunds. If the charge is for an Invoice, the receipt will be stylized as an Invoice receipt.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'receipt_url'?: string;
    /**
     * Whether or not the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
     * @type {boolean}
     * @memberof DjStripeCharge
     */
    'refunded'?: boolean;
    /**
     * Shipping information for the charge
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * For card charges, use statement_descriptor_suffix instead. Otherwise, you can use this value as the complete description of a charge on your customers\' statements. Must contain at least one letter, maximum 22 characters.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'statement_descriptor'?: string | null;
    /**
     * Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that\'s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'statement_descriptor_suffix'?: string | null;
    /**
     * The status of the payment.  * `failed` - Failed * `pending` - Pending * `succeeded` - Succeeded
     * @type {StripeSourceCodeVerificationStatus}
     * @memberof DjStripeCharge
     */
    'status': StripeSourceCodeVerificationStatus;
    /**
     * An optional dictionary including the account to automatically transfer to as part of a destination charge.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCharge
     */
    'transfer_data'?: { [key: string]: any; } | null;
    /**
     * A string that identifies this transaction as part of a group.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'transfer_group'?: string | null;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'djstripe_owner_account'?: string | null;
    /**
     * The application fee (if any) for the charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'application_fee'?: string | null;
    /**
     * The balance transaction that describes the impact of this charge on your account balance (not including refunds or disputes).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'balance_transaction'?: string | null;
    /**
     * The customer associated with this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'customer'?: string | null;
    /**
     * Details about the dispute if the charge has been disputed.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'dispute'?: string | null;
    /**
     * The invoice this charge is for if one exists.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'invoice'?: string | null;
    /**
     * The account (if any) the charge was made on behalf of without triggering an automatic transfer.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'on_behalf_of'?: string | null;
    /**
     * PaymentIntent associated with this charge, if one exists.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'payment_intent'?: string | null;
    /**
     * PaymentMethod used in this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'payment_method'?: string | null;
    /**
     * The source used for this charge.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'source'?: string | null;
    /**
     * The transfer which created this charge. Only present if the charge came from another Stripe account.
     * @type {string}
     * @memberof DjStripeCharge
     */
    'source_transfer'?: string | null;
    /**
     * The transfer to the `destination` account (only applicable if the charge was created using the `destination` parameter).
     * @type {string}
     * @memberof DjStripeCharge
     */
    'transfer'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripeCheckoutSession
 */
export interface DjStripeCheckoutSession {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeSessionBillingAddressCollection}
     * @memberof DjStripeCheckoutSession
     */
    'billing_address_collection': StripeSessionBillingAddressCollection;
    /**
     * 
     * @type {StripeSessionMode}
     * @memberof DjStripeCheckoutSession
     */
    'mode': StripeSessionMode;
    /**
     * 
     * @type {StripeSubmitTypeStatus}
     * @memberof DjStripeCheckoutSession
     */
    'submit_type': StripeSubmitTypeStatus;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCheckoutSession
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'description'?: string | null;
    /**
     * The URL the customer will be directed to if theydecide to cancel payment and return to your website.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'cancel_url'?: string;
    /**
     * A unique string to reference the Checkout Session.This can be a customer ID, a cart ID, or similar, andcan be used to reconcile the session with your internal systems.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'client_reference_id'?: string;
    /**
     * If provided, this value will be used when the Customer object is created.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'customer_email'?: string;
    /**
     * The line items, plans, or SKUs purchased by the customer.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'display_items'?: { [key: string]: any; } | null;
    /**
     * The IETF language tag of the locale Checkout is displayed in.If blank or auto, the browser\'s locale is used.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'locale'?: string;
    /**
     * The list of payment method types (e.g. card) that this Checkout Session is allowed to accept.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCheckoutSession
     */
    'payment_method_types': { [key: string]: any; };
    /**
     * The URL the customer will be directed to after the payment or subscriptioncreation is successful.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'success_url'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'djstripe_owner_account'?: string | null;
    /**
     * Customer this Checkout is for if one exists.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'customer'?: string | null;
    /**
     * PaymentIntent created if SKUs or line items were provided.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'payment_intent'?: string | null;
    /**
     * Subscription created if one or more plans were provided.
     * @type {string}
     * @memberof DjStripeCheckoutSession
     */
    'subscription'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripeCustomer
 */
export interface DjStripeCustomer {
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'djstripe_id': number;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'description'?: string | null;
    /**
     * The customer\'s address.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'address'?: { [key: string]: any; } | null;
    /**
     * Current balance (in cents), if any, being stored on the customer\'s account. If negative, the customer has credit to apply to the next invoice. If positive, the customer has an amount owed that will be added to the next invoice. The balance does not refer to any unpaid invoices; it solely takes into account amounts that have yet to be successfully applied to any invoice. This balance is only taken into account for recurring billing purposes (i.e., subscriptions, invoices, invoice items).
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'balance'?: number | null;
    /**
     * The currency the customer can be charged in for recurring billing purposes
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'currency'?: string;
    /**
     * Whether or not the latest charge for the customer\'s latest invoice has failed.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'delinquent'?: boolean | null;
    /**
     * Whether the Customer instance has been deleted upstream in Stripe or not.
     * @type {boolean}
     * @memberof DjStripeCustomer
     */
    'deleted'?: boolean | null;
    /**
     * If a coupon is present, the date at which it was applied.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'coupon_start': string | null;
    /**
     * If a coupon is present and has a limited duration, the date that the discount will end.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'coupon_end': string | null;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'email'?: string;
    /**
     * The prefix for the customer used to generate unique invoice numbers.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'invoice_prefix'?: string;
    /**
     * The customer\'s default invoice settings.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'invoice_settings'?: { [key: string]: any; } | null;
    /**
     * The customer\'s full name or business name.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'name'?: string;
    /**
     * The customer\'s phone number.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'phone'?: string;
    /**
     * The customer\'s preferred locales (languages), ordered by preference.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'preferred_locales'?: { [key: string]: any; } | null;
    /**
     * Shipping information associated with the customer.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeCustomer
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * Describes the customer\'s tax exemption status. When set to reverse, invoice and receipt PDFs include the text \"Reverse charge\".  * `exempt` - Exempt * `none` - None * `reverse` - Reverse
     * @type {StripeCustomerTaxExempt}
     * @memberof DjStripeCustomer
     */
    'tax_exempt'?: StripeCustomerTaxExempt;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'date_purged': string | null;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'djstripe_owner_account': string | null;
    /**
     * 
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'default_source'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'coupon'?: number | null;
    /**
     * default payment method used for subscriptions and invoices for the customer.
     * @type {string}
     * @memberof DjStripeCustomer
     */
    'default_payment_method'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DjStripeCustomer
     */
    'subscriber': number | null;
}
/**
 * 
 * @export
 * @interface DjStripePaymentIntent
 */
export interface DjStripePaymentIntent {
    /**
     * 
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripePaymentIntentCancellationReason}
     * @memberof DjStripePaymentIntent
     */
    'cancellation_reason': StripePaymentIntentCancellationReason;
    /**
     * 
     * @type {Array<DjStripeCharge>}
     * @memberof DjStripePaymentIntent
     */
    'charges': Array<DjStripeCharge>;
    /**
     * 
     * @type {StripeIntentUsage}
     * @memberof DjStripePaymentIntent
     */
    'setup_future_usage': StripeIntentUsage;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripePaymentIntent
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Amount (in cents) intended to be collected by this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount': number;
    /**
     * Amount (in cents) that can be captured from this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount_capturable': number;
    /**
     * Amount (in cents) that was collected by this PaymentIntent.
     * @type {number}
     * @memberof DjStripePaymentIntent
     */
    'amount_received': number;
    /**
     * Populated when status is canceled, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'canceled_at'?: string | null;
    /**
     * Capture method of this PaymentIntent, one of automatic or manual.  * `automatic` - Automatic * `manual` - Manual
     * @type {StripeConfirmationMethod}
     * @memberof DjStripePaymentIntent
     */
    'capture_method': StripeConfirmationMethod;
    /**
     * The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'client_secret': string;
    /**
     * Confirmation method of this PaymentIntent, one of manual or automatic.  * `automatic` - Automatic * `manual` - Manual
     * @type {StripeConfirmationMethod}
     * @memberof DjStripePaymentIntent
     */
    'confirmation_method': StripeConfirmationMethod;
    /**
     * Three-letter ISO currency code
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'currency': string;
    /**
     * An arbitrary string attached to the object. Often useful for displaying to users.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'description'?: string;
    /**
     * The payment error encountered in the previous PaymentIntent confirmation.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'last_payment_error'?: { [key: string]: any; } | null;
    /**
     * If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'next_action'?: { [key: string]: any; } | null;
    /**
     * The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'payment_method_types': { [key: string]: any; };
    /**
     * Email address that the receipt for the resulting payment will be sent to.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'receipt_email'?: string;
    /**
     * Shipping information for this PaymentIntent.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'shipping'?: { [key: string]: any; } | null;
    /**
     * For non-card charges, you can use this value as the complete description that appears on your customers\' statements. Must contain at least one letter, maximum 22 characters.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'statement_descriptor'?: string;
    /**
     * Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.  * `canceled` - Cancellation invalidates the intent for future confirmation and cannot be undone. * `processing` - Required actions have been handled. * `requires_action` - Payment Method require additional action, such as 3D secure. * `requires_capture` - Capture the funds on the cards which have been put on holds. * `requires_confirmation` - Intent is ready to be confirmed. * `requires_payment_method` - Intent created and requires a Payment Method to be attached. * `succeeded` - The funds are in your account.
     * @type {StripePaymentIntentStatus}
     * @memberof DjStripePaymentIntent
     */
    'status': StripePaymentIntentStatus;
    /**
     * The data with which to automatically create a Transfer when the payment is finalized. See the PaymentIntents Connect usage guide for details.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePaymentIntent
     */
    'transfer_data'?: { [key: string]: any; } | null;
    /**
     * A string that identifies the resulting payment as part of a group. See the PaymentIntents Connect usage guide for details.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'transfer_group'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'djstripe_owner_account'?: string | null;
    /**
     * Customer this PaymentIntent is for if one exists.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'customer'?: string | null;
    /**
     * The account (if any) for which the funds of the PaymentIntent are intended.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'on_behalf_of'?: string | null;
    /**
     * Payment method used in this PaymentIntent.
     * @type {string}
     * @memberof DjStripePaymentIntent
     */
    'payment_method'?: string | null;
}
/**
 * 
 * @export
 * @interface DjStripePrice
 */
export interface DjStripePrice {
    /**
     * 
     * @type {number}
     * @memberof DjStripePrice
     */
    'djstripe_id': number;
    /**
     * 
     * @type {StripeBillingScheme}
     * @memberof DjStripePrice
     */
    'billing_scheme': StripeBillingScheme;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'human_readable_price': string;
    /**
     * 
     * @type {StripePriceTiersMode}
     * @memberof DjStripePrice
     */
    'tiers_mode': StripePriceTiersMode;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripePrice
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripePrice
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripePrice
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripePrice
     */
    'description'?: string | null;
    /**
     * Whether the price can be used for new purchases.
     * @type {boolean}
     * @memberof DjStripePrice
     */
    'active': boolean;
    /**
     * Three-letter ISO currency code
     * @type {string}
     * @memberof DjStripePrice
     */
    'currency': string;
    /**
     * A brief description of the plan, hidden from customers.
     * @type {string}
     * @memberof DjStripePrice
     */
    'nickname'?: string;
    /**
     * The recurring components of a price such as `interval` and `usage_type`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'recurring'?: { [key: string]: any; } | null;
    /**
     * Whether the price is for a one-time purchase or a recurring (subscription) purchase.  * `one_time` - One-time * `recurring` - Recurring
     * @type {StripePriceType}
     * @memberof DjStripePrice
     */
    'type': StripePriceType;
    /**
     * The unit amount in cents to be charged, represented as a whole integer if possible. Null if a sub-cent precision is required.
     * @type {number}
     * @memberof DjStripePrice
     */
    'unit_amount'?: number | null;
    /**
     * The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
     * @type {string}
     * @memberof DjStripePrice
     */
    'unit_amount_decimal'?: string | null;
    /**
     * A lookup key used to retrieve prices dynamically from a static string.
     * @type {string}
     * @memberof DjStripePrice
     */
    'lookup_key'?: string | null;
    /**
     * Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'tiers'?: { [key: string]: any; } | null;
    /**
     * Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripePrice
     */
    'transform_quantity'?: { [key: string]: any; } | null;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripePrice
     */
    'djstripe_owner_account'?: string | null;
    /**
     * The product this price is associated with.
     * @type {string}
     * @memberof DjStripePrice
     */
    'product': string;
}
/**
 * 
 * @export
 * @interface DjStripeProduct
 */
export interface DjStripeProduct {
    /**
     * 
     * @type {number}
     * @memberof DjStripeProduct
     */
    'djstripe_id': number;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_created': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_updated': string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'id': string;
    /**
     * Null here indicates that the livemode status is unknown or was previously unrecorded. Otherwise, this field indicates whether this record comes from Stripe test mode or live mode operation.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'livemode'?: boolean | null;
    /**
     * The datetime this object was created in stripe.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'created'?: string | null;
    /**
     * A set of key/value pairs that you can attach to an object. It can be useful for storing additional information about an object in a structured format.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * A description of this object.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'description'?: string | null;
    /**
     * The product\'s name, meant to be displayable to the customer. Applicable to both `service` and `good` types.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'name': string;
    /**
     * The type of the product. The product is either of type `good`, which is eligible for use with Orders and SKUs, or `service`, which is eligible for use with Subscriptions and Plans.  * `good` - Good * `service` - Service
     * @type {StripeProductType}
     * @memberof DjStripeProduct
     */
    'type': StripeProductType;
    /**
     * Whether the product is currently available for purchase. Only applicable to products of `type=good`.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'active'?: boolean | null;
    /**
     * A list of up to 5 attributes that each SKU can provide values for (e.g., `[\"color\", \"size\"]`). Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'attributes'?: { [key: string]: any; } | null;
    /**
     * A short one-line description of the product, meant to be displayableto the customer. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'caption'?: string;
    /**
     * An array of connect application identifiers that cannot purchase this product. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'deactivate_on'?: { [key: string]: any; } | null;
    /**
     * A list of up to 8 URLs of images for this product, meant to be displayable to the customer. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'images'?: { [key: string]: any; } | null;
    /**
     * The dimensions of this product for shipping purposes. A SKU associated with this product can override this value by having its own `package_dimensions`. Only applicable to products of `type=good`.
     * @type {{ [key: string]: any; }}
     * @memberof DjStripeProduct
     */
    'package_dimensions'?: { [key: string]: any; } | null;
    /**
     * Whether this product is a shipped good. Only applicable to products of `type=good`.
     * @type {boolean}
     * @memberof DjStripeProduct
     */
    'shippable'?: boolean | null;
    /**
     * A URL of a publicly-accessible webpage for this product. Only applicable to products of `type=good`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'url'?: string | null;
    /**
     * Extra information about a product which will appear on your customer\'s credit card statement. In the case that multiple products are billed at once, the first statement descriptor will be used. Only available on products of type=`service`.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'statement_descriptor'?: string;
    /**
     * 
     * @type {string}
     * @memberof DjStripeProduct
     */
    'unit_label'?: string;
    /**
     * The Stripe Account this object belongs to.
     * @type {string}
     * @memberof DjStripeProduct
     */
    'djstripe_owner_account'?: string | null;
}
/**
 * 
 * @export
 * @interface EmailAlertSettings
 */
export interface EmailAlertSettings {
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EmailAlertSettings
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof EmailAlertSettings
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailAlertSettings
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof EmailAlertSettings
     */
    'event_types'?: Array<EventTypesEnum>;
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettings
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface EmailAlertSettingsRequest
 */
export interface EmailAlertSettingsRequest {
    /**
     * 
     * @type {number}
     * @memberof EmailAlertSettingsRequest
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof EmailAlertSettingsRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof EmailAlertSettingsRequest
     */
    'event_types'?: Array<EventTypesEnum>;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuth
 */
export interface EmailAuth {
    /**
     * 
     * @type {string}
     * @memberof EmailAuth
     */
    'email': string;
}
/**
 * Abstract class that returns a callback token based on the field given Returns a token if valid, None or a message if not.
 * @export
 * @interface EmailAuthRequest
 */
export interface EmailAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailAuthRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface EmailWaitlist
 */
export interface EmailWaitlist {
    /**
     * 
     * @type {number}
     * @memberof EmailWaitlist
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlist
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlist
     */
    'email': string;
    /**
     * 
     * @type {InterestEnum}
     * @memberof EmailWaitlist
     */
    'interest'?: InterestEnum;
}
/**
 * 
 * @export
 * @interface EmailWaitlistRequest
 */
export interface EmailWaitlistRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailWaitlistRequest
     */
    'email': string;
    /**
     * 
     * @type {InterestEnum}
     * @memberof EmailWaitlistRequest
     */
    'interest'?: InterestEnum;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'code': string;
}
/**
 * * `octoprint` - Events originating from OctoPrint * `printnanny_os` - Event originating from PrintNanny OS * `printnanny_cloud` - Events originating from PrintNanny Cloud services * `mainsail` - Events originating from moonraker
 * @export
 * @enum {string}
 */

export const EventSourceEnum = {
    Octoprint: 'octoprint',
    PrintnannyOs: 'printnanny_os',
    PrintnannyCloud: 'printnanny_cloud',
    Mainsail: 'mainsail'
} as const;

export type EventSourceEnum = typeof EventSourceEnum[keyof typeof EventSourceEnum];


/**
 * * `PrintQuality` - Quality control alerts * `PrintStarted` - Triggered on print job start * `PrintDone` - Triggered when print job is finished * `PrintProgress` - Triggered when print job progress reaches %percent * `PrintPaused` - Triggered when print job is paused * `PrintCancelled` - Triggered when print job is cancelled
 * @export
 * @enum {string}
 */

export const EventTypeEnum = {
    PrintQuality: 'PrintQuality',
    PrintStarted: 'PrintStarted',
    PrintDone: 'PrintDone',
    PrintProgress: 'PrintProgress',
    PrintPaused: 'PrintPaused',
    PrintCancelled: 'PrintCancelled'
} as const;

export type EventTypeEnum = typeof EventTypeEnum[keyof typeof EventTypeEnum];


/**
 * * `PrintQuality` - Quality control alerts * `PrintStarted` - Triggered on print job start * `PrintDone` - Triggered when print job is finished * `PrintProgress` - Triggered when print job progress reaches %percent * `PrintPaused` - Triggered when print job is paused * `PrintCancelled` - Triggered when print job is cancelled
 * @export
 * @enum {string}
 */

export const EventTypesEnum = {
    PrintQuality: 'PrintQuality',
    PrintStarted: 'PrintStarted',
    PrintDone: 'PrintDone',
    PrintProgress: 'PrintProgress',
    PrintPaused: 'PrintPaused',
    PrintCancelled: 'PrintCancelled'
} as const;

export type EventTypesEnum = typeof EventTypesEnum[keyof typeof EventTypesEnum];


/**
 * 
 * @export
 * @interface GcodeFile
 */
export interface GcodeFile {
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof GcodeFile
     */
    'created_dt': string;
    /**
     * 
     * @type {number}
     * @memberof GcodeFile
     */
    'user': number;
}
/**
 * * `printnanny` - Subscribe to PrintNanny news and development updates * `sdwire` - Get notified when SDWire is back in stock * `rpi4_kit` - Get notified when Raspberry Pi 4 kits are available * `printnanny_demo` - Uploaded image to PrintNanny challenge/demo marketing campaign
 * @export
 * @enum {string}
 */

export const InterestEnum = {
    Printnanny: 'printnanny',
    Sdwire: 'sdwire',
    Rpi4Kit: 'rpi4_kit',
    PrintnannyDemo: 'printnanny_demo'
} as const;

export type InterestEnum = typeof InterestEnum[keyof typeof InterestEnum];


/**
 * * `cloud` - Cloud WebRTC Gateway * `edge` - Edge WebRTC Gateway
 * @export
 * @enum {string}
 */

export const JanusConfigType = {
    Cloud: 'cloud',
    Edge: 'edge'
} as const;

export type JanusConfigType = typeof JanusConfigType[keyof typeof JanusConfigType];


/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MoonrakerServer
 */
export interface MoonrakerServer {
    /**
     * 
     * @type {number}
     * @memberof MoonrakerServer
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'base_url': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'venv_path': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'pip_path': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'python_path': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'moonraker_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServer
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MoonrakerServer
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof MoonrakerServer
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface MoonrakerServerRequest
 */
export interface MoonrakerServerRequest {
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServerRequest
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServerRequest
     */
    'moonraker_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof MoonrakerServerRequest
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MoonrakerServerRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface NatsOrganization
 */
export interface NatsOrganization {
    /**
     * 
     * @type {number}
     * @memberof NatsOrganization
     */
    'id': number;
    /**
     * The name of the organization
     * @type {string}
     * @memberof NatsOrganization
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NatsOrganization
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganization
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganization
     */
    'modified': string;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof NatsOrganization
     */
    'slug': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganization
     */
    'json'?: { [key: string]: any; };
    /**
     * Enable JetStream for all users/apps belonging to NatsOrganization account
     * @type {boolean}
     * @memberof NatsOrganization
     */
    'jetstream_enabled'?: boolean;
    /**
     * JetStream memory resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganization
     */
    'jetstream_max_mem'?: string;
    /**
     * JetStream file resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganization
     */
    'jetstream_max_file'?: string;
    /**
     * JetStream max number of streams (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganization
     */
    'jetstream_max_streams'?: number;
    /**
     * JetStream max number of consumers (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganization
     */
    'jetstream_max_consumers'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'imports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'exports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganization
     */
    'users': Array<number>;
}
/**
 * 
 * @export
 * @interface NatsOrganizationRequest
 */
export interface NatsOrganizationRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof NatsOrganizationRequest
     */
    'is_active'?: boolean;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'slug': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganizationRequest
     */
    'json'?: { [key: string]: any; };
    /**
     * Enable JetStream for all users/apps belonging to NatsOrganization account
     * @type {boolean}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_enabled'?: boolean;
    /**
     * JetStream memory resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_mem'?: string;
    /**
     * JetStream file resource limits (shared across all users/apps beloning to NatsOrganization account)
     * @type {string}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_file'?: string;
    /**
     * JetStream max number of streams (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_streams'?: number;
    /**
     * JetStream max number of consumers (shared across all users/apps beloning to NatsOrganization account)
     * @type {number}
     * @memberof NatsOrganizationRequest
     */
    'jetstream_max_consumers'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganizationRequest
     */
    'imports': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof NatsOrganizationRequest
     */
    'exports': Array<number>;
}
/**
 * 
 * @export
 * @interface NatsOrganizationUser
 */
export interface NatsOrganizationUser {
    /**
     * 
     * @type {number}
     * @memberof NatsOrganizationUser
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganizationUser
     */
    'app_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof NatsOrganizationUser
     */
    'organization': number;
    /**
     * 
     * @type {string}
     * @memberof NatsOrganizationUser
     */
    'creds': string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof NatsOrganizationUser
     */
    'json'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NetworkSettings
 */
export interface NetworkSettings {
    /**
     * 
     * @type {number}
     * @memberof NetworkSettings
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NetworkSettings
     */
    'updated_dt': string;
    /**
     * 
     * @type {PreferredDnsType}
     * @memberof NetworkSettings
     */
    'preferred_dns'?: PreferredDnsType;
    /**
     * 
     * @type {number}
     * @memberof NetworkSettings
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface NetworkSettingsRequest
 */
export interface NetworkSettingsRequest {
    /**
     * 
     * @type {PreferredDnsType}
     * @memberof NetworkSettingsRequest
     */
    'preferred_dns'?: PreferredDnsType;
    /**
     * 
     * @type {number}
     * @memberof NetworkSettingsRequest
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrintBackup
 */
export interface OctoPrintBackup {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'hostname': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'octoprint_version': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintBackup
     */
    'file': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintBackup
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrintServer
 */
export interface OctoPrintServer {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'id': number;
    /**
     * 
     * @type {OctoPrintSettings}
     * @memberof OctoPrintServer
     */
    'settings': OctoPrintSettings;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'base_url': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'venv_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'pip_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'python_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServer
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServer
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintServerRequest
 */
export interface OctoPrintServerRequest {
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'base_url': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'base_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'venv_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'pip_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'python_path': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintServerRequest
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintServerRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface OctoPrintSettings
 */
export interface OctoPrintSettings {
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'id': number;
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettings
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettings
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettings
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'octoprint_server': number;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettings
     */
    'user': number | null;
}
/**
 * 
 * @export
 * @interface OctoPrintSettingsRequest
 */
export interface OctoPrintSettingsRequest {
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof OctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OctoPrintSettingsRequest
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrintSettingsRequest
     */
    'octoprint_server': number;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfile
 */
export interface OctoPrinterProfile {
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'id': number;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfile
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfile
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'volume_width'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfile
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfile
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface OctoPrinterProfileRequest
 */
export interface OctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof OctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'octoprint_key': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * Djstripe\'s representation of Stripe Checkout model is missing a number of fields, like subtotal amount and shipping/tax charges  stripe_checkout_session_data is the raw JSON returned by stripe.checkout.Session.retrieve
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'created_dt': string;
    /**
     * 
     * @type {DjStripeCheckoutSession}
     * @memberof Order
     */
    'djstripe_checkout_session': DjStripeCheckoutSession;
    /**
     * 
     * @type {DjStripeCustomer}
     * @memberof Order
     */
    'djstripe_customer': DjStripeCustomer;
    /**
     * 
     * @type {DjStripePaymentIntent}
     * @memberof Order
     */
    'djstripe_payment_intent': DjStripePaymentIntent;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_shippable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'is_subscription': boolean;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'last_status': OrderStatus;
    /**
     * 
     * @type {Array<Product>}
     * @memberof Order
     */
    'products': Array<Product>;
    /**
     * 
     * @type {Array<OrderStatus>}
     * @memberof Order
     */
    'status_history': Array<OrderStatus>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Order
     */
    'stripe_checkout_session_data': { [key: string]: any; };
    /**
     * 
     * @type {User}
     * @memberof Order
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'receipt_url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'portal_url': string | null;
}
/**
 * 
 * @export
 * @interface OrderCheckoutRequest
 */
export interface OrderCheckoutRequest {
    /**
     * 
     * @type {Array<OrderItemRequest>}
     * @memberof OrderCheckoutRequest
     */
    'items': Array<OrderItemRequest>;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface OrderItemRequest
 */
export interface OrderItemRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderItemRequest
     */
    'product': string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemRequest
     */
    'price': string;
}
/**
 * 
 * @export
 * @interface OrderStatus
 */
export interface OrderStatus {
    /**
     * 
     * @type {number}
     * @memberof OrderStatus
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'deleted': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrderStatus
     */
    'deleted_by_cascade': boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'created_dt': string;
    /**
     * 
     * @type {OrderStatusType}
     * @memberof OrderStatus
     */
    'status': OrderStatusType;
    /**
     * 
     * @type {string}
     * @memberof OrderStatus
     */
    'order': string;
}
/**
 * * `checkout_session_created` - Checkout session created * `checkout_session_completed` - Checkout session completed * `checkout_session_expired` - Checkout session expired * `processing` - Order is being proccessed * `ready_to_ship` - Order is ready to ship * `shipped` - Order has been passed shipping service * `goods_fulfilled` - Physical goods order fulfilled * `service_fulfilled` - Electronic service or subscription fulfilled * `refund_requested` - Refund requested * `refund_granted` - Refund granted
 * @export
 * @enum {string}
 */

export const OrderStatusType = {
    CheckoutSessionCreated: 'checkout_session_created',
    CheckoutSessionCompleted: 'checkout_session_completed',
    CheckoutSessionExpired: 'checkout_session_expired',
    Processing: 'processing',
    ReadyToShip: 'ready_to_ship',
    Shipped: 'shipped',
    GoodsFulfilled: 'goods_fulfilled',
    ServiceFulfilled: 'service_fulfilled',
    RefundRequested: 'refund_requested',
    RefundGranted: 'refund_granted'
} as const;

export type OrderStatusType = typeof OrderStatusType[keyof typeof OrderStatusType];


/**
 * 
 * @export
 * @interface PaginatedAchievementList
 */
export interface PaginatedAchievementList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAchievementList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAchievementList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAchievementList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Achievement>}
     * @memberof PaginatedAchievementList
     */
    'results'?: Array<Achievement>;
}
/**
 * 
 * @export
 * @interface PaginatedCameraSnapshotList
 */
export interface PaginatedCameraSnapshotList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCameraSnapshotList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCameraSnapshotList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCameraSnapshotList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CameraSnapshot>}
     * @memberof PaginatedCameraSnapshotList
     */
    'results'?: Array<CameraSnapshot>;
}
/**
 * 
 * @export
 * @interface PaginatedCrashReportList
 */
export interface PaginatedCrashReportList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCrashReportList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCrashReportList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCrashReportList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<CrashReport>}
     * @memberof PaginatedCrashReportList
     */
    'results'?: Array<CrashReport>;
}
/**
 * 
 * @export
 * @interface PaginatedGcodeFileList
 */
export interface PaginatedGcodeFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGcodeFileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGcodeFileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<GcodeFile>}
     * @memberof PaginatedGcodeFileList
     */
    'results'?: Array<GcodeFile>;
}
/**
 * 
 * @export
 * @interface PaginatedMoonrakerServerList
 */
export interface PaginatedMoonrakerServerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoonrakerServerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoonrakerServerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoonrakerServerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<MoonrakerServer>}
     * @memberof PaginatedMoonrakerServerList
     */
    'results'?: Array<MoonrakerServer>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintBackupList
 */
export interface PaginatedOctoPrintBackupList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintBackupList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintBackupList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintBackup>}
     * @memberof PaginatedOctoPrintBackupList
     */
    'results'?: Array<OctoPrintBackup>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintServerList
 */
export interface PaginatedOctoPrintServerList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintServerList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintServerList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintServerList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintServer>}
     * @memberof PaginatedOctoPrintServerList
     */
    'results'?: Array<OctoPrintServer>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrintSettingsList
 */
export interface PaginatedOctoPrintSettingsList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrintSettings>}
     * @memberof PaginatedOctoPrintSettingsList
     */
    'results'?: Array<OctoPrintSettings>;
}
/**
 * 
 * @export
 * @interface PaginatedOctoPrinterProfileList
 */
export interface PaginatedOctoPrinterProfileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<OctoPrinterProfile>}
     * @memberof PaginatedOctoPrinterProfileList
     */
    'results'?: Array<OctoPrinterProfile>;
}
/**
 * 
 * @export
 * @interface PaginatedPiList
 */
export interface PaginatedPiList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPiList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPiList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Pi>}
     * @memberof PaginatedPiList
     */
    'results'?: Array<Pi>;
}
/**
 * 
 * @export
 * @interface PaginatedPrintJobAlertList
 */
export interface PaginatedPrintJobAlertList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPrintJobAlertList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintJobAlertList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPrintJobAlertList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<PrintJobAlert>}
     * @memberof PaginatedPrintJobAlertList
     */
    'results'?: Array<PrintJobAlert>;
}
/**
 * 
 * @export
 * @interface PaginatedProductList
 */
export interface PaginatedProductList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedProductList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedProductList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Product>}
     * @memberof PaginatedProductList
     */
    'results'?: Array<Product>;
}
/**
 * 
 * @export
 * @interface PaginatedSystemInfoList
 */
export interface PaginatedSystemInfoList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSystemInfoList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSystemInfoList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<SystemInfo>}
     * @memberof PaginatedSystemInfoList
     */
    'results'?: Array<SystemInfo>;
}
/**
 * 
 * @export
 * @interface PaginatedVideoRecordingList
 */
export interface PaginatedVideoRecordingList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedVideoRecordingList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideoRecordingList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideoRecordingList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<VideoRecording>}
     * @memberof PaginatedVideoRecordingList
     */
    'results'?: Array<VideoRecording>;
}
/**
 * 
 * @export
 * @interface PaginatedVideoRecordingPartList
 */
export interface PaginatedVideoRecordingPartList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedVideoRecordingPartList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideoRecordingPartList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVideoRecordingPartList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<VideoRecordingPart>}
     * @memberof PaginatedVideoRecordingPartList
     */
    'results'?: Array<VideoRecordingPart>;
}
/**
 * 
 * @export
 * @interface PaginatedWebrtcStreamList
 */
export interface PaginatedWebrtcStreamList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedWebrtcStreamList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWebrtcStreamList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWebrtcStreamList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<WebrtcStream>}
     * @memberof PaginatedWebrtcStreamList
     */
    'results'?: Array<WebrtcStream>;
}
/**
 * 
 * @export
 * @interface PaginatedWorkspaceList
 */
export interface PaginatedWorkspaceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedWorkspaceList
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkspaceList
     */
    'next'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedWorkspaceList
     */
    'previous'?: string | null;
    /**
     * 
     * @type {Array<Workspace>}
     * @memberof PaginatedWorkspaceList
     */
    'results'?: Array<Workspace>;
}
/**
 * 
 * @export
 * @interface PasswordChangeRequest
 */
export interface PasswordChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'new_password1': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordChangeRequest
     */
    'new_password2': string;
}
/**
 * Serializer for confirming a password reset attempt.
 * @export
 * @interface PasswordResetConfirmRequest
 */
export interface PasswordResetConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'new_password1': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'new_password2': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordResetConfirmRequest
     */
    'token': string;
}
/**
 * Serializer for requesting a password reset e-mail.
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PatchedDemoSubmissionFeedbackRequest
 */
export interface PatchedDemoSubmissionFeedbackRequest {
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof PatchedDemoSubmissionFeedbackRequest
     */
    'feedback_nozzle'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof PatchedDemoSubmissionFeedbackRequest
     */
    'feedback_adhesion'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof PatchedDemoSubmissionFeedbackRequest
     */
    'feedback_spaghetti'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof PatchedDemoSubmissionFeedbackRequest
     */
    'feedback_print'?: DemoFeedbackEnum | null;
    /**
     * 
     * @type {DemoFeedbackEnum}
     * @memberof PatchedDemoSubmissionFeedbackRequest
     */
    'feedback_raft'?: DemoFeedbackEnum | null;
}
/**
 * 
 * @export
 * @interface PatchedEmailAlertSettingsRequest
 */
export interface PatchedEmailAlertSettingsRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'progress_percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<EventTypesEnum>}
     * @memberof PatchedEmailAlertSettingsRequest
     */
    'event_types'?: Array<EventTypesEnum>;
}
/**
 * 
 * @export
 * @interface PatchedMoonrakerServerRequest
 */
export interface PatchedMoonrakerServerRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMoonrakerServerRequest
     */
    'base_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMoonrakerServerRequest
     */
    'moonraker_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMoonrakerServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMoonrakerServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMoonrakerServerRequest
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMoonrakerServerRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedNetworkSettingsRequest
 */
export interface PatchedNetworkSettingsRequest {
    /**
     * 
     * @type {PreferredDnsType}
     * @memberof PatchedNetworkSettingsRequest
     */
    'preferred_dns'?: PreferredDnsType;
    /**
     * 
     * @type {number}
     * @memberof PatchedNetworkSettingsRequest
     */
    'user'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintServerRequest
 */
export interface PatchedOctoPrintServerRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'base_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'base_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'venv_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pip_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'python_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'octoprint_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pip_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'python_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'printnanny_plugin_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintServerRequest
     */
    'api_key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintServerRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrintSettingsRequest
 */
export interface PatchedOctoPrintSettingsRequest {
    /**
     * Start OctoPrint service
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'octoprint_enabled'?: boolean;
    /**
     * Send OctoPrint events related to print job status/progress to PrintNanny Cloud https://docs.octoprint.org/en/master/events/index.html
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'events_enabled'?: boolean;
    /**
     * Sync Gcode files to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_gcode'?: boolean;
    /**
     * Sync Printer Profiles to/from PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_printer_profiles'?: boolean;
    /**
     * Upload OctoPrint backups to PrintNanny Cloud
     * @type {boolean}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'sync_backups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'auto_backup'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrintSettingsRequest
     */
    'octoprint_server'?: number;
}
/**
 * 
 * @export
 * @interface PatchedOctoPrinterProfileRequest
 */
export interface PatchedOctoPrinterProfileRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_e_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_x_inverted'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_y_speed'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_inverted'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'axes_z_speed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_nozzle_diameter'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'extruder_shared_nozzle'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_bed'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'heated_chamber'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'octoprint_key'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_custom_box'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_depth'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_formfactor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_height'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_origin'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedOctoPrinterProfileRequest
     */
    'volume_width'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedPiRequest
 */
export interface PatchedPiRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedPiRequest
     */
    'hostname'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPiRequest
     */
    'favorite'?: boolean;
    /**
     * 
     * @type {SbcEnum}
     * @memberof PatchedPiRequest
     */
    'sbc'?: SbcEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPiRequest
     */
    'setup_finished'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedPrintJobAlertRequest
 */
export interface PatchedPrintJobAlertRequest {
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof PatchedPrintJobAlertRequest
     */
    'event_type'?: EventTypeEnum;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PatchedPrintJobAlertRequest
     */
    'event_source'?: EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PatchedPrintJobAlertRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPrintJobAlertRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedSystemInfoRequest
 */
export interface PatchedSystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'machine_id'?: string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'revision'?: string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'model'?: string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'serial'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'cores'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'ram'?: number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'os_version_id'?: string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof PatchedSystemInfoRequest
     */
    'os_build_id'?: string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof PatchedSystemInfoRequest
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'uptime'?: number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'rootfs_size'?: number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'rootfs_used'?: number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'bootfs_size'?: number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'bootfs_used'?: number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'datafs_size'?: number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'datafs_used'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSystemInfoRequest
     */
    'pi'?: number;
}
/**
 * 
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface PatchedVideoRecordingRequest
 */
export interface PatchedVideoRecordingRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedVideoRecordingRequest
     */
    'cloud_sync_done'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'finalize_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'finalize_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'recording_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'recording_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedVideoRecordingRequest
     */
    'gcode_file_name'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedWebrtcStreamRequest
 */
export interface PatchedWebrtcStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PatchedWebrtcStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof PatchedWebrtcStreamRequest
     */
    'config_type'?: JanusConfigType;
}
/**
 * 
 * @export
 * @interface PatchedWorkspaceRequest
 */
export interface PatchedWorkspaceRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof PatchedWorkspaceRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedWorkspaceRequest
     */
    'is_active'?: boolean;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof PatchedWorkspaceRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface Pi
 */
export interface Pi {
    /**
     * 
     * @type {number}
     * @memberof Pi
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'last_boot': string | null;
    /**
     * 
     * @type {NetworkSettings}
     * @memberof Pi
     */
    'network_settings': NetworkSettings;
    /**
     * 
     * @type {User}
     * @memberof Pi
     */
    'user': User;
    /**
     * 
     * @type {SystemInfo}
     * @memberof Pi
     */
    'system_info': SystemInfo;
    /**
     * 
     * @type {WebrtcStream}
     * @memberof Pi
     */
    'webrtc_edge': WebrtcStream;
    /**
     * 
     * @type {WebrtcStream}
     * @memberof Pi
     */
    'webrtc_cloud': WebrtcStream;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'latest_camera_snapshot_url': string | null;
    /**
     * 
     * @type {OctoPrintServer}
     * @memberof Pi
     */
    'octoprint_server': OctoPrintServer;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'hostname': string;
    /**
     * 
     * @type {boolean}
     * @memberof Pi
     */
    'favorite': boolean;
    /**
     * 
     * @type {SbcEnum}
     * @memberof Pi
     */
    'sbc': SbcEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Pi
     */
    'setup_finished': boolean;
    /**
     * 
     * @type {PiNatsApp}
     * @memberof Pi
     */
    'nats_app': PiNatsApp;
    /**
     * 
     * @type {PiUrls}
     * @memberof Pi
     */
    'urls': PiUrls;
    /**
     * 
     * @type {PiUrls}
     * @memberof Pi
     */
    'shortname_urls': PiUrls;
    /**
     * 
     * @type {PiUrls}
     * @memberof Pi
     */
    'mdns_urls': PiUrls;
    /**
     * 
     * @type {string}
     * @memberof Pi
     */
    'created_dt': string;
}
/**
 * 
 * @export
 * @interface PiNatsApp
 */
export interface PiNatsApp {
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'app_name'?: string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof PiNatsApp
     */
    'json'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'pi': number;
    /**
     * 
     * @type {NatsOrganization}
     * @memberof PiNatsApp
     */
    'organization': NatsOrganization;
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'organization_user': number;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_server_uri': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_ws_uri': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_subject_pattern': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'nats_subject_pattern_template': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_moonraker_request': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_moonraker_request': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_moonraker_response': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_moonraker_response': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_template_klipper_status': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_subject_klipper_status': string;
    /**
     * 
     * @type {string}
     * @memberof PiNatsApp
     */
    'mqtt_broker_host': string;
    /**
     * 
     * @type {number}
     * @memberof PiNatsApp
     */
    'mqtt_broker_port': number;
}
/**
 * 
 * @export
 * @interface PiNatsAppRequest
 */
export interface PiNatsAppRequest {
    /**
     * 
     * @type {string}
     * @memberof PiNatsAppRequest
     */
    'app_name'?: string;
    /**
     * Output of `nsc describe account`
     * @type {{ [key: string]: any; }}
     * @memberof PiNatsAppRequest
     */
    'json'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PiNatsAppRequest
     */
    'pi': number;
    /**
     * 
     * @type {NatsOrganizationRequest}
     * @memberof PiNatsAppRequest
     */
    'organization': NatsOrganizationRequest;
    /**
     * 
     * @type {number}
     * @memberof PiNatsAppRequest
     */
    'organization_user': number;
}
/**
 * 
 * @export
 * @interface PiRequest
 */
export interface PiRequest {
    /**
     * 
     * @type {string}
     * @memberof PiRequest
     */
    'hostname': string;
    /**
     * 
     * @type {boolean}
     * @memberof PiRequest
     */
    'favorite': boolean;
    /**
     * 
     * @type {SbcEnum}
     * @memberof PiRequest
     */
    'sbc': SbcEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PiRequest
     */
    'setup_finished': boolean;
}
/**
 * 
 * @export
 * @interface PiUrls
 */
export interface PiUrls {
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'moonraker_api': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'mission_control': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'octoprint': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'swupdate': string;
    /**
     * 
     * @type {string}
     * @memberof PiUrls
     */
    'syncthing': string;
}
/**
 * * `multicast` - Multicast DNS (mDNS) * `tailscale` - Tailscale Magic DNS
 * @export
 * @enum {string}
 */

export const PreferredDnsType = {
    Multicast: 'multicast',
    Tailscale: 'tailscale'
} as const;

export type PreferredDnsType = typeof PreferredDnsType[keyof typeof PreferredDnsType];


/**
 * 
 * @export
 * @interface PrintJobAlert
 */
export interface PrintJobAlert {
    /**
     * 
     * @type {string}
     * @memberof PrintJobAlert
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PrintJobAlert
     */
    'created_dt': string;
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof PrintJobAlert
     */
    'event_type': EventTypeEnum;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PrintJobAlert
     */
    'event_source': EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobAlert
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof PrintJobAlert
     */
    'email_message_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof PrintJobAlert
     */
    'celery_task_id': string | null;
    /**
     * 
     * @type {number}
     * @memberof PrintJobAlert
     */
    'user': number;
    /**
     * 
     * @type {number}
     * @memberof PrintJobAlert
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface PrintJobAlertRequest
 */
export interface PrintJobAlertRequest {
    /**
     * 
     * @type {EventTypeEnum}
     * @memberof PrintJobAlertRequest
     */
    'event_type': EventTypeEnum;
    /**
     * 
     * @type {EventSourceEnum}
     * @memberof PrintJobAlertRequest
     */
    'event_source': EventSourceEnum;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PrintJobAlertRequest
     */
    'payload'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PrintJobAlertRequest
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * 
     * @type {DjStripeProduct}
     * @memberof Product
     */
    'djstripe_product': DjStripeProduct;
    /**
     * 
     * @type {Array<DjStripePrice>}
     * @memberof Product
     */
    'prices': Array<DjStripePrice>;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'deleted': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'deleted_by_cascade': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'updated_dt': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'sku': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'unit_label': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'statement_descriptor': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Product
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_shippable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_preorder': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Product
     */
    'is_subscription': boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'stripe_price_lookup_key'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'stripe_product_id'?: string | null;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password1': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password2': string;
}
/**
 * 
 * @export
 * @interface ResendEmailVerificationRequest
 */
export interface ResendEmailVerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof ResendEmailVerificationRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RestAuthDetail
 */
export interface RestAuthDetail {
    /**
     * 
     * @type {string}
     * @memberof RestAuthDetail
     */
    'detail': string;
}
/**
 * * `rpi_4` - Raspberry Pi 4
 * @export
 * @enum {string}
 */

export const SbcEnum = {
    Rpi4: 'rpi_4'
} as const;

export type SbcEnum = typeof SbcEnum[keyof typeof SbcEnum];


/**
 * * `account_already_exists` - Account already exists * `account_country_invalid_address` - Account country invalid address * `account_invalid` - Account invalid * `account_number_invalid` - Account number invalid * `alipay_upgrade_required` - Alipay upgrade required * `amount_too_large` - Amount too large * `amount_too_small` - Amount too small * `api_key_expired` - Api key expired * `balance_insufficient` - Balance insufficient * `bank_account_exists` - Bank account exists * `bank_account_unusable` - Bank account unusable * `bank_account_unverified` - Bank account unverified * `bitcoin_upgrade_required` - Bitcoin upgrade required * `card_declined` - Card was declined * `charge_already_captured` - Charge already captured * `charge_already_refunded` - Charge already refunded * `charge_disputed` - Charge disputed * `charge_exceeds_source_limit` - Charge exceeds source limit * `charge_expired_for_capture` - Charge expired for capture * `country_unsupported` - Country unsupported * `coupon_expired` - Coupon expired * `customer_max_subscriptions` - Customer max subscriptions * `email_invalid` - Email invalid * `expired_card` - Expired card * `idempotency_key_in_use` - Idempotency key in use * `incorrect_address` - Incorrect address * `incorrect_cvc` - Incorrect security code * `incorrect_number` - Incorrect number * `incorrect_zip` - ZIP code failed validation * `instant_payouts_unsupported` - Instant payouts unsupported * `invalid_card_type` - Invalid card type * `invalid_charge_amount` - Invalid charge amount * `invalid_cvc` - Invalid security code * `invalid_expiry_month` - Invalid expiration month * `invalid_expiry_year` - Invalid expiration year * `invalid_number` - Invalid number * `invalid_source_usage` - Invalid source usage * `invalid_swipe_data` - Invalid swipe data * `invoice_no_customer_line_items` - Invoice no customer line items * `invoice_no_subscription_line_items` - Invoice no subscription line items * `invoice_not_editable` - Invoice not editable * `invoice_upcoming_none` - Invoice upcoming none * `livemode_mismatch` - Livemode mismatch * `missing` - No card being charged * `not_allowed_on_standard_account` - Not allowed on standard account * `order_creation_failed` - Order creation failed * `order_required_settings` - Order required settings * `order_status_invalid` - Order status invalid * `order_upstream_timeout` - Order upstream timeout * `out_of_inventory` - Out of inventory * `parameter_invalid_empty` - Parameter invalid empty * `parameter_invalid_integer` - Parameter invalid integer * `parameter_invalid_string_blank` - Parameter invalid string blank * `parameter_invalid_string_empty` - Parameter invalid string empty * `parameter_missing` - Parameter missing * `parameter_unknown` - Parameter unknown * `parameters_exclusive` - Parameters exclusive * `payment_intent_authentication_failure` - Payment intent authentication failure * `payment_intent_incompatible_payment_method` - Payment intent incompatible payment method * `payment_intent_invalid_parameter` - Payment intent invalid parameter * `payment_intent_payment_attempt_failed` - Payment intent payment attempt failed * `payment_intent_unexpected_state` - Payment intent unexpected state * `payment_method_unactivated` - Payment method unactivated * `payment_method_unexpected_state` - Payment method unexpected state * `payouts_not_allowed` - Payouts not allowed * `platform_api_key_expired` - Platform api key expired * `postal_code_invalid` - Postal code invalid * `processing_error` - Processing error * `product_inactive` - Product inactive * `rate_limit` - Rate limit * `resource_already_exists` - Resource already exists * `resource_missing` - Resource missing * `routing_number_invalid` - Routing number invalid * `secret_key_required` - Secret key required * `sepa_unsupported_account` - SEPA unsupported account * `shipping_calculation_failed` - Shipping calculation failed * `sku_inactive` - SKU inactive * `state_unsupported` - State unsupported * `tax_id_invalid` - Tax id invalid * `taxes_calculation_failed` - Taxes calculation failed * `testmode_charges_only` - Testmode charges only * `tls_version_unsupported` - TLS version unsupported * `token_already_used` - Token already used * `token_in_use` - Token in use * `transfers_not_allowed` - Transfers not allowed * `upstream_order_creation_failed` - Upstream order creation failed * `url_invalid` - URL invalid
 * @export
 * @enum {string}
 */

export const StripeApiErrorCode = {
    AccountAlreadyExists: 'account_already_exists',
    AccountCountryInvalidAddress: 'account_country_invalid_address',
    AccountInvalid: 'account_invalid',
    AccountNumberInvalid: 'account_number_invalid',
    AlipayUpgradeRequired: 'alipay_upgrade_required',
    AmountTooLarge: 'amount_too_large',
    AmountTooSmall: 'amount_too_small',
    ApiKeyExpired: 'api_key_expired',
    BalanceInsufficient: 'balance_insufficient',
    BankAccountExists: 'bank_account_exists',
    BankAccountUnusable: 'bank_account_unusable',
    BankAccountUnverified: 'bank_account_unverified',
    BitcoinUpgradeRequired: 'bitcoin_upgrade_required',
    CardDeclined: 'card_declined',
    ChargeAlreadyCaptured: 'charge_already_captured',
    ChargeAlreadyRefunded: 'charge_already_refunded',
    ChargeDisputed: 'charge_disputed',
    ChargeExceedsSourceLimit: 'charge_exceeds_source_limit',
    ChargeExpiredForCapture: 'charge_expired_for_capture',
    CountryUnsupported: 'country_unsupported',
    CouponExpired: 'coupon_expired',
    CustomerMaxSubscriptions: 'customer_max_subscriptions',
    EmailInvalid: 'email_invalid',
    ExpiredCard: 'expired_card',
    IdempotencyKeyInUse: 'idempotency_key_in_use',
    IncorrectAddress: 'incorrect_address',
    IncorrectCvc: 'incorrect_cvc',
    IncorrectNumber: 'incorrect_number',
    IncorrectZip: 'incorrect_zip',
    InstantPayoutsUnsupported: 'instant_payouts_unsupported',
    InvalidCardType: 'invalid_card_type',
    InvalidChargeAmount: 'invalid_charge_amount',
    InvalidCvc: 'invalid_cvc',
    InvalidExpiryMonth: 'invalid_expiry_month',
    InvalidExpiryYear: 'invalid_expiry_year',
    InvalidNumber: 'invalid_number',
    InvalidSourceUsage: 'invalid_source_usage',
    InvalidSwipeData: 'invalid_swipe_data',
    InvoiceNoCustomerLineItems: 'invoice_no_customer_line_items',
    InvoiceNoSubscriptionLineItems: 'invoice_no_subscription_line_items',
    InvoiceNotEditable: 'invoice_not_editable',
    InvoiceUpcomingNone: 'invoice_upcoming_none',
    LivemodeMismatch: 'livemode_mismatch',
    Missing: 'missing',
    NotAllowedOnStandardAccount: 'not_allowed_on_standard_account',
    OrderCreationFailed: 'order_creation_failed',
    OrderRequiredSettings: 'order_required_settings',
    OrderStatusInvalid: 'order_status_invalid',
    OrderUpstreamTimeout: 'order_upstream_timeout',
    OutOfInventory: 'out_of_inventory',
    ParameterInvalidEmpty: 'parameter_invalid_empty',
    ParameterInvalidInteger: 'parameter_invalid_integer',
    ParameterInvalidStringBlank: 'parameter_invalid_string_blank',
    ParameterInvalidStringEmpty: 'parameter_invalid_string_empty',
    ParameterMissing: 'parameter_missing',
    ParameterUnknown: 'parameter_unknown',
    ParametersExclusive: 'parameters_exclusive',
    PaymentIntentAuthenticationFailure: 'payment_intent_authentication_failure',
    PaymentIntentIncompatiblePaymentMethod: 'payment_intent_incompatible_payment_method',
    PaymentIntentInvalidParameter: 'payment_intent_invalid_parameter',
    PaymentIntentPaymentAttemptFailed: 'payment_intent_payment_attempt_failed',
    PaymentIntentUnexpectedState: 'payment_intent_unexpected_state',
    PaymentMethodUnactivated: 'payment_method_unactivated',
    PaymentMethodUnexpectedState: 'payment_method_unexpected_state',
    PayoutsNotAllowed: 'payouts_not_allowed',
    PlatformApiKeyExpired: 'platform_api_key_expired',
    PostalCodeInvalid: 'postal_code_invalid',
    ProcessingError: 'processing_error',
    ProductInactive: 'product_inactive',
    RateLimit: 'rate_limit',
    ResourceAlreadyExists: 'resource_already_exists',
    ResourceMissing: 'resource_missing',
    RoutingNumberInvalid: 'routing_number_invalid',
    SecretKeyRequired: 'secret_key_required',
    SepaUnsupportedAccount: 'sepa_unsupported_account',
    ShippingCalculationFailed: 'shipping_calculation_failed',
    SkuInactive: 'sku_inactive',
    StateUnsupported: 'state_unsupported',
    TaxIdInvalid: 'tax_id_invalid',
    TaxesCalculationFailed: 'taxes_calculation_failed',
    TestmodeChargesOnly: 'testmode_charges_only',
    TlsVersionUnsupported: 'tls_version_unsupported',
    TokenAlreadyUsed: 'token_already_used',
    TokenInUse: 'token_in_use',
    TransfersNotAllowed: 'transfers_not_allowed',
    UpstreamOrderCreationFailed: 'upstream_order_creation_failed',
    UrlInvalid: 'url_invalid'
} as const;

export type StripeApiErrorCode = typeof StripeApiErrorCode[keyof typeof StripeApiErrorCode];


/**
 * * `per_unit` - Per-unit * `tiered` - Tiered
 * @export
 * @enum {string}
 */

export const StripeBillingScheme = {
    PerUnit: 'per_unit',
    Tiered: 'tiered'
} as const;

export type StripeBillingScheme = typeof StripeBillingScheme[keyof typeof StripeBillingScheme];


/**
 * * `automatic` - Automatic * `manual` - Manual
 * @export
 * @enum {string}
 */

export const StripeConfirmationMethod = {
    Automatic: 'automatic',
    Manual: 'manual'
} as const;

export type StripeConfirmationMethod = typeof StripeConfirmationMethod[keyof typeof StripeConfirmationMethod];


/**
 * * `exempt` - Exempt * `none` - None * `reverse` - Reverse
 * @export
 * @enum {string}
 */

export const StripeCustomerTaxExempt = {
    Exempt: 'exempt',
    None: 'none',
    Reverse: 'reverse'
} as const;

export type StripeCustomerTaxExempt = typeof StripeCustomerTaxExempt[keyof typeof StripeCustomerTaxExempt];


/**
 * * `off_session` - Off session * `on_session` - On session
 * @export
 * @enum {string}
 */

export const StripeIntentUsage = {
    OffSession: 'off_session',
    OnSession: 'on_session'
} as const;

export type StripeIntentUsage = typeof StripeIntentUsage[keyof typeof StripeIntentUsage];


/**
 * * `abandoned` - Abandoned * `automatic` - Automatic * `duplicate` - Duplicate * `failed_invoice` - Failed invoice * `fraudulent` - Fraudulent * `requested_by_customer` - Requested by Customer * `void_invoice` - Void invoice
 * @export
 * @enum {string}
 */

export const StripePaymentIntentCancellationReason = {
    Abandoned: 'abandoned',
    Automatic: 'automatic',
    Duplicate: 'duplicate',
    FailedInvoice: 'failed_invoice',
    Fraudulent: 'fraudulent',
    RequestedByCustomer: 'requested_by_customer',
    VoidInvoice: 'void_invoice'
} as const;

export type StripePaymentIntentCancellationReason = typeof StripePaymentIntentCancellationReason[keyof typeof StripePaymentIntentCancellationReason];


/**
 * * `canceled` - Cancellation invalidates the intent for future confirmation and cannot be undone. * `processing` - Required actions have been handled. * `requires_action` - Payment Method require additional action, such as 3D secure. * `requires_capture` - Capture the funds on the cards which have been put on holds. * `requires_confirmation` - Intent is ready to be confirmed. * `requires_payment_method` - Intent created and requires a Payment Method to be attached. * `succeeded` - The funds are in your account.
 * @export
 * @enum {string}
 */

export const StripePaymentIntentStatus = {
    Canceled: 'canceled',
    Processing: 'processing',
    RequiresAction: 'requires_action',
    RequiresCapture: 'requires_capture',
    RequiresConfirmation: 'requires_confirmation',
    RequiresPaymentMethod: 'requires_payment_method',
    Succeeded: 'succeeded'
} as const;

export type StripePaymentIntentStatus = typeof StripePaymentIntentStatus[keyof typeof StripePaymentIntentStatus];


/**
 * * `graduated` - Graduated * `volume` - Volume-based
 * @export
 * @enum {string}
 */

export const StripePriceTiersMode = {
    Graduated: 'graduated',
    Volume: 'volume'
} as const;

export type StripePriceTiersMode = typeof StripePriceTiersMode[keyof typeof StripePriceTiersMode];


/**
 * * `one_time` - One-time * `recurring` - Recurring
 * @export
 * @enum {string}
 */

export const StripePriceType = {
    OneTime: 'one_time',
    Recurring: 'recurring'
} as const;

export type StripePriceType = typeof StripePriceType[keyof typeof StripePriceType];


/**
 * * `good` - Good * `service` - Service
 * @export
 * @enum {string}
 */

export const StripeProductType = {
    Good: 'good',
    Service: 'service'
} as const;

export type StripeProductType = typeof StripeProductType[keyof typeof StripeProductType];


/**
 * * `auto` - Auto * `required` - Required
 * @export
 * @enum {string}
 */

export const StripeSessionBillingAddressCollection = {
    Auto: 'auto',
    Required: 'required'
} as const;

export type StripeSessionBillingAddressCollection = typeof StripeSessionBillingAddressCollection[keyof typeof StripeSessionBillingAddressCollection];


/**
 * * `payment` - Payment * `setup` - Setup * `subscription` - Subscription
 * @export
 * @enum {string}
 */

export const StripeSessionMode = {
    Payment: 'payment',
    Setup: 'setup',
    Subscription: 'subscription'
} as const;

export type StripeSessionMode = typeof StripeSessionMode[keyof typeof StripeSessionMode];


/**
 * * `failed` - Failed * `pending` - Pending * `succeeded` - Succeeded
 * @export
 * @enum {string}
 */

export const StripeSourceCodeVerificationStatus = {
    Failed: 'failed',
    Pending: 'pending',
    Succeeded: 'succeeded'
} as const;

export type StripeSourceCodeVerificationStatus = typeof StripeSourceCodeVerificationStatus[keyof typeof StripeSourceCodeVerificationStatus];


/**
 * * `auto` - Auto * `book` - Book * `donate` - donate * `pay` - pay
 * @export
 * @enum {string}
 */

export const StripeSubmitTypeStatus = {
    Auto: 'auto',
    Book: 'book',
    Donate: 'donate',
    Pay: 'pay'
} as const;

export type StripeSubmitTypeStatus = typeof StripeSubmitTypeStatus[keyof typeof StripeSubmitTypeStatus];


/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'bootfs_size_pretty': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'datafs_size_pretty': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_available': number;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_available_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_size_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'rootfs_used_pretty': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'created_dt': string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'updated_dt': string;
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfo
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfo
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfo
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfo
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'ram': number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfo
     */
    'os_version_id'?: string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfo
     */
    'os_build_id'?: string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof SystemInfo
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof SystemInfo
     */
    'uptime': number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_size': number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'rootfs_used': number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_size': number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'bootfs_used': number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_size': number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfo
     */
    'datafs_used': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    'pi': number;
}
/**
 * 
 * @export
 * @interface SystemInfoRequest
 */
export interface SystemInfoRequest {
    /**
     * Populated from /etc/machine-id
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'machine_id': string;
    /**
     * Populated from /proc/cpuinfo REVISION
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'revision': string;
    /**
     * Populated from /proc/cpuinfo MODEL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'model': string;
    /**
     * Populated from /proc/cpuinfo SERIAL
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'serial': string;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'ram': number;
    /**
     * PrintNanny OS VERSION_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'os_version_id'?: string;
    /**
     * PrintNanny OS BUILD_ID from /etc/os-release
     * @type {string}
     * @memberof SystemInfoRequest
     */
    'os_build_id'?: string;
    /**
     * Full contents of /etc/os-release in key:value format
     * @type {{ [key: string]: any; }}
     * @memberof SystemInfoRequest
     */
    'os_release_json'?: { [key: string]: any; };
    /**
     * system uptime (in seconds)
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'uptime': number;
    /**
     * Size of /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'rootfs_size': number;
    /**
     * Space used in /dev/root filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'rootfs_used': number;
    /**
     * Size of /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'bootfs_size': number;
    /**
     * Space used in /dev/mmcblk0p1 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'bootfs_used': number;
    /**
     * Size of /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'datafs_size': number;
    /**
     * Space used in /dev/mmcblk0p4 filesystem in bytes
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'datafs_used': number;
    /**
     * 
     * @type {number}
     * @memberof SystemInfoRequest
     */
    'pi': number;
}
/**
 * Serializer for Token model.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_beta_tester': boolean;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface VerifyEmailRequest
 */
export interface VerifyEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailRequest
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface VideoRecording
 */
export interface VideoRecording {
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VideoRecording
     */
    'mp4_size': number | null;
    /**
     * 
     * @type {boolean}
     * @memberof VideoRecording
     */
    'cloud_sync_done'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'finalize_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'finalize_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'finalize_task_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'recording_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'recording_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'gcode_file_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecording
     */
    'mp4_file': string | null;
    /**
     * 
     * @type {number}
     * @memberof VideoRecording
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface VideoRecordingFinalizeRequest
 */
export interface VideoRecordingFinalizeRequest {
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingFinalizeRequest
     */
    'recording_end': string;
}
/**
 * 
 * @export
 * @interface VideoRecordingPart
 */
export interface VideoRecordingPart {
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof VideoRecordingPart
     */
    'deleted_by_cascade': boolean;
    /**
     * 
     * @type {number}
     * @memberof VideoRecordingPart
     */
    'size': number;
    /**
     * 
     * @type {number}
     * @memberof VideoRecordingPart
     */
    'buffer_index': number;
    /**
     * 
     * @type {number}
     * @memberof VideoRecordingPart
     */
    'buffer_runningtime': number;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'mp4_file': string;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'sync_start': string;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'sync_end': string;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingPart
     */
    'video_recording': string;
    /**
     * 
     * @type {number}
     * @memberof VideoRecordingPart
     */
    'user': number;
}
/**
 * 
 * @export
 * @interface VideoRecordingRequest
 */
export interface VideoRecordingRequest {
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VideoRecordingRequest
     */
    'cloud_sync_done'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'finalize_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'finalize_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'recording_start'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'recording_end'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VideoRecordingRequest
     */
    'gcode_file_name'?: string | null;
}
/**
 * 
 * @export
 * @interface WebrtcStream
 */
export interface WebrtcStream {
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStream
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'admin_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'admin_secret': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'admin_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_domain': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'api_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_token': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'api_url': string;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof WebrtcStream
     */
    'config_type'?: JanusConfigType;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'created_dt': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'id': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WebrtcStream
     */
    'info': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStream
     */
    'is_admin': boolean;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'pi': number;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'pt': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'rtp_domain': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'video_rtp_port': number | null;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'data_rtp_port': number | null;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'rtpmap': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'stream_pin': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'stream_secret': string;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'updated_dt': string;
    /**
     * 
     * @type {number}
     * @memberof WebrtcStream
     */
    'ws_port': number;
    /**
     * 
     * @type {string}
     * @memberof WebrtcStream
     */
    'ws_url': string;
}
/**
 * 
 * @export
 * @interface WebrtcStreamRequest
 */
export interface WebrtcStreamRequest {
    /**
     * 
     * @type {boolean}
     * @memberof WebrtcStreamRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {JanusConfigType}
     * @memberof WebrtcStreamRequest
     */
    'config_type'?: JanusConfigType;
}
/**
 * 
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {number}
     * @memberof Workspace
     */
    'id': number;
    /**
     * 
     * @type {Array<User>}
     * @memberof Workspace
     */
    'users': Array<User>;
    /**
     * 
     * @type {WorkspaceOwner}
     * @memberof Workspace
     */
    'owner': WorkspaceOwner;
    /**
     * The name of the organization
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof Workspace
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'modified': string;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof Workspace
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface WorkspaceOwner
 */
export interface WorkspaceOwner {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceOwner
     */
    'id': number;
    /**
     * 
     * @type {WorkspaceUser}
     * @memberof WorkspaceOwner
     */
    'organization_user': WorkspaceUser;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceOwner
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceOwner
     */
    'modified': string;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceOwner
     */
    'organization': number;
}
/**
 * 
 * @export
 * @interface WorkspaceOwnerRequest
 */
export interface WorkspaceOwnerRequest {
    /**
     * 
     * @type {WorkspaceUserRequest}
     * @memberof WorkspaceOwnerRequest
     */
    'organization_user': WorkspaceUserRequest;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceOwnerRequest
     */
    'organization': number;
}
/**
 * 
 * @export
 * @interface WorkspaceRequest
 */
export interface WorkspaceRequest {
    /**
     * The name of the organization
     * @type {string}
     * @memberof WorkspaceRequest
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceRequest
     */
    'is_active'?: boolean;
    /**
     * The name in all lowercase, suitable for URL identification
     * @type {string}
     * @memberof WorkspaceRequest
     */
    'slug': string;
}
/**
 * 
 * @export
 * @interface WorkspaceUser
 */
export interface WorkspaceUser {
    /**
     * 
     * @type {number}
     * @memberof WorkspaceUser
     */
    'id': number;
    /**
     * 
     * @type {User}
     * @memberof WorkspaceUser
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUser
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceUser
     */
    'modified': string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUser
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceUser
     */
    'organization': number;
}
/**
 * 
 * @export
 * @interface WorkspaceUserRequest
 */
export interface WorkspaceUserRequest {
    /**
     * 
     * @type {UserRequest}
     * @memberof WorkspaceUserRequest
     */
    'user': UserRequest;
    /**
     * 
     * @type {boolean}
     * @memberof WorkspaceUserRequest
     */
    'is_admin'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceUserRequest
     */
    'organization': number;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthEmailCreate: async (emailAuthRequest: EmailAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailAuthRequest' is not null or undefined
            assertParamExists('accounts2faAuthEmailCreate', 'emailAuthRequest', emailAuthRequest)
            const localVarPath = `/accounts/2fa-auth/email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persist a user id and a backend in the request. This way a user doesn\'t have to reauthenticate on every request. Note that data set during the anonymous session is retained when the user logs in.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthSessionCreate: async (callbackTokenAuthRequest: CallbackTokenAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenAuthRequest' is not null or undefined
            assertParamExists('accounts2faAuthSessionCreate', 'callbackTokenAuthRequest', callbackTokenAuthRequest)
            const localVarPath = `/accounts/2fa-auth/session/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthTokenCreate: async (callbackTokenAuthRequest: CallbackTokenAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callbackTokenAuthRequest' is not null or undefined
            assertParamExists('accounts2faAuthTokenCreate', 'callbackTokenAuthRequest', callbackTokenAuthRequest)
            const localVarPath = `/accounts/2fa-auth/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(callbackTokenAuthRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsEmailWaitlistCreate: async (emailWaitlistRequest: EmailWaitlistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailWaitlistRequest' is not null or undefined
            assertParamExists('accountsEmailWaitlistCreate', 'emailWaitlistRequest', emailWaitlistRequest)
            const localVarPath = `/api/accounts/email-waitlist/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailWaitlistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate: async (loginRequest: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('accountsLoginCreate', 'loginRequest', loginRequest)
            const localVarPath = `/api/accounts/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordChangeCreate: async (passwordChangeRequest: PasswordChangeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChangeRequest' is not null or undefined
            assertParamExists('accountsPasswordChangeCreate', 'passwordChangeRequest', passwordChangeRequest)
            const localVarPath = `/api/accounts/password/change/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChangeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate: async (passwordResetConfirmRequest: PasswordResetConfirmRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetConfirmRequest' is not null or undefined
            assertParamExists('accountsPasswordResetConfirmCreate', 'passwordResetConfirmRequest', passwordResetConfirmRequest)
            const localVarPath = `/api/accounts/password/reset/confirm/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetConfirmRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate: async (passwordResetRequest: PasswordResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordResetRequest' is not null or undefined
            assertParamExists('accountsPasswordResetCreate', 'passwordResetRequest', passwordResetRequest)
            const localVarPath = `/api/accounts/password/reset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationCreate: async (registerRequest: RegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('accountsRegistrationCreate', 'registerRequest', registerRequest)
            const localVarPath = `/api/accounts/registration/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationResendEmailCreate: async (resendEmailVerificationRequest: ResendEmailVerificationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resendEmailVerificationRequest' is not null or undefined
            assertParamExists('accountsRegistrationResendEmailCreate', 'resendEmailVerificationRequest', resendEmailVerificationRequest)
            const localVarPath = `/api/accounts/registration/resend-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendEmailVerificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationVerifyEmailCreate: async (verifyEmailRequest: VerifyEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailRequest' is not null or undefined
            assertParamExists('accountsRegistrationVerifyEmailCreate', 'verifyEmailRequest', verifyEmailRequest)
            const localVarPath = `/api/accounts/registration/verify-email/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserNkeyRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/nkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserPartialUpdate: async (patchedUserRequest?: PatchedUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserUpdate: async (userRequest: UserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('accountsUserUpdate', 'userRequest', userRequest)
            const localVarPath = `/api/accounts/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts2faAuthEmailCreate(emailAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Persist a user id and a backend in the request. This way a user doesn\'t have to reauthenticate on every request. Note that data set during the anonymous session is retained when the user logs in.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts2faAuthSessionCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallbackTokenAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts2faAuthSessionCreate(callbackTokenAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallbackTokenAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts2faAuthTokenCreate(callbackTokenAuthRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailWaitlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsEmailWaitlistCreate(emailWaitlistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLoginCreate(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsLogoutCreate(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsLogoutCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordChangeCreate(passwordChangeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsPasswordResetCreate(passwordResetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationCreate(registerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestAuthDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserNkeyRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NatsOrganizationUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserNkeyRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserPartialUpdate(patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsUserUpdate(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
         * @param {EmailAuthRequest} emailAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: any): AxiosPromise<EmailAuth> {
            return localVarFp.accounts2faAuthEmailCreate(emailAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Persist a user id and a backend in the request. This way a user doesn\'t have to reauthenticate on every request. Note that data set during the anonymous session is retained when the user logs in.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthSessionCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<CallbackTokenAuth> {
            return localVarFp.accounts2faAuthSessionCreate(callbackTokenAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
         * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: any): AxiosPromise<CallbackTokenAuth> {
            return localVarFp.accounts2faAuthTokenCreate(callbackTokenAuthRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {EmailWaitlistRequest} emailWaitlistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: any): AxiosPromise<EmailWaitlist> {
            return localVarFp.accountsEmailWaitlistCreate(emailWaitlistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLoginCreate(loginRequest: LoginRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.accountsLoginCreate(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsLogoutCreate(options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsLogoutCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordChangeRequest} passwordChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordChangeCreate(passwordChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
         * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
         * @param {PasswordResetRequest} passwordResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsPasswordResetCreate(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationCreate(registerRequest: RegisterRequest, options?: any): AxiosPromise<Token> {
            return localVarFp.accountsRegistrationCreate(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyEmailRequest} verifyEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: any): AxiosPromise<RestAuthDetail> {
            return localVarFp.accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Providers user nkey credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserNkeyRetrieve(options?: any): AxiosPromise<NatsOrganizationUser> {
            return localVarFp.accountsUserNkeyRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserPartialUpdate(patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserRetrieve(options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
         * @param {UserRequest} userRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsUserUpdate(userRequest: UserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.accountsUserUpdate(userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - interface
 * @export
 * @interface AccountsApi
 */
export interface AccountsApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAuth>;

    /**
     * Persist a user id and a backend in the request. This way a user doesn\'t have to reauthenticate on every request. Note that data set during the anonymous session is retained when the user logs in.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accounts2faAuthSessionCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): AxiosPromise<CallbackTokenAuth>;

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig): AxiosPromise<CallbackTokenAuth>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {EmailWaitlistRequest} emailWaitlistRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig): AxiosPromise<EmailWaitlist>;

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig): AxiosPromise<Token>;

    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsLogoutCreate(options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @param {PasswordResetRequest} passwordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig): AxiosPromise<Token>;

    /**
     * 
     * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * 
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig): AxiosPromise<RestAuthDetail>;

    /**
     * Providers user nkey credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserNkeyRetrieve(options?: AxiosRequestConfig): AxiosPromise<NatsOrganizationUser>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserRetrieve(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApiInterface
     */
    accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig): AxiosPromise<User>;

}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI implements AccountsApiInterface {
    /**
     * This returns a 6-digit callback token we can trade for a user\'s Auth Token.
     * @param {EmailAuthRequest} emailAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accounts2faAuthEmailCreate(emailAuthRequest: EmailAuthRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accounts2faAuthEmailCreate(emailAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Persist a user id and a backend in the request. This way a user doesn\'t have to reauthenticate on every request. Note that data set during the anonymous session is retained when the user logs in.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accounts2faAuthSessionCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accounts2faAuthSessionCreate(callbackTokenAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a duplicate of rest_framework\'s own ObtainAuthToken method. Instead, this returns an Auth Token based on our callback token and source.
     * @param {CallbackTokenAuthRequest} callbackTokenAuthRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accounts2faAuthTokenCreate(callbackTokenAuthRequest: CallbackTokenAuthRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accounts2faAuthTokenCreate(callbackTokenAuthRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {EmailWaitlistRequest} emailWaitlistRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsEmailWaitlistCreate(emailWaitlistRequest: EmailWaitlistRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsEmailWaitlistCreate(emailWaitlistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the credentials and return the REST Token if the credentials are valid and authenticated. Calls Django Auth login method to register User ID in Django session framework  Accept the following POST parameters: username, password Return the REST Framework Token Object\'s key.
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLoginCreate(loginRequest: LoginRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLoginCreate(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django logout method and delete the Token object assigned to the current User object.  Accepts/Returns nothing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsLogoutCreate(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsLogoutCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django Auth SetPasswordForm save method.  Accepts the following POST parameters: new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordChangeRequest} passwordChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordChangeCreate(passwordChangeRequest: PasswordChangeRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordChangeCreate(passwordChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Password reset e-mail link is confirmed, therefore this resets the user\'s password.  Accepts the following POST parameters: token, uid,     new_password1, new_password2 Returns the success/fail message.
     * @param {PasswordResetConfirmRequest} passwordResetConfirmRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetConfirmCreate(passwordResetConfirmRequest: PasswordResetConfirmRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetConfirmCreate(passwordResetConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calls Django Auth PasswordResetForm save method.  Accepts the following POST parameters: email Returns the success/fail message.
     * @param {PasswordResetRequest} passwordResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsPasswordResetCreate(passwordResetRequest: PasswordResetRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsPasswordResetCreate(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationCreate(registerRequest: RegisterRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationCreate(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ResendEmailVerificationRequest} resendEmailVerificationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationResendEmailCreate(resendEmailVerificationRequest: ResendEmailVerificationRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationResendEmailCreate(resendEmailVerificationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyEmailRequest} verifyEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsRegistrationVerifyEmailCreate(verifyEmailRequest: VerifyEmailRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsRegistrationVerifyEmailCreate(verifyEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Providers user nkey credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserNkeyRetrieve(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserNkeyRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserPartialUpdate(patchedUserRequest?: PatchedUserRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserPartialUpdate(patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserRetrieve(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reads and updates UserModel fields Accepts GET, PUT, PATCH methods.  Default accepted fields: username, first_name, last_name Default display fields: pk, username, email, first_name, last_name Read-only fields: pk, email  Returns UserModel fields.
     * @param {UserRequest} userRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsUserUpdate(userRequest: UserRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsUserUpdate(userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AchievementsApi - axios parameter creator
 * @export
 */
export const AchievementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/achievements/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AchievementsApi - functional programming interface
 * @export
 */
export const AchievementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AchievementsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async achievementsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAchievementList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.achievementsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AchievementsApi - factory interface
 * @export
 */
export const AchievementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AchievementsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        achievementsList(page?: number, options?: any): AxiosPromise<PaginatedAchievementList> {
            return localVarFp.achievementsList(page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AchievementsApi - interface
 * @export
 * @interface AchievementsApi
 */
export interface AchievementsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApiInterface
     */
    achievementsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedAchievementList>;

}

/**
 * AchievementsApi - object-oriented interface
 * @export
 * @class AchievementsApi
 * @extends {BaseAPI}
 */
export class AchievementsApi extends BaseAPI implements AchievementsApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AchievementsApi
     */
    public achievementsList(page?: number, options?: AxiosRequestConfig) {
        return AchievementsApiFp(this.configuration).achievementsList(page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobCreate: async (printJobAlertRequest: PrintJobAlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'printJobAlertRequest' is not null or undefined
            assertParamExists('alertsPrintJobCreate', 'printJobAlertRequest', printJobAlertRequest)
            const localVarPath = `/api/alerts/print-job/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printJobAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/alerts/print-job/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PatchedPrintJobAlertRequest} [patchedPrintJobAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobPartialUpdate: async (id: string, patchedPrintJobAlertRequest?: PatchedPrintJobAlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsPrintJobPartialUpdate', 'id', id)
            const localVarPath = `/api/alerts/print-job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPrintJobAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsPrintJobRetrieve', 'id', id)
            const localVarPath = `/api/alerts/print-job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobUpdate: async (id: string, printJobAlertRequest: PrintJobAlertRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('alertsPrintJobUpdate', 'id', id)
            // verify required parameter 'printJobAlertRequest' is not null or undefined
            assertParamExists('alertsPrintJobUpdate', 'printJobAlertRequest', printJobAlertRequest)
            const localVarPath = `/api/alerts/print-job/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(printJobAlertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsCreate: async (emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/email-alert-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsPartialUpdate: async (id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('emailAlertSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/email-alert-settings//{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEmailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/email-alert-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsUpdate: async (id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('emailAlertSettingsUpdate', 'id', id)
            const localVarPath = `/api/email-alert-settings//{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPrintJobCreate(printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintJobAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPrintJobCreate(printJobAlertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPrintJobList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPrintJobAlertList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPrintJobList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PatchedPrintJobAlertRequest} [patchedPrintJobAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPrintJobPartialUpdate(id: string, patchedPrintJobAlertRequest?: PatchedPrintJobAlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintJobAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPrintJobPartialUpdate(id, patchedPrintJobAlertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPrintJobRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintJobAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPrintJobRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertsPrintJobUpdate(id: string, printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrintJobAlert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertsPrintJobUpdate(id, printJobAlertRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsCreate(emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * 
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobCreate(printJobAlertRequest: PrintJobAlertRequest, options?: any): AxiosPromise<PrintJobAlert> {
            return localVarFp.alertsPrintJobCreate(printJobAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobList(page?: number, options?: any): AxiosPromise<PaginatedPrintJobAlertList> {
            return localVarFp.alertsPrintJobList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PatchedPrintJobAlertRequest} [patchedPrintJobAlertRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobPartialUpdate(id: string, patchedPrintJobAlertRequest?: PatchedPrintJobAlertRequest, options?: any): AxiosPromise<PrintJobAlert> {
            return localVarFp.alertsPrintJobPartialUpdate(id, patchedPrintJobAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobRetrieve(id: string, options?: any): AxiosPromise<PrintJobAlert> {
            return localVarFp.alertsPrintJobRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this print job alert.
         * @param {PrintJobAlertRequest} printJobAlertRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertsPrintJobUpdate(id: string, printJobAlertRequest: PrintJobAlertRequest, options?: any): AxiosPromise<PrintJobAlert> {
            return localVarFp.alertsPrintJobUpdate(id, printJobAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsCreate(emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsRetrieve(options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - interface
 * @export
 * @interface AlertsApi
 */
export interface AlertsApiInterface {
    /**
     * 
     * @param {PrintJobAlertRequest} printJobAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPrintJobCreate(printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig): AxiosPromise<PrintJobAlert>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPrintJobList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPrintJobAlertList>;

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {PatchedPrintJobAlertRequest} [patchedPrintJobAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPrintJobPartialUpdate(id: string, patchedPrintJobAlertRequest?: PatchedPrintJobAlertRequest, options?: AxiosRequestConfig): AxiosPromise<PrintJobAlert>;

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPrintJobRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<PrintJobAlert>;

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {PrintJobAlertRequest} printJobAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    alertsPrintJobUpdate(id: string, printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig): AxiosPromise<PrintJobAlert>;

    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id 
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    emailAlertSettingsRetrieve(options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApiInterface
     */
    emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI implements AlertsApiInterface {
    /**
     * 
     * @param {PrintJobAlertRequest} printJobAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPrintJobCreate(printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPrintJobCreate(printJobAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPrintJobList(page?: number, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPrintJobList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {PatchedPrintJobAlertRequest} [patchedPrintJobAlertRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPrintJobPartialUpdate(id: string, patchedPrintJobAlertRequest?: PatchedPrintJobAlertRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPrintJobPartialUpdate(id, patchedPrintJobAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPrintJobRetrieve(id: string, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPrintJobRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this print job alert.
     * @param {PrintJobAlertRequest} printJobAlertRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public alertsPrintJobUpdate(id: string, printJobAlertRequest: PrintJobAlertRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).alertsPrintJobUpdate(id, printJobAlertRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).emailAlertSettingsCreate(emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public emailAlertSettingsRetrieve(options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).emailAlertSettingsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return AlertsApiFp(this.configuration).emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CrashReportsApi - axios parameter creator
 * @export
 */
export const CrashReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsCreate: async (description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/crash-reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/crash-reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsPartialUpdate: async (id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsPartialUpdate', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsRetrieve', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsUpdate: async (id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('crashReportsUpdate', 'id', id)
            const localVarPath = `/api/crash-reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (osVersion !== undefined) { 
                localVarFormParams.append('os_version', osVersion as any);
            }
    
            if (osLogs !== undefined) { 
                localVarFormParams.append('os_logs', osLogs as any);
            }
    
            if (browserVersion !== undefined) { 
                localVarFormParams.append('browser_version', browserVersion as any);
            }
    
            if (browserLogs !== undefined) { 
                localVarFormParams.append('browser_logs', browserLogs as any);
            }
    
            if (serial !== undefined) { 
                localVarFormParams.append('serial', serial as any);
            }
    
            if (posthogSession !== undefined) { 
                localVarFormParams.append('posthog_session', posthogSession as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.append('status', new Blob([JSON.stringify(status)], { type: "application/json", }));
            }
    
            if (supportComment !== undefined) { 
                localVarFormParams.append('support_comment', supportComment as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CrashReportsApi - functional programming interface
 * @export
 */
export const CrashReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CrashReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCrashReportList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CrashReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CrashReportsApi - factory interface
 * @export
 */
export const CrashReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CrashReportsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsList(page?: number, options?: any): AxiosPromise<PaginatedCrashReportList> {
            return localVarFp.crashReportsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsRetrieve(id: string, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this crash report.
         * @param {string} [description] 
         * @param {string} [email] 
         * @param {string} [osVersion] 
         * @param {any} [osLogs] 
         * @param {string} [browserVersion] 
         * @param {any} [browserLogs] 
         * @param {string} [serial] 
         * @param {string} [posthogSession] 
         * @param {CrashReportStatusEnum} [status] 
         * @param {string} [supportComment] 
         * @param {number} [pi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: any): AxiosPromise<CrashReport> {
            return localVarFp.crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CrashReportsApi - interface
 * @export
 * @interface CrashReportsApi
 */
export interface CrashReportsApiInterface {
    /**
     * 
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedCrashReportList>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApiInterface
     */
    crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig): AxiosPromise<CrashReport>;

}

/**
 * CrashReportsApi - object-oriented interface
 * @export
 * @class CrashReportsApi
 * @extends {BaseAPI}
 */
export class CrashReportsApi extends BaseAPI implements CrashReportsApiInterface {
    /**
     * 
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsCreate(description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsCreate(description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsList(page?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsPartialUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsPartialUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsRetrieve(id: string, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this crash report.
     * @param {string} [description] 
     * @param {string} [email] 
     * @param {string} [osVersion] 
     * @param {any} [osLogs] 
     * @param {string} [browserVersion] 
     * @param {any} [browserLogs] 
     * @param {string} [serial] 
     * @param {string} [posthogSession] 
     * @param {CrashReportStatusEnum} [status] 
     * @param {string} [supportComment] 
     * @param {number} [pi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CrashReportsApi
     */
    public crashReportsUpdate(id: string, description?: string, email?: string, osVersion?: string, osLogs?: any, browserVersion?: string, browserLogs?: any, serial?: string, posthogSession?: string, status?: CrashReportStatusEnum, supportComment?: string, pi?: number, options?: AxiosRequestConfig) {
        return CrashReportsApiFp(this.configuration).crashReportsUpdate(id, description, email, osVersion, osLogs, browserVersion, browserLogs, serial, posthogSession, status, supportComment, pi, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DemosApi - axios parameter creator
 * @export
 */
export const DemosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} email 
         * @param {any} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosCreate: async (email: string, submission: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('demosCreate', 'email', email)
            // verify required parameter 'submission' is not null or undefined
            assertParamExists('demosCreate', 'submission', submission)
            const localVarPath = `/api/demos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (submission !== undefined) { 
                localVarFormParams.append('submission', submission as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {PatchedDemoSubmissionFeedbackRequest} [patchedDemoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackPartialUpdate: async (id: string, patchedDemoSubmissionFeedbackRequest?: PatchedDemoSubmissionFeedbackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demosFeedbackPartialUpdate', 'id', id)
            const localVarPath = `/api/demos/feedback/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedDemoSubmissionFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demosFeedbackRetrieve', 'id', id)
            const localVarPath = `/api/demos/feedback/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {DemoSubmissionFeedbackRequest} [demoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackUpdate: async (id: string, demoSubmissionFeedbackRequest?: DemoSubmissionFeedbackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demosFeedbackUpdate', 'id', id)
            const localVarPath = `/api/demos/feedback/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(demoSubmissionFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demosRetrieve', 'id', id)
            const localVarPath = `/api/demos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemosApi - functional programming interface
 * @export
 */
export const DemosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DemosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {any} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demosCreate(email: string, submission: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemoSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demosCreate(email, submission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {PatchedDemoSubmissionFeedbackRequest} [patchedDemoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demosFeedbackPartialUpdate(id: string, patchedDemoSubmissionFeedbackRequest?: PatchedDemoSubmissionFeedbackRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemoSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demosFeedbackPartialUpdate(id, patchedDemoSubmissionFeedbackRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demosFeedbackRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemoSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demosFeedbackRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {DemoSubmissionFeedbackRequest} [demoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demosFeedbackUpdate(id: string, demoSubmissionFeedbackRequest?: DemoSubmissionFeedbackRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemoSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demosFeedbackUpdate(id, demoSubmissionFeedbackRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demosRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DemoSubmission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demosRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DemosApi - factory interface
 * @export
 */
export const DemosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DemosApiFp(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {any} submission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosCreate(email: string, submission: any, options?: any): AxiosPromise<DemoSubmission> {
            return localVarFp.demosCreate(email, submission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {PatchedDemoSubmissionFeedbackRequest} [patchedDemoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackPartialUpdate(id: string, patchedDemoSubmissionFeedbackRequest?: PatchedDemoSubmissionFeedbackRequest, options?: any): AxiosPromise<DemoSubmission> {
            return localVarFp.demosFeedbackPartialUpdate(id, patchedDemoSubmissionFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackRetrieve(id: string, options?: any): AxiosPromise<DemoSubmission> {
            return localVarFp.demosFeedbackRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {DemoSubmissionFeedbackRequest} [demoSubmissionFeedbackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosFeedbackUpdate(id: string, demoSubmissionFeedbackRequest?: DemoSubmissionFeedbackRequest, options?: any): AxiosPromise<DemoSubmission> {
            return localVarFp.demosFeedbackUpdate(id, demoSubmissionFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this demo submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demosRetrieve(id: string, options?: any): AxiosPromise<DemoSubmission> {
            return localVarFp.demosRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DemosApi - interface
 * @export
 * @interface DemosApi
 */
export interface DemosApiInterface {
    /**
     * 
     * @param {string} email 
     * @param {any} submission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApiInterface
     */
    demosCreate(email: string, submission: any, options?: AxiosRequestConfig): AxiosPromise<DemoSubmission>;

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {PatchedDemoSubmissionFeedbackRequest} [patchedDemoSubmissionFeedbackRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApiInterface
     */
    demosFeedbackPartialUpdate(id: string, patchedDemoSubmissionFeedbackRequest?: PatchedDemoSubmissionFeedbackRequest, options?: AxiosRequestConfig): AxiosPromise<DemoSubmission>;

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApiInterface
     */
    demosFeedbackRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<DemoSubmission>;

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {DemoSubmissionFeedbackRequest} [demoSubmissionFeedbackRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApiInterface
     */
    demosFeedbackUpdate(id: string, demoSubmissionFeedbackRequest?: DemoSubmissionFeedbackRequest, options?: AxiosRequestConfig): AxiosPromise<DemoSubmission>;

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApiInterface
     */
    demosRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<DemoSubmission>;

}

/**
 * DemosApi - object-oriented interface
 * @export
 * @class DemosApi
 * @extends {BaseAPI}
 */
export class DemosApi extends BaseAPI implements DemosApiInterface {
    /**
     * 
     * @param {string} email 
     * @param {any} submission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApi
     */
    public demosCreate(email: string, submission: any, options?: AxiosRequestConfig) {
        return DemosApiFp(this.configuration).demosCreate(email, submission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {PatchedDemoSubmissionFeedbackRequest} [patchedDemoSubmissionFeedbackRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApi
     */
    public demosFeedbackPartialUpdate(id: string, patchedDemoSubmissionFeedbackRequest?: PatchedDemoSubmissionFeedbackRequest, options?: AxiosRequestConfig) {
        return DemosApiFp(this.configuration).demosFeedbackPartialUpdate(id, patchedDemoSubmissionFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApi
     */
    public demosFeedbackRetrieve(id: string, options?: AxiosRequestConfig) {
        return DemosApiFp(this.configuration).demosFeedbackRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {DemoSubmissionFeedbackRequest} [demoSubmissionFeedbackRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApi
     */
    public demosFeedbackUpdate(id: string, demoSubmissionFeedbackRequest?: DemoSubmissionFeedbackRequest, options?: AxiosRequestConfig) {
        return DemosApiFp(this.configuration).demosFeedbackUpdate(id, demoSubmissionFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this demo submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemosApi
     */
    public demosRetrieve(id: string, options?: AxiosRequestConfig) {
        return DemosApiFp(this.configuration).demosRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsCreate: async (networkSettingsRequest: NetworkSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSettingsRequest' is not null or undefined
            assertParamExists('networkSettingsCreate', 'networkSettingsRequest', networkSettingsRequest)
            const localVarPath = `/api/network-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNetworkSettingsRequest} [patchedNetworkSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsPartialUpdate: async (id: number, patchedNetworkSettingsRequest?: PatchedNetworkSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/network-settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedNetworkSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/network-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsUpdate: async (id: number, networkSettingsRequest: NetworkSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSettingsUpdate', 'id', id)
            // verify required parameter 'networkSettingsRequest' is not null or undefined
            assertParamExists('networkSettingsUpdate', 'networkSettingsRequest', networkSettingsRequest)
            const localVarPath = `/api/network-settings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        piUpdateOrCreate: async (piRequest: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piRequest' is not null or undefined
            assertParamExists('piUpdateOrCreate', 'piRequest', piRequest)
            const localVarPath = `/api/pis/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCreate: async (piRequest: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piRequest' is not null or undefined
            assertParamExists('pisCreate', 'piRequest', piRequest)
            const localVarPath = `/api/pis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisDestroy', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisLicenseZipRetrieve: async (piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisLicenseZipRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/license/zip/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisPartialUpdate: async (id: number, patchedPiRequest?: PatchedPiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisPartialUpdate', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisRetrieve', 'id', id)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoCreate: async (piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoCreate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('pisSystemInfoCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoPartialUpdate: async (id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSystemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoUpdate: async (id: number, piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('pisSystemInfoUpdate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisUpdate: async (id: number, piRequest: PiRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisUpdate', 'id', id)
            // verify required parameter 'piRequest' is not null or undefined
            assertParamExists('pisUpdate', 'piRequest', piRequest)
            const localVarPath = `/api/pis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(piRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate: async (id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate: async (id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate: async (piId: number, systemInfoRequest: SystemInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'piId', piId)
            // verify required parameter 'systemInfoRequest' is not null or undefined
            assertParamExists('systemInfoUpdateOrCreate', 'systemInfoRequest', systemInfoRequest)
            const localVarPath = `/api/pis/{pi_id}/system-info/update-or-create/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(systemInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webrtcStreamUpdateOrCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('webrtcStreamUpdateOrCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/update-or-create/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSettingsCreate(networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSettingsCreate(networkSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNetworkSettingsRequest} [patchedNetworkSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSettingsPartialUpdate(id: number, patchedNetworkSettingsRequest?: PatchedNetworkSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSettingsPartialUpdate(id, patchedNetworkSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSettingsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSettingsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSettingsUpdate(id: number, networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSettingsUpdate(id, networkSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async piUpdateOrCreate(piRequest: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.piUpdateOrCreate(piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCreate(piRequest: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCreate(piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisLicenseZipRetrieve(piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPiList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisPartialUpdate(id, patchedPiRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoCreate(piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSystemInfoList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisSystemInfoUpdate(id, piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisUpdate(id: number, piRequest: PiRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisUpdate(id, piRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebrtcStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfoUpdateOrCreate(piId, systemInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsCreate(networkSettingsRequest: NetworkSettingsRequest, options?: any): AxiosPromise<NetworkSettings> {
            return localVarFp.networkSettingsCreate(networkSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedNetworkSettingsRequest} [patchedNetworkSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsPartialUpdate(id: number, patchedNetworkSettingsRequest?: PatchedNetworkSettingsRequest, options?: any): AxiosPromise<NetworkSettings> {
            return localVarFp.networkSettingsPartialUpdate(id, patchedNetworkSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsRetrieve(options?: any): AxiosPromise<NetworkSettings> {
            return localVarFp.networkSettingsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {NetworkSettingsRequest} networkSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSettingsUpdate(id: number, networkSettingsRequest: NetworkSettingsRequest, options?: any): AxiosPromise<NetworkSettings> {
            return localVarFp.networkSettingsUpdate(id, networkSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        piUpdateOrCreate(piRequest: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.piUpdateOrCreate(piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCreate(piRequest: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisCreate(piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.pisDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisLicenseZipRetrieve(piId: number, options?: any): AxiosPromise<any> {
            return localVarFp.pisLicenseZipRetrieve(piId, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisList(page?: number, options?: any): AxiosPromise<PaginatedPiList> {
            return localVarFp.pisList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PatchedPiRequest} [patchedPiRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisPartialUpdate(id, patchedPiRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisRetrieve(id: number, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoCreate(piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedSystemInfoList> {
            return localVarFp.pisSystemInfoList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoRetrieve(id: number, piId: number, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this system info.
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.pisSystemInfoUpdate(id, piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * A device (Raspberry Pi) running Print Nanny OS
         * @param {number} id A unique integer value identifying this pi.
         * @param {PiRequest} piRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisUpdate(id: number, piRequest: PiRequest, options?: any): AxiosPromise<Pi> {
            return localVarFp.pisUpdate(id, piRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedWebrtcStreamList> {
            return localVarFp.pisWebrtcStreamsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve(id: number, piId: number, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {SystemInfoRequest} systemInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.systemInfoUpdateOrCreate(piId, systemInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - interface
 * @export
 * @interface DevicesApi
 */
export interface DevicesApiInterface {
    /**
     * 
     * @param {NetworkSettingsRequest} networkSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    networkSettingsCreate(networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<NetworkSettings>;

    /**
     * 
     * @param {number} id 
     * @param {PatchedNetworkSettingsRequest} [patchedNetworkSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    networkSettingsPartialUpdate(id: number, patchedNetworkSettingsRequest?: PatchedNetworkSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<NetworkSettings>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    networkSettingsRetrieve(options?: AxiosRequestConfig): AxiosPromise<NetworkSettings>;

    /**
     * 
     * @param {number} id 
     * @param {NetworkSettingsRequest} networkSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    networkSettingsUpdate(id: number, networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<NetworkSettings>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    piUpdateOrCreate(piRequest: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisCreate(piRequest: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisDestroy(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig): AxiosPromise<any>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedPiList>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PatchedPiRequest} [patchedPiRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedSystemInfoList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisUpdate(id: number, piRequest: PiRequest, options?: AxiosRequestConfig): AxiosPromise<Pi>;

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedWebrtcStreamList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig): AxiosPromise<SystemInfo>;

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI implements DevicesApiInterface {
    /**
     * 
     * @param {NetworkSettingsRequest} networkSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public networkSettingsCreate(networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).networkSettingsCreate(networkSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedNetworkSettingsRequest} [patchedNetworkSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public networkSettingsPartialUpdate(id: number, patchedNetworkSettingsRequest?: PatchedNetworkSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).networkSettingsPartialUpdate(id, patchedNetworkSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public networkSettingsRetrieve(options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).networkSettingsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {NetworkSettingsRequest} networkSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public networkSettingsUpdate(id: number, networkSettingsRequest: NetworkSettingsRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).networkSettingsUpdate(id, networkSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public piUpdateOrCreate(piRequest: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).piUpdateOrCreate(piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisCreate(piRequest: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisCreate(piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisDestroy(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisLicenseZipRetrieve(piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisLicenseZipRetrieve(piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisList(page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PatchedPiRequest} [patchedPiRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisPartialUpdate(id: number, patchedPiRequest?: PatchedPiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisPartialUpdate(id, patchedPiRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisRetrieve(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoCreate(piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {PatchedSystemInfoRequest} [patchedSystemInfoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoPartialUpdate(id: number, piId: number, patchedSystemInfoRequest?: PatchedSystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoPartialUpdate(id, piId, patchedSystemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this system info.
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisSystemInfoUpdate(id: number, piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisSystemInfoUpdate(id, piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A device (Raspberry Pi) running Print Nanny OS
     * @param {number} id A unique integer value identifying this pi.
     * @param {PiRequest} piRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisUpdate(id: number, piRequest: PiRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisUpdate(id, piRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {SystemInfoRequest} systemInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public systemInfoUpdateOrCreate(piId: number, systemInfoRequest: SystemInfoRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).systemInfoUpdateOrCreate(piId, systemInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public webrtcStreamUpdateOrCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).webrtcStreamUpdateOrCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JanusApi - axios parameter creator
 * @export
 */
export const JanusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate: async (piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsCreate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate: async (id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsPartialUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve: async (id: number, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate: async (id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisWebrtcStreamsUpdate', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/webrtc-streams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webrtcStreamRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JanusApi - functional programming interface
 * @export
 */
export const JanusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JanusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWebrtcStreamList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebrtcStream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JanusApi - factory interface
 * @export
 */
export const JanusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JanusApiFp(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedWebrtcStreamList> {
            return localVarFp.pisWebrtcStreamsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsRetrieve(id: number, piId: number, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webrtc stream.
         * @param {number} piId 
         * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: any): AxiosPromise<WebrtcStream> {
            return localVarFp.pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JanusApi - interface
 * @export
 * @interface JanusApi
 */
export interface JanusApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedWebrtcStreamList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApiInterface
     */
    pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig): AxiosPromise<WebrtcStream>;

}

/**
 * JanusApi - object-oriented interface
 * @export
 * @class JanusApi
 * @extends {BaseAPI}
 */
export class JanusApi extends BaseAPI implements JanusApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsCreate(piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsCreate(piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {PatchedWebrtcStreamRequest} [patchedWebrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsPartialUpdate(id: number, piId: number, patchedWebrtcStreamRequest?: PatchedWebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsPartialUpdate(id, piId, patchedWebrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsRetrieve(id: number, piId: number, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webrtc stream.
     * @param {number} piId 
     * @param {WebrtcStreamRequest} [webrtcStreamRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JanusApi
     */
    public pisWebrtcStreamsUpdate(id: number, piId: number, webrtcStreamRequest?: WebrtcStreamRequest, options?: AxiosRequestConfig) {
        return JanusApiFp(this.configuration).pisWebrtcStreamsUpdate(id, piId, webrtcStreamRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MoonrakerApi - axios parameter creator
 * @export
 */
export const MoonrakerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerCreate: async (moonrakerServerRequest: MoonrakerServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moonrakerServerRequest' is not null or undefined
            assertParamExists('moonrakerCreate', 'moonrakerServerRequest', moonrakerServerRequest)
            const localVarPath = `/api/moonraker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moonrakerServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/moonraker/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {PatchedMoonrakerServerRequest} [patchedMoonrakerServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerPartialUpdate: async (id: number, patchedMoonrakerServerRequest?: PatchedMoonrakerServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moonrakerPartialUpdate', 'id', id)
            const localVarPath = `/api/moonraker/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMoonrakerServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moonrakerRetrieve', 'id', id)
            const localVarPath = `/api/moonraker/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerServerUpdateOrCreate: async (moonrakerServerRequest: MoonrakerServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moonrakerServerRequest' is not null or undefined
            assertParamExists('moonrakerServerUpdateOrCreate', 'moonrakerServerRequest', moonrakerServerRequest)
            const localVarPath = `/api/moonraker/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moonrakerServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerUpdate: async (id: number, moonrakerServerRequest: MoonrakerServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moonrakerUpdate', 'id', id)
            // verify required parameter 'moonrakerServerRequest' is not null or undefined
            assertParamExists('moonrakerUpdate', 'moonrakerServerRequest', moonrakerServerRequest)
            const localVarPath = `/api/moonraker/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moonrakerServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisMoonrakerServerList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisMoonrakerServerList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/moonraker-server/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoonrakerApi - functional programming interface
 * @export
 */
export const MoonrakerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoonrakerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoonrakerServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerCreate(moonrakerServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMoonrakerServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {PatchedMoonrakerServerRequest} [patchedMoonrakerServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerPartialUpdate(id: number, patchedMoonrakerServerRequest?: PatchedMoonrakerServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoonrakerServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerPartialUpdate(id, patchedMoonrakerServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoonrakerServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerServerUpdateOrCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoonrakerServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerServerUpdateOrCreate(moonrakerServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonrakerUpdate(id: number, moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoonrakerServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonrakerUpdate(id, moonrakerServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisMoonrakerServerList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMoonrakerServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisMoonrakerServerList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MoonrakerApi - factory interface
 * @export
 */
export const MoonrakerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoonrakerApiFp(configuration)
    return {
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: any): AxiosPromise<MoonrakerServer> {
            return localVarFp.moonrakerCreate(moonrakerServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerList(page?: number, options?: any): AxiosPromise<PaginatedMoonrakerServerList> {
            return localVarFp.moonrakerList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {PatchedMoonrakerServerRequest} [patchedMoonrakerServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerPartialUpdate(id: number, patchedMoonrakerServerRequest?: PatchedMoonrakerServerRequest, options?: any): AxiosPromise<MoonrakerServer> {
            return localVarFp.moonrakerPartialUpdate(id, patchedMoonrakerServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerRetrieve(id: number, options?: any): AxiosPromise<MoonrakerServer> {
            return localVarFp.moonrakerRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerServerUpdateOrCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: any): AxiosPromise<MoonrakerServer> {
            return localVarFp.moonrakerServerUpdateOrCreate(moonrakerServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this moonraker server.
         * @param {MoonrakerServerRequest} moonrakerServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonrakerUpdate(id: number, moonrakerServerRequest: MoonrakerServerRequest, options?: any): AxiosPromise<MoonrakerServer> {
            return localVarFp.moonrakerUpdate(id, moonrakerServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisMoonrakerServerList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedMoonrakerServerList> {
            return localVarFp.pisMoonrakerServerList(piId, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoonrakerApi - interface
 * @export
 * @interface MoonrakerApi
 */
export interface MoonrakerApiInterface {
    /**
     * 
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): AxiosPromise<MoonrakerServer>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedMoonrakerServerList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {PatchedMoonrakerServerRequest} [patchedMoonrakerServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerPartialUpdate(id: number, patchedMoonrakerServerRequest?: PatchedMoonrakerServerRequest, options?: AxiosRequestConfig): AxiosPromise<MoonrakerServer>;

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<MoonrakerServer>;

    /**
     * 
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerServerUpdateOrCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): AxiosPromise<MoonrakerServer>;

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    moonrakerUpdate(id: number, moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig): AxiosPromise<MoonrakerServer>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApiInterface
     */
    pisMoonrakerServerList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedMoonrakerServerList>;

}

/**
 * MoonrakerApi - object-oriented interface
 * @export
 * @class MoonrakerApi
 * @extends {BaseAPI}
 */
export class MoonrakerApi extends BaseAPI implements MoonrakerApiInterface {
    /**
     * 
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerCreate(moonrakerServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerList(page?: number, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {PatchedMoonrakerServerRequest} [patchedMoonrakerServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerPartialUpdate(id: number, patchedMoonrakerServerRequest?: PatchedMoonrakerServerRequest, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerPartialUpdate(id, patchedMoonrakerServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerRetrieve(id: number, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerServerUpdateOrCreate(moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerServerUpdateOrCreate(moonrakerServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this moonraker server.
     * @param {MoonrakerServerRequest} moonrakerServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public moonrakerUpdate(id: number, moonrakerServerRequest: MoonrakerServerRequest, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).moonrakerUpdate(id, moonrakerServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonrakerApi
     */
    public pisMoonrakerServerList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return MoonrakerApiFp(this.configuration).pisMoonrakerServerList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OctoprintApi - axios parameter creator
 * @export
 */
export const OctoprintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate: async (hostname: string, name: string, octoprintVersion: string, file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hostname' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'hostname', hostname)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'name', name)
            // verify required parameter 'octoprintVersion' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'octoprintVersion', octoprintVersion)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintBackupsCreate', 'file', file)
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (hostname !== undefined) { 
                localVarFormParams.append('hostname', hostname as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (octoprintVersion !== undefined) { 
                localVarFormParams.append('octoprint_version', octoprintVersion as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/backups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintBackupsRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/backups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCreate: async (octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintCreate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate: async (name: string, file: any, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'file', file)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('octoprintGcodeFilesCreate', 'hash', hash)
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (hash !== undefined) { 
                localVarFormParams.append('hash', hash as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/gcode-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintGcodeFilesRetrieve', 'id', id)
            const localVarPath = `/api/octoprint/gcode-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPartialUpdate: async (id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/printer-profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate: async (id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate: async (id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'id', id)
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintPrinterProfilesUpdate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate: async (octoPrinterProfileRequest: OctoPrinterProfileRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrinterProfileRequest' is not null or undefined
            assertParamExists('octoprintProfileUpdateOrCreate', 'octoPrinterProfileRequest', octoPrinterProfileRequest)
            const localVarPath = `/api/octoprint/printer-profiles/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrinterProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintServerUpdateOrCreate: async (octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintServerUpdateOrCreate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate: async (octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsCreate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/octoprint/settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate: async (id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedOctoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate: async (id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintSettingsUpdate', 'id', id)
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsUpdate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate: async (octoPrintSettingsRequest: OctoPrintSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'octoPrintSettingsRequest' is not null or undefined
            assertParamExists('octoprintSettingsUpdateOrCreate', 'octoPrintSettingsRequest', octoPrintSettingsRequest)
            const localVarPath = `/api/octoprint/settings/update-or-create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintUpdate: async (id: number, octoPrintServerRequest: OctoPrintServerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('octoprintUpdate', 'id', id)
            // verify required parameter 'octoPrintServerRequest' is not null or undefined
            assertParamExists('octoprintUpdate', 'octoPrintServerRequest', octoPrintServerRequest)
            const localVarPath = `/api/octoprint/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(octoPrintServerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisOctoprintServerList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisOctoprintServerList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/octoprint-server/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OctoprintApi - functional programming interface
 * @export
 */
export const OctoprintApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OctoprintApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintBackupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintBackup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintBackupsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintCreate(octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesCreate(name, file, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGcodeFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GcodeFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintGcodeFilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrinterProfileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrinterProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintServerUpdateOrCreate(octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintSettingsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OctoPrintServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.octoprintUpdate(id, octoPrintServerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisOctoprintServerList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedOctoPrintServerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisOctoprintServerList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OctoprintApi - factory interface
 * @export
 */
export const OctoprintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OctoprintApiFp(configuration)
    return {
        /**
         * 
         * @param {string} hostname 
         * @param {string} name 
         * @param {string} octoprintVersion 
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintBackupList> {
            return localVarFp.octoprintBackupsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintBackupsRetrieve(id: number, options?: any): AxiosPromise<OctoPrintBackup> {
            return localVarFp.octoprintBackupsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintCreate(octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {string} hash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesList(page?: number, options?: any): AxiosPromise<PaginatedGcodeFileList> {
            return localVarFp.octoprintGcodeFilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this gcode file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintGcodeFilesRetrieve(id: number, options?: any): AxiosPromise<GcodeFile> {
            return localVarFp.octoprintGcodeFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintServerList> {
            return localVarFp.octoprintList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrinterProfileList> {
            return localVarFp.octoprintPrinterProfilesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo printer profile.
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: any): AxiosPromise<OctoPrinterProfile> {
            return localVarFp.octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintServerUpdateOrCreate(octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsList(page?: number, options?: any): AxiosPromise<PaginatedOctoPrintSettingsList> {
            return localVarFp.octoprintSettingsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print settings.
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: any): AxiosPromise<OctoPrintSettings> {
            return localVarFp.octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this octo print server.
         * @param {OctoPrintServerRequest} octoPrintServerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: any): AxiosPromise<OctoPrintServer> {
            return localVarFp.octoprintUpdate(id, octoPrintServerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisOctoprintServerList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedOctoPrintServerList> {
            return localVarFp.pisOctoprintServerList(piId, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OctoprintApi - interface
 * @export
 * @interface OctoprintApi
 */
export interface OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintBackupList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<OctoPrintBackup>;

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedGcodeFileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig): AxiosPromise<GcodeFile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintServerList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrinterProfileList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrinterProfile>;

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintSettingsList>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintSettings>;

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig): AxiosPromise<OctoPrintServer>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApiInterface
     */
    pisOctoprintServerList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedOctoPrintServerList>;

}

/**
 * OctoprintApi - object-oriented interface
 * @export
 * @class OctoprintApi
 * @extends {BaseAPI}
 */
export class OctoprintApi extends BaseAPI implements OctoprintApiInterface {
    /**
     * 
     * @param {string} hostname 
     * @param {string} name 
     * @param {string} octoprintVersion 
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsCreate(hostname: string, name: string, octoprintVersion: string, file: any, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsCreate(hostname, name, octoprintVersion, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print backup.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintBackupsRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintBackupsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintCreate(octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {string} hash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesCreate(name: string, file: any, hash: string, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesCreate(name, file, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this gcode file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintGcodeFilesRetrieve(id: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintGcodeFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {PatchedOctoPrintServerRequest} [patchedOctoPrintServerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPartialUpdate(id: number, patchedOctoPrintServerRequest?: PatchedOctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPartialUpdate(id, patchedOctoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {PatchedOctoPrinterProfileRequest} [patchedOctoPrinterProfileRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesPartialUpdate(id: number, patchedOctoPrinterProfileRequest?: PatchedOctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesPartialUpdate(id, patchedOctoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo printer profile.
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintPrinterProfilesUpdate(id: number, octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintPrinterProfilesUpdate(id, octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrinterProfileRequest} octoPrinterProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintProfileUpdateOrCreate(octoPrinterProfileRequest: OctoPrinterProfileRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintProfileUpdateOrCreate(octoPrinterProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintServerUpdateOrCreate(octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintServerUpdateOrCreate(octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsList(page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {PatchedOctoPrintSettingsRequest} [patchedOctoPrintSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsPartialUpdate(id: number, patchedOctoPrintSettingsRequest?: PatchedOctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsPartialUpdate(id, patchedOctoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print settings.
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdate(id: number, octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdate(id, octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OctoPrintSettingsRequest} octoPrintSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest: OctoPrintSettingsRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintSettingsUpdateOrCreate(octoPrintSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this octo print server.
     * @param {OctoPrintServerRequest} octoPrintServerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public octoprintUpdate(id: number, octoPrintServerRequest: OctoPrintServerRequest, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).octoprintUpdate(id, octoPrintServerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OctoprintApi
     */
    public pisOctoprintServerList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return OctoprintApiFp(this.configuration).pisOctoprintServerList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - interface
 * @export
 * @interface SchemaApi
 */
export interface SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApiInterface
     */
    schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI implements SchemaApiInterface {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'ms' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsCreate: async (emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/email-alert-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsPartialUpdate: async (id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('emailAlertSettingsPartialUpdate', 'id', id)
            const localVarPath = `/api/email-alert-settings//{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedEmailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/email-alert-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsUpdate: async (id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('emailAlertSettingsUpdate', 'id', id)
            const localVarPath = `/api/email-alert-settings//{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailAlertSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsCreate(emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailAlertSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsCreate(emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsRetrieve(options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: any): AxiosPromise<EmailAlertSettings> {
            return localVarFp.emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - interface
 * @export
 * @interface SettingsApi
 */
export interface SettingsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id 
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    emailAlertSettingsRetrieve(options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

    /**
     * 
     * @param {number} id 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApiInterface
     */
    emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<EmailAlertSettings>;

}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI implements SettingsApiInterface {
    /**
     * 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public emailAlertSettingsCreate(emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).emailAlertSettingsCreate(emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {PatchedEmailAlertSettingsRequest} [patchedEmailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public emailAlertSettingsPartialUpdate(id: number, patchedEmailAlertSettingsRequest?: PatchedEmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).emailAlertSettingsPartialUpdate(id, patchedEmailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public emailAlertSettingsRetrieve(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).emailAlertSettingsRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {EmailAlertSettingsRequest} [emailAlertSettingsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public emailAlertSettingsUpdate(id: number, emailAlertSettingsRequest?: EmailAlertSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).emailAlertSettingsUpdate(id, emailAlertSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShopApi - axios parameter creator
 * @export
 */
export const ShopApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudPlansRetrieve: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shop/products/cloud-plans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCheckoutSuccessRetrieve: async (stripeCheckoutSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stripeCheckoutSessionId' is not null or undefined
            assertParamExists('shopCheckoutSuccessRetrieve', 'stripeCheckoutSessionId', stripeCheckoutSessionId)
            const localVarPath = `/api/shop/checkout/success/{stripe_checkout_session_id}`
                .replace(`{${"stripe_checkout_session_id"}}`, encodeURIComponent(String(stripeCheckoutSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate: async (orderCheckoutRequest: OrderCheckoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCheckoutRequest' is not null or undefined
            assertParamExists('shopOrdersCreate', 'orderCheckoutRequest', orderCheckoutRequest)
            const localVarPath = `/api/shop/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCheckoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shop/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsRetrieve: async (sku: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('shopProductsRetrieve', 'sku', sku)
            const localVarPath = `/api/shop/products/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopApi - functional programming interface
 * @export
 */
export const ShopApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudPlansRetrieve(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudPlansRetrieve(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrdersCreate(orderCheckoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedProductList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopProductsRetrieve(sku: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopProductsRetrieve(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShopApi - factory interface
 * @export
 */
export const ShopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudPlansRetrieve(page?: number, options?: any): AxiosPromise<PaginatedProductList> {
            return localVarFp.cloudPlansRetrieve(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stripeCheckoutSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: any): AxiosPromise<Order> {
            return localVarFp.shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OrderCheckoutRequest} orderCheckoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.shopOrdersCreate(orderCheckoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsList(page?: number, options?: any): AxiosPromise<PaginatedProductList> {
            return localVarFp.shopProductsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopProductsRetrieve(sku: string, options?: any): AxiosPromise<Product> {
            return localVarFp.shopProductsRetrieve(sku, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopApi - interface
 * @export
 * @interface ShopApi
 */
export interface ShopApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    cloudPlansRetrieve(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedProductList>;

    /**
     * 
     * @param {string} stripeCheckoutSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * 
     * @param {OrderCheckoutRequest} orderCheckoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig): AxiosPromise<Order>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopProductsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedProductList>;

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApiInterface
     */
    shopProductsRetrieve(sku: string, options?: AxiosRequestConfig): AxiosPromise<Product>;

}

/**
 * ShopApi - object-oriented interface
 * @export
 * @class ShopApi
 * @extends {BaseAPI}
 */
export class ShopApi extends BaseAPI implements ShopApiInterface {
    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public cloudPlansRetrieve(page?: number, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).cloudPlansRetrieve(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stripeCheckoutSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopCheckoutSuccessRetrieve(stripeCheckoutSessionId: string, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopCheckoutSuccessRetrieve(stripeCheckoutSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrderCheckoutRequest} orderCheckoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopOrdersCreate(orderCheckoutRequest: OrderCheckoutRequest, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopOrdersCreate(orderCheckoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsList(page?: number, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopApi
     */
    public shopProductsRetrieve(sku: string, options?: AxiosRequestConfig) {
        return ShopApiFp(this.configuration).shopProductsRetrieve(sku, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} piId 
         * @param {any} image 
         * @param {number} pi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsCreate: async (piId: number, image: any, pi: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisCameraSnapshotsCreate', 'piId', piId)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('pisCameraSnapshotsCreate', 'image', image)
            // verify required parameter 'pi' is not null or undefined
            assertParamExists('pisCameraSnapshotsCreate', 'pi', pi)
            const localVarPath = `/api/pis/{pi_id}/camera-snapshots/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (pi !== undefined) { 
                localVarFormParams.append('pi', pi as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsList: async (piId: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisCameraSnapshotsList', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/camera-snapshots/`
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this camera snapshot.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsRetrieve: async (id: string, piId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pisCameraSnapshotsRetrieve', 'id', id)
            // verify required parameter 'piId' is not null or undefined
            assertParamExists('pisCameraSnapshotsRetrieve', 'piId', piId)
            const localVarPath = `/api/pis/{pi_id}/camera-snapshots/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pi_id"}}`, encodeURIComponent(String(piId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} size 
         * @param {number} bufferIndex 
         * @param {number} bufferRunningtime 
         * @param {string} fileName 
         * @param {any} mp4File 
         * @param {string} syncStart 
         * @param {string} videoRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsCreate: async (id: string, size: number, bufferIndex: number, bufferRunningtime: number, fileName: string, mp4File: any, syncStart: string, videoRecording: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videoPartsCreate', 'id', id)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('videoPartsCreate', 'size', size)
            // verify required parameter 'bufferIndex' is not null or undefined
            assertParamExists('videoPartsCreate', 'bufferIndex', bufferIndex)
            // verify required parameter 'bufferRunningtime' is not null or undefined
            assertParamExists('videoPartsCreate', 'bufferRunningtime', bufferRunningtime)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('videoPartsCreate', 'fileName', fileName)
            // verify required parameter 'mp4File' is not null or undefined
            assertParamExists('videoPartsCreate', 'mp4File', mp4File)
            // verify required parameter 'syncStart' is not null or undefined
            assertParamExists('videoPartsCreate', 'syncStart', syncStart)
            // verify required parameter 'videoRecording' is not null or undefined
            assertParamExists('videoPartsCreate', 'videoRecording', videoRecording)
            const localVarPath = `/api/video-parts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }
    
            if (bufferIndex !== undefined) { 
                localVarFormParams.append('buffer_index', bufferIndex as any);
            }
    
            if (bufferRunningtime !== undefined) { 
                localVarFormParams.append('buffer_runningtime', bufferRunningtime as any);
            }
    
            if (fileName !== undefined) { 
                localVarFormParams.append('file_name', fileName as any);
            }
    
            if (mp4File !== undefined) { 
                localVarFormParams.append('mp4_file', mp4File as any);
            }
    
            if (syncStart !== undefined) { 
                localVarFormParams.append('sync_start', syncStart as any);
            }
    
            if (videoRecording !== undefined) { 
                localVarFormParams.append('video_recording', videoRecording as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/video-parts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique value identifying this video recording part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videoPartsRetrieve', 'id', id)
            const localVarPath = `/api/video-parts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingFinalizeRequest} videoRecordingFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoRecordingsFinalize: async (id: string, videoRecordingFinalizeRequest: VideoRecordingFinalizeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videoRecordingsFinalize', 'id', id)
            // verify required parameter 'videoRecordingFinalizeRequest' is not null or undefined
            assertParamExists('videoRecordingsFinalize', 'videoRecordingFinalizeRequest', videoRecordingFinalizeRequest)
            const localVarPath = `/api/videos/{id}/finalize/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoRecordingFinalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoRecordingsUpdateOrCreate: async (id: string, videoRecordingRequest?: VideoRecordingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videoRecordingsUpdateOrCreate', 'id', id)
            const localVarPath = `/api/videos/{id}/update-or-create/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoRecordingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosCreate: async (videoRecordingRequest?: VideoRecordingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/videos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoRecordingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/videos/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {PatchedVideoRecordingRequest} [patchedVideoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosPartialUpdate: async (id: string, patchedVideoRecordingRequest?: PatchedVideoRecordingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videosPartialUpdate', 'id', id)
            const localVarPath = `/api/videos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedVideoRecordingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videosRetrieve', 'id', id)
            const localVarPath = `/api/videos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUpdate: async (id: string, videoRecordingRequest?: VideoRecordingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('videosUpdate', 'id', id)
            const localVarPath = `/api/videos/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoRecordingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {any} image 
         * @param {number} pi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCameraSnapshotsCreate(piId: number, image: any, pi: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CameraSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCameraSnapshotsCreate(piId, image, pi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCameraSnapshotsList(piId: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCameraSnapshotList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCameraSnapshotsList(piId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this camera snapshot.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pisCameraSnapshotsRetrieve(id: string, piId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CameraSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pisCameraSnapshotsRetrieve(id, piId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} size 
         * @param {number} bufferIndex 
         * @param {number} bufferRunningtime 
         * @param {string} fileName 
         * @param {any} mp4File 
         * @param {string} syncStart 
         * @param {string} videoRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoPartsCreate(id: string, size: number, bufferIndex: number, bufferRunningtime: number, fileName: string, mp4File: any, syncStart: string, videoRecording: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecordingPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoPartsCreate(id, size, bufferIndex, bufferRunningtime, fileName, mp4File, syncStart, videoRecording, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoPartsList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVideoRecordingPartList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoPartsList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique value identifying this video recording part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoPartsRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecordingPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoPartsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingFinalizeRequest} videoRecordingFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoRecordingsFinalize(id: string, videoRecordingFinalizeRequest: VideoRecordingFinalizeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoRecordingsFinalize(id, videoRecordingFinalizeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoRecordingsUpdateOrCreate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoRecordingsUpdateOrCreate(id, videoRecordingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosCreate(videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosCreate(videoRecordingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedVideoRecordingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {PatchedVideoRecordingRequest} [patchedVideoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosPartialUpdate(id: string, patchedVideoRecordingRequest?: PatchedVideoRecordingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosPartialUpdate(id, patchedVideoRecordingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videosUpdate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoRecording>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videosUpdate(id, videoRecordingRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideosApiFp(configuration)
    return {
        /**
         * 
         * @param {number} piId 
         * @param {any} image 
         * @param {number} pi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsCreate(piId: number, image: any, pi: number, options?: any): AxiosPromise<CameraSnapshot> {
            return localVarFp.pisCameraSnapshotsCreate(piId, image, pi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} piId 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsList(piId: number, page?: number, options?: any): AxiosPromise<PaginatedCameraSnapshotList> {
            return localVarFp.pisCameraSnapshotsList(piId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this camera snapshot.
         * @param {number} piId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pisCameraSnapshotsRetrieve(id: string, piId: number, options?: any): AxiosPromise<CameraSnapshot> {
            return localVarFp.pisCameraSnapshotsRetrieve(id, piId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} size 
         * @param {number} bufferIndex 
         * @param {number} bufferRunningtime 
         * @param {string} fileName 
         * @param {any} mp4File 
         * @param {string} syncStart 
         * @param {string} videoRecording 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsCreate(id: string, size: number, bufferIndex: number, bufferRunningtime: number, fileName: string, mp4File: any, syncStart: string, videoRecording: string, options?: any): AxiosPromise<VideoRecordingPart> {
            return localVarFp.videoPartsCreate(id, size, bufferIndex, bufferRunningtime, fileName, mp4File, syncStart, videoRecording, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsList(page?: number, options?: any): AxiosPromise<PaginatedVideoRecordingPartList> {
            return localVarFp.videoPartsList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique value identifying this video recording part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoPartsRetrieve(id: string, options?: any): AxiosPromise<VideoRecordingPart> {
            return localVarFp.videoPartsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingFinalizeRequest} videoRecordingFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoRecordingsFinalize(id: string, videoRecordingFinalizeRequest: VideoRecordingFinalizeRequest, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videoRecordingsFinalize(id, videoRecordingFinalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoRecordingsUpdateOrCreate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videoRecordingsUpdateOrCreate(id, videoRecordingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosCreate(videoRecordingRequest?: VideoRecordingRequest, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videosCreate(videoRecordingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosList(page?: number, options?: any): AxiosPromise<PaginatedVideoRecordingList> {
            return localVarFp.videosList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {PatchedVideoRecordingRequest} [patchedVideoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosPartialUpdate(id: string, patchedVideoRecordingRequest?: PatchedVideoRecordingRequest, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videosPartialUpdate(id, patchedVideoRecordingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosRetrieve(id: string, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videosRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A UUID string identifying this video recording.
         * @param {VideoRecordingRequest} [videoRecordingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videosUpdate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: any): AxiosPromise<VideoRecording> {
            return localVarFp.videosUpdate(id, videoRecordingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideosApi - interface
 * @export
 * @interface VideosApi
 */
export interface VideosApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {any} image 
     * @param {number} pi 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    pisCameraSnapshotsCreate(piId: number, image: any, pi: number, options?: AxiosRequestConfig): AxiosPromise<CameraSnapshot>;

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    pisCameraSnapshotsList(piId: number, page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedCameraSnapshotList>;

    /**
     * 
     * @param {string} id A UUID string identifying this camera snapshot.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    pisCameraSnapshotsRetrieve(id: string, piId: number, options?: AxiosRequestConfig): AxiosPromise<CameraSnapshot>;

    /**
     * 
     * @param {string} id 
     * @param {number} size 
     * @param {number} bufferIndex 
     * @param {number} bufferRunningtime 
     * @param {string} fileName 
     * @param {any} mp4File 
     * @param {string} syncStart 
     * @param {string} videoRecording 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videoPartsCreate(id: string, size: number, bufferIndex: number, bufferRunningtime: number, fileName: string, mp4File: any, syncStart: string, videoRecording: string, options?: AxiosRequestConfig): AxiosPromise<VideoRecordingPart>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videoPartsList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedVideoRecordingPartList>;

    /**
     * 
     * @param {string} id A unique value identifying this video recording part.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videoPartsRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<VideoRecordingPart>;

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingFinalizeRequest} videoRecordingFinalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videoRecordingsFinalize(id: string, videoRecordingFinalizeRequest: VideoRecordingFinalizeRequest, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videoRecordingsUpdateOrCreate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

    /**
     * 
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videosCreate(videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videosList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedVideoRecordingList>;

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {PatchedVideoRecordingRequest} [patchedVideoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videosPartialUpdate(id: string, patchedVideoRecordingRequest?: PatchedVideoRecordingRequest, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videosRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApiInterface
     */
    videosUpdate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig): AxiosPromise<VideoRecording>;

}

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI implements VideosApiInterface {
    /**
     * 
     * @param {number} piId 
     * @param {any} image 
     * @param {number} pi 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public pisCameraSnapshotsCreate(piId: number, image: any, pi: number, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).pisCameraSnapshotsCreate(piId, image, pi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} piId 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public pisCameraSnapshotsList(piId: number, page?: number, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).pisCameraSnapshotsList(piId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this camera snapshot.
     * @param {number} piId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public pisCameraSnapshotsRetrieve(id: string, piId: number, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).pisCameraSnapshotsRetrieve(id, piId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} size 
     * @param {number} bufferIndex 
     * @param {number} bufferRunningtime 
     * @param {string} fileName 
     * @param {any} mp4File 
     * @param {string} syncStart 
     * @param {string} videoRecording 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videoPartsCreate(id: string, size: number, bufferIndex: number, bufferRunningtime: number, fileName: string, mp4File: any, syncStart: string, videoRecording: string, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videoPartsCreate(id, size, bufferIndex, bufferRunningtime, fileName, mp4File, syncStart, videoRecording, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videoPartsList(page?: number, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videoPartsList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique value identifying this video recording part.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videoPartsRetrieve(id: string, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videoPartsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingFinalizeRequest} videoRecordingFinalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videoRecordingsFinalize(id: string, videoRecordingFinalizeRequest: VideoRecordingFinalizeRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videoRecordingsFinalize(id, videoRecordingFinalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videoRecordingsUpdateOrCreate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videoRecordingsUpdateOrCreate(id, videoRecordingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosCreate(videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosCreate(videoRecordingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosList(page?: number, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {PatchedVideoRecordingRequest} [patchedVideoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosPartialUpdate(id: string, patchedVideoRecordingRequest?: PatchedVideoRecordingRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosPartialUpdate(id, patchedVideoRecordingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosRetrieve(id: string, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A UUID string identifying this video recording.
     * @param {VideoRecordingRequest} [videoRecordingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public videosUpdate(id: string, videoRecordingRequest?: VideoRecordingRequest, options?: AxiosRequestConfig) {
        return VideosApiFp(this.configuration).videosUpdate(id, videoRecordingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspacesApi - axios parameter creator
 * @export
 */
export const WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesCreate: async (workspaceRequest: WorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceRequest' is not null or undefined
            assertParamExists('workspacesCreate', 'workspaceRequest', workspaceRequest)
            const localVarPath = `/api/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesList: async (page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/workspaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {PatchedWorkspaceRequest} [patchedWorkspaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesPartialUpdate: async (id: string, page?: number, patchedWorkspaceRequest?: PatchedWorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesPartialUpdate', 'id', id)
            const localVarPath = `/api/workspaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWorkspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesRetrieve', 'id', id)
            const localVarPath = `/api/workspaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesUpdate: async (id: string, workspaceRequest: WorkspaceRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspacesUpdate', 'id', id)
            // verify required parameter 'workspaceRequest' is not null or undefined
            assertParamExists('workspacesUpdate', 'workspaceRequest', workspaceRequest)
            const localVarPath = `/api/workspaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            // authentication tokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspacesApi - functional programming interface
 * @export
 */
export const WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesCreate(workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesCreate(workspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesList(page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesList(page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {PatchedWorkspaceRequest} [patchedWorkspaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesPartialUpdate(id: string, page?: number, patchedWorkspaceRequest?: PatchedWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedWorkspaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesPartialUpdate(id, page, patchedWorkspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspacesUpdate(id: string, workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspacesUpdate(id, workspaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspacesApi - factory interface
 * @export
 */
export const WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesCreate(workspaceRequest: WorkspaceRequest, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspacesCreate(workspaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesList(page?: number, options?: any): AxiosPromise<PaginatedWorkspaceList> {
            return localVarFp.workspacesList(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] A page number within the paginated result set.
         * @param {PatchedWorkspaceRequest} [patchedWorkspaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesPartialUpdate(id: string, page?: number, patchedWorkspaceRequest?: PatchedWorkspaceRequest, options?: any): AxiosPromise<PaginatedWorkspaceList> {
            return localVarFp.workspacesPartialUpdate(id, page, patchedWorkspaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesRetrieve(id: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspacesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {WorkspaceRequest} workspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspacesUpdate(id: string, workspaceRequest: WorkspaceRequest, options?: any): AxiosPromise<Workspace> {
            return localVarFp.workspacesUpdate(id, workspaceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspacesApi - interface
 * @export
 * @interface WorkspacesApi
 */
export interface WorkspacesApiInterface {
    /**
     * 
     * @param {WorkspaceRequest} workspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    workspacesCreate(workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<Workspace>;

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    workspacesList(page?: number, options?: AxiosRequestConfig): AxiosPromise<PaginatedWorkspaceList>;

    /**
     * 
     * @param {string} id 
     * @param {number} [page] A page number within the paginated result set.
     * @param {PatchedWorkspaceRequest} [patchedWorkspaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    workspacesPartialUpdate(id: string, page?: number, patchedWorkspaceRequest?: PatchedWorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<PaginatedWorkspaceList>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    workspacesRetrieve(id: string, options?: AxiosRequestConfig): AxiosPromise<Workspace>;

    /**
     * 
     * @param {string} id 
     * @param {WorkspaceRequest} workspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApiInterface
     */
    workspacesUpdate(id: string, workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<Workspace>;

}

/**
 * WorkspacesApi - object-oriented interface
 * @export
 * @class WorkspacesApi
 * @extends {BaseAPI}
 */
export class WorkspacesApi extends BaseAPI implements WorkspacesApiInterface {
    /**
     * 
     * @param {WorkspaceRequest} workspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesCreate(workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesCreate(workspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesList(page?: number, options?: AxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesList(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [page] A page number within the paginated result set.
     * @param {PatchedWorkspaceRequest} [patchedWorkspaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesPartialUpdate(id: string, page?: number, patchedWorkspaceRequest?: PatchedWorkspaceRequest, options?: AxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesPartialUpdate(id, page, patchedWorkspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesRetrieve(id: string, options?: AxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {WorkspaceRequest} workspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspacesApi
     */
    public workspacesUpdate(id: string, workspaceRequest: WorkspaceRequest, options?: AxiosRequestConfig) {
        return WorkspacesApiFp(this.configuration).workspacesUpdate(id, workspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


